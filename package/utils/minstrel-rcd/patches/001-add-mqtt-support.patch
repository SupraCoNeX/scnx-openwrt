--- /dev/null
+++ b/mqtt.c
@@ -0,0 +1,458 @@
+#include <errno.h>
+#include <mqtt_protocol.h>
+#include "rcd.h"
+
+static LIST_HEAD(brokers);
+static LIST_HEAD(pending);
+static struct uloop_timeout restart_timer;
+static struct uloop_timeout mosquitto_misc_timer;
+
+#define KEEPALIVE_SECONDS 5 // TODO: make configurable
+#define MOSQUITTO_MAINTENANCE_FREQ_MS 1000
+
+/* Max length for topic string is 64KB
+ *(https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_UTF-8_Encoded_String)
+ */
+#define TOPIC_MAXLEN 65536
+#define TOPIC_BASELEN 5 // '.../api/...'
+
+static int
+validate_topic(const char *topic, const char *id)
+{
+	size_t topic_len;
+
+	if (topic) {
+		topic_len = strlen(topic);
+
+		if (topic[topic_len - 1] != '/') {
+			fprintf(stderr, "WARNING: Topic prefix '%s' does not end with '/'\n", topic);
+			return -1;
+		}
+	} else {
+		topic_len = 0;
+	}
+
+	if (!id) {
+		fprintf(stderr, "WARNING: Skipping a broker because no ID was given.\n");
+		return -1;
+	}
+
+	if (topic_len + strlen(id) + TOPIC_BASELEN > TOPIC_MAXLEN) {
+		fprintf(stderr, "Given topic strings can exceed the maximum length of 64KB. "
+			"Please reconsider what you are doing.\n");
+		return -1;
+	}
+
+	return 0;
+}
+
+static int
+__add_broker(char *addr, int port, const char *bind_addr, const char *id, const char *topic)
+{
+	struct mqtt_context *ctx;
+
+	ctx = calloc(1, sizeof(*ctx));
+	if (!ctx) {
+		fprintf(stderr, "ERROR: Out of memory!\n");
+		return -1;
+	}
+
+	ctx->id = id;
+	ctx->addr = addr;
+	ctx->port = port;
+	ctx->bind_addr = bind_addr ? bind_addr : "::";
+	ctx->topic_prefix = topic ? topic : "";
+
+	printf("add broker {'addr': %s, 'port': '%d', 'bind': %s, 'id': '%s', 'prefix': '%s'}\n",
+		ctx->addr, ctx->port, ctx->bind_addr, ctx->id, ctx->topic_prefix);
+
+	list_add_tail(&ctx->list, &pending);
+	return 0;
+}
+
+void
+mqtt_broker_add_cli(const char *addr, const char *bind_addr, const char *id,
+					const char *topic_prefix)
+{
+	char *sep, *buf;
+	int port, err;
+
+	err = validate_topic(topic_prefix, id);
+	if (err)
+		return;
+
+	/* IPv6 addresses are enclosed in [] */
+	if (*addr == '[') {
+		sep = strrchr(addr, ']');
+		if (!sep) {
+			fprintf(stderr, "ERROR: invalid IPv6 address '%s' (enclose in '[]')\n", addr);
+			return;
+		} else {
+			++sep;
+		}
+	} else {
+		sep = strchrnul(addr, ':');
+	}
+
+	port = (sep[0]) ? (sep[1] ? atoi(sep + 1) : MQTT_PORT) : MQTT_PORT;
+
+	buf = calloc(sep - addr + 1, 1);
+	if (!buf) {
+		fprintf(stderr, "ERROR: Out of memory\n");
+		return;
+	}
+
+	strncpy(buf, addr, sep - addr);
+
+	err = __add_broker(buf, port, bind_addr, id, topic_prefix);
+	if (err)
+		free(buf);
+}
+
+void
+mqtt_broker_add(const char *addr, int port, const char *bind_addr, const char *id,
+				const char *topic_prefix)
+{
+	char *buf;
+	size_t addrlen;
+	int err;
+
+	err = validate_topic(topic_prefix, id);
+	if (err)
+		return;
+
+	addrlen = strlen(addr);
+	buf = calloc(addrlen + 1, 1);
+	if (!buf) {
+		fprintf(stderr, "ERROR: Out fo memory\n");
+		return;
+	}
+
+	strncpy(buf, addr, addrlen);
+	__add_broker(buf, port, bind_addr, id, topic_prefix);
+}
+
+static int
+mqtt_connect(struct mqtt_context *ctx, bool reconnect)
+{
+	int err;
+
+	if (reconnect)
+		err = mosquitto_reconnect(ctx->mosq);
+	else
+		err = mosquitto_connect_bind_v5(ctx->mosq, ctx->addr, ctx->port, KEEPALIVE_SECONDS,
+										ctx->bind_addr, NULL);
+
+	if (err) {
+		fprintf(stderr, "%s: connecting to %s:%d via %s failed: %s\n",
+			ctx->id, ctx->addr, ctx->port, ctx->bind_addr,
+			err == MOSQ_ERR_ERRNO ? strerror(errno) : mosquitto_strerror(err));
+		return err;
+	}
+
+	list_move_tail(&ctx->list, &brokers);
+	return 0;
+}
+
+static int
+mqtt_publish(struct mqtt_context *ctx, const char *topic, const void *data, int len, bool api,
+			 bool retain, int qos, mosquitto_property *props)
+{
+	static char buf[TOPIC_MAXLEN + 1];
+	int chars;
+
+	chars = snprintf(buf, TOPIC_MAXLEN, api ? "%s%s/api/%s" : "%s%s/%s",
+		ctx->topic_prefix ? ctx->topic_prefix : "",
+		ctx->id, topic);
+
+	if (chars >= TOPIC_MAXLEN) {
+		fprintf(stderr, "Topic exceeds maximum length of %d\n", TOPIC_MAXLEN);
+		return -1;
+	}
+
+	return mosquitto_publish_v5(ctx->mosq, NULL, buf, len, data, qos, retain, props);
+}
+
+static inline int
+mqtt_publish_api(struct mqtt_context *ctx, const char *topic, const void *data, int len,
+				 mosquitto_property *props)
+{
+	return mqtt_publish(ctx, topic, data, len, true, true, 1, props);
+}
+
+static int
+phy_dump_cb(void *arg, char *buf)
+{
+	struct mqtt_context *ctx = arg;
+	char *newline, *sep;
+
+	sep = strchr(buf, ';');
+	if (!sep)
+		return -1;
+
+	*sep++ = '\0';
+	newline = strrchr(sep, '\n');
+	if (newline)
+		*newline = '\0';
+
+	if (*buf == '#') {
+		buf++;
+		return mqtt_publish_api(ctx, buf, sep, strlen(sep), NULL);
+	}
+
+	return mqtt_publish(ctx, buf, sep, strlen(sep), false, true, 1, NULL);
+}
+
+void
+mqtt_phy_event(struct phy *phy, const char *str)
+{
+	static char topic_buf[16];
+	const char *timestamp;
+	char *topic_ptr, *tmp, ev_buf[128];
+
+	struct mqtt_context *ctx;
+
+	list_for_each_entry(ctx, &brokers, list) {
+		timestamp = str;
+		tmp = strchr(str, ';');
+		if (!tmp)
+			return;
+		*tmp = '\0';
+
+		topic_ptr = ++tmp;
+		tmp = strchr(tmp, ';');
+		if (!topic_ptr)
+			return;
+		*tmp = '\0';
+
+		snprintf(topic_buf, 16, "%s/%s", phy_name(phy), topic_ptr);
+		snprintf(ev_buf, 128, "%s;%s", timestamp, ++tmp);
+
+		mqtt_publish(ctx, topic_buf, ev_buf, strlen(ev_buf), false, false, 0, NULL);
+	}
+}
+
+static inline int
+mqtt_phy_publish(struct mqtt_context *ctx, struct phy *phy, bool add)
+{
+	return mqtt_publish(ctx, phy_name(phy),
+						add ? "0;add" : "0;remove",
+						add ? 5 : 8,
+						false, true, 1, NULL);
+}
+
+static void
+mqtt_set_phy_state(struct mqtt_context *ctx, struct phy *phy, bool add)
+{
+	if (!ctx) {
+		list_for_each_entry(ctx, &brokers, list)
+			mqtt_set_phy_state(ctx, phy, add);
+		return;
+	}
+
+	if (add && !ctx->init_done) {
+		mqtt_phy_dump(phy, phy_dump_cb, ctx);
+		ctx->init_done = true;
+	}
+
+	mqtt_phy_publish(ctx, phy, add);
+}
+
+static void
+mqtt_ctl_subscribe(struct mqtt_context *ctx)
+{
+	static char all_nodes[128];
+	static char this_node[128];
+	static char *const topics[2] = {all_nodes, this_node};
+	int err;
+
+	err = snprintf(all_nodes, 128, "%sctl/all", ctx->topic_prefix);
+	if (err >= 128)
+		goto too_long;
+
+	err = snprintf(this_node, 128, "%sctl/%s", ctx->topic_prefix, ctx->id);
+	if (err >= 128)
+		goto too_long;
+
+	err = mosquitto_subscribe_multiple(ctx->mosq, NULL, 2, topics, 1,
+									   MQTT_SUB_OPT_SEND_RETAIN_NEVER, NULL);
+	if (err)
+		fprintf(stderr, "Failed to subscribe to control topics: %s\n", mosquitto_strerror(err));
+
+	return;
+
+too_long:
+	fprintf(stderr, "Failed to subscribe to control topics: topic too long\n");
+}
+
+static void
+on_connect(struct mosquitto *mosq, void *arg, int rc, int flags, const mosquitto_property *prop)
+{
+	enum {
+		CONN_REFUSED_INVALID_PROTO = 1,
+		CONN_REFUSED_ID_REJECTED = 2,
+		CONN_REFUSED_BROKER_UNAVAIL = 3,
+		__CONN_MAX
+	};
+
+	static const char *rc_str[__CONN_MAX] = {
+		[CONN_REFUSED_INVALID_PROTO] = "invalid protocol",
+		[CONN_REFUSED_ID_REJECTED] = "ID rejected",
+		[CONN_REFUSED_BROKER_UNAVAIL] = "broker unavailable",
+	};
+
+	struct phy *phy;
+	struct mqtt_context *ctx = arg;
+
+	if (rc) {
+		fprintf(stderr, "%s:%s:%d > Connection refused: %s",
+			ctx->id, ctx->addr, ctx->port, rc_str[rc]);
+		return;
+	}
+
+	vlist_for_each_element(&phy_list, phy, node)
+		mqtt_set_phy_state(ctx, phy, true);
+
+	mqtt_ctl_subscribe(ctx);
+}
+
+static void
+on_disconnect(struct mosquitto *mosq, void *arg, int reason, const mosquitto_property *prop)
+{
+	bool others_pending;
+	struct mqtt_context *ctx = arg;
+
+	fprintf(stderr, "%s lost connection to %s:%d\n", ctx->id, ctx->addr, ctx->port);
+
+	uloop_fd_delete(&ctx->fd);
+
+	others_pending = !list_empty(&pending);
+	list_add_tail(&ctx->list, &pending);
+	if (!others_pending)
+		uloop_timeout_set(&restart_timer, 100);
+}
+
+static void
+on_message(struct mosquitto *mosq, void *arg, const struct mosquitto_message *msg,
+		   const mosquitto_property *prop)
+{
+	char buf[msg->payloadlen + 1];
+	strncpy(buf, (char*) msg->payload, msg->payloadlen);
+	buf[msg->payloadlen] = '\0';
+
+	rcd_phy_control(NULL, buf);
+}
+
+static void
+mqtt_handle_sock_event(struct uloop_fd *fd, unsigned int events)
+{
+	struct mqtt_context *ctx = container_of(fd, struct mqtt_context, fd);
+
+	if (events & ULOOP_READ)
+		mosquitto_loop_read(ctx->mosq, 1);
+}
+
+static void
+mqtt_connect_pending(struct uloop_timeout *timeout)
+{
+	static const char *will_msg = "disconnected";
+	struct mqtt_context *ctx, *tmp;
+	bool reconnect;
+	int err;
+
+	list_for_each_entry_safe(ctx, tmp, &pending, list) {
+		if (!ctx->mosq) {
+			reconnect = false;
+			ctx->mosq = mosquitto_new(ctx->id, false, ctx);
+			if (!ctx->mosq) {
+				fprintf(stderr, "%s:%s:%d > Failed to initialize mosquitto client: %s\n",
+					ctx->id, ctx->addr, ctx->port, strerror(errno));
+				exit(errno);
+			}
+			mosquitto_connect_v5_callback_set(ctx->mosq, on_connect);
+			mosquitto_message_v5_callback_set(ctx->mosq, on_message);
+			mosquitto_disconnect_v5_callback_set(ctx->mosq, on_disconnect);
+		} else {
+			reconnect = true;
+		}
+
+		err = mosquitto_will_set_v5(ctx->mosq, ctx->id, strlen(will_msg), will_msg, 0, false, NULL);
+		if (err)
+			fprintf(stderr, "%s:%s:%d WARNING: setting will failed: %s\n",
+					ctx->id, ctx->addr, ctx->port, mosquitto_strerror(err));
+
+		err = mqtt_connect(ctx, reconnect);
+		if (err)
+			continue;
+
+		ctx->fd.fd = mosquitto_socket(ctx->mosq);
+		ctx->fd.cb = mqtt_handle_sock_event;
+		uloop_fd_add(&ctx->fd, ULOOP_READ);
+	}
+
+	if (!list_empty(&pending))
+		uloop_timeout_set(timeout, 100);
+}
+
+static void
+mqtt_context_destroy(struct mqtt_context *ctx)
+{
+	mosquitto_destroy(ctx->mosq);
+	free(ctx->addr);
+	free(ctx);
+}
+
+void
+mqtt_stop(void)
+{
+	struct mqtt_context *ctx, *tmp;
+
+	uloop_timeout_cancel(&restart_timer);
+
+	list_for_each_entry_safe(ctx, tmp, &pending, list) {
+		list_del(&ctx->list);
+		mqtt_context_destroy(ctx);
+	}
+
+	list_for_each_entry_safe(ctx, tmp, &brokers, list) {
+		list_del(&ctx->list);
+		mosquitto_disconnect_v5(ctx->mosq, -1, NULL);
+		mqtt_context_destroy(ctx);
+	}
+
+	mosquitto_lib_cleanup();
+}
+
+static void
+mqtt_maintain(struct uloop_timeout *timeout)
+{
+	struct mqtt_context *ctx;
+	int err;
+
+	list_for_each_entry(ctx, &brokers, list) {
+		err = mosquitto_loop_misc(ctx->mosq);
+		switch (err) {
+			case MOSQ_ERR_INVAL:
+				fprintf(stderr, "%s:%s:%d > error during periodic maintenance of mqtt connection\n",
+					ctx->id, ctx->addr, ctx->port);
+					break;
+			case MOSQ_ERR_NO_CONN:
+				mqtt_connect(ctx, true);
+				break;
+		}
+	}
+
+	uloop_timeout_set(timeout, MOSQUITTO_MAINTENANCE_FREQ_MS);
+}
+
+void
+mqtt_init()
+{
+	mosquitto_lib_init();
+
+	restart_timer.cb = mqtt_connect_pending;
+	mqtt_connect_pending(&restart_timer);
+
+	mosquitto_misc_timer.cb = mqtt_maintain;
+	uloop_timeout_set(&mosquitto_misc_timer, MOSQUITTO_MAINTENANCE_FREQ_MS);
+}
--- a/phy.c
+++ b/phy.c
@@ -33,6 +33,9 @@ phy_event_read_buf(struct phy *phy, char
 		*next = 0;
 
 		rcd_client_phy_event(phy, cur);
+#ifdef CONFIG_MQTT
+		mqtt_phy_event(phy, cur);
+#endif
 	}
 
 	len = strlen(cur);
@@ -176,6 +179,23 @@ void rcd_phy_dump(struct client *cl, str
 	fclose(f);
 }
 
+#ifdef CONFIG_MQTT
+void mqtt_phy_dump(struct phy *phy, int (*cb)(void*, char*), void *cb_arg)
+{
+	char buf[128];
+	FILE *f;
+
+	f = fopen(phy_file_path(phy, "api_info"), "r");
+	if (!f)
+		return;
+
+	while (fgets(buf, sizeof(buf), f) != NULL)
+		cb(cb_arg, buf);
+
+	fclose(f);
+}
+#endif
+
 void rcd_phy_control(struct client *cl, char *data)
 {
 	struct phy *phy;
@@ -208,6 +228,13 @@ retry:
 	return;
 
 error:
+#ifdef CONFIG_MQTT
+	/* do not send error messages over mqtt */
+	if (!cl) {
+		fprintf(stderr, "mqtt command '%s' failed: %s\n", data, err);
+		return;
+	}
+#endif
 	client_printf(cl, "*;0;#error;%s\n", err);
 }
 
--- a/rcd.h
+++ b/rcd.h
@@ -15,8 +15,21 @@
 #include <stdio.h>
 #include <unistd.h>
 
+#ifdef CONFIG_MQTT
+#include <mosquitto.h>
+
+#define MQTT_PORT 1883
+#endif
+
 #define RCD_PORT 0x5243
 
+extern const char *config_path;
+
+#ifdef CONFIG_MQTT
+extern const char *global_id;
+extern const char *global_topic;
+#endif
+
 struct phy {
 	struct vlist_node node;
 
@@ -36,6 +49,21 @@ struct server {
 	const char *addr;
 };
 
+#ifdef CONFIG_MQTT
+struct mqtt_context {
+	struct list_head list;
+	struct mosquitto *mosq;
+	const char *id;
+	char *addr;
+	int port;
+	const char *bind_addr;
+	const char *topic_prefix;
+	struct uloop_fd fd;
+	bool init_done;
+};
+#endif
+
+
 static inline const char *phy_name(struct phy *phy)
 {
 	return phy->node.avl.key;
@@ -58,4 +86,17 @@ void rcd_phy_control(struct client *cl,
 #define client_printf(cl, ...) ustream_printf(&(cl)->sfd.stream, __VA_ARGS__)
 #define client_phy_printf(cl, phy, fmt, ...) client_printf(cl, "%s;" fmt, phy_name(phy), ## __VA_ARGS__)
 
+#ifdef CONFIG_MQTT
+void rcd_config_init(void);
+void mqtt_init(void);
+void mqtt_broker_add(const char *addr, int port, const char *bind, const char *id,
+					 const char *prefix);
+void mqtt_broker_add_cli(const char *addr, const char *bind, const char *id, const char *prefix);
+int mqtt_publish_event(const struct phy *phy, const char *str);
+void mqtt_stop(void);
+
+void mqtt_phy_dump(struct phy *phy, int (*cb)(void *, char*), void *cb_arg);
+void mqtt_phy_event(struct phy *phy, const char *str);
+#endif
+
 #endif
--- a/main.c
+++ b/main.c
@@ -4,25 +4,99 @@
 #include <libubox/ustream.h>
 #include "rcd.h"
 
+const char *config_path = NULL; /* use the default set in libuci */
+
+static void
+usage(void)
+{
+	fprintf(stderr, "usage: minstrel-rcd [-h INTERFACE]");
+#ifdef CONFIG_MQTT
+	fprintf(stderr, " [-i ID] [-t TOPIC_PREFIX] [-b BROKER]\n"
+					"       where ID is used to identify with the broker,\n"
+					"       TOPIC_PREFIX is prepended to all mqtt messages published by this node, and\n"
+					"       BROKER is ADDRESS[:PORT] for IPv4 and '[ADDRESS]'[:PORT] for IPv6\n"
+					"       Note: You may connect to multiple brokers re-using all options expcept BROKER.\n"
+					"             Simply provide them before specifying the broker.\n");
+#endif
+	fprintf(stderr, "\n");
+}
+
+static void
+rcd_stop(int signo)
+{
+#ifdef CONFIG_MQTT
+	mqtt_stop();
+#endif
+	uloop_end();
+}
+
+static void
+rcd_setup_signals(void)
+{
+	struct sigaction s;
+
+	memset(&s, 0, sizeof(s));
+	s.sa_handler = rcd_stop;
+	s.sa_flags = 0;
+	sigaction(SIGINT, &s, NULL);
+	sigaction(SIGTERM, &s, NULL);
+	sigaction(SIGUSR1, &s, NULL);
+	sigaction(SIGUSR2, &s, NULL);
+
+	s.sa_handler = SIG_IGN;
+	sigaction(SIGPIPE, &s, NULL);
+}
+
 int main(int argc, char **argv)
 {
 	int ch;
 
+#ifdef CONFIG_MQTT
+	const char *bind_addr = NULL;
+	const char *mqtt_id = NULL;
+	const char *topic = NULL;
+#endif
+
 	uloop_init();
 
-	while ((ch = getopt(argc, argv, "h:")) != -1) {
+#ifdef CONFIG_MQTT
+	rcd_config_init();
+#endif
+
+	while ((ch = getopt(argc, argv, "h:i:b:t:")) != -1) {
 		switch (ch) {
 		case 'h':
 			rcd_server_add(optarg);
+#ifdef CONFIG_MQTT
+			bind_addr = optarg;
+			break;
+		case 'i':
+			mqtt_id = optarg;
 			break;
+		case 't':
+			topic = optarg;
+			break;
+		case 'b':
+			mqtt_broker_add_cli(optarg, bind_addr, mqtt_id, topic);
+#endif
+			break;
+		default:
+			usage();
+			exit(1);
 		}
 	}
 
+	rcd_setup_signals();
+
 	rcd_phy_init();
 	rcd_server_init();
+#ifdef CONFIG_MQTT
+	mqtt_init();
+#endif
+
 	uloop_run();
 
-	uloop_end();
+	rcd_stop(-1);
 
 	return 0;
 }
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -2,6 +2,8 @@ cmake_minimum_required(VERSION 2.6)
 
 PROJECT(minstrel-rcd C)
 
+SET(SOURCES main.c phy.c server.c client.c)
+
 ADD_DEFINITIONS(-Wall -Werror)
 IF(CMAKE_C_COMPILER_VERSION VERSION_GREATER 6)
 	ADD_DEFINITIONS(-Wextra -Werror=implicit-function-declaration)
@@ -13,8 +15,22 @@ FIND_LIBRARY(ubox_library NAMES ubox)
 FIND_PATH(ubox_include_dir libubox/usock.h)
 INCLUDE_DIRECTORIES(${ubox_include_dir})
 
-ADD_EXECUTABLE(minstrel-rcd main.c phy.c server.c client.c)
-TARGET_LINK_LIBRARIES(minstrel-rcd ${ubox_library})
+FIND_LIBRARY(uci_library NAMES uci)
+FIND_PATH(uci_include_dir uci.h)
+INCLUDE_DIRECTORIES(${uci_include_dir})
+SET(LIBS ${ubox_library} ${uci_library})
+
+IF(DEFINED CONFIG_MQTT)
+	FIND_LIBRARY(mosquitto_library NAMES mosquitto)
+	FIND_PATH(mosquitto_include_dir mosquitto.h)
+	INCLUDE_DIRECTORIES(${mosquitto_include_dir})
+	SET(SOURCES ${SOURCES} mqtt.c config.c)
+	SET(LIBS ${LIBS} ${mosquitto_library})
+	ADD_DEFINITIONS(-DCONFIG_MQTT -D_GNU_SOURCE)
+ENDIF()
+
+ADD_EXECUTABLE(minstrel-rcd ${SOURCES})
+TARGET_LINK_LIBRARIES(minstrel-rcd ${LIBS})
 
 INSTALL(TARGETS minstrel-rcd
 	RUNTIME DESTINATION sbin
--- /dev/null
+++ b/config.c
@@ -0,0 +1,105 @@
+#include <uci.h>
+
+#include "rcd.h"
+
+static struct uci_context *uci_ctx = NULL;
+static struct uci_package *config = NULL;
+
+#ifdef CONFIG_MQTT
+const char *global_id = NULL;
+const char *global_topic = NULL;
+#endif
+
+static struct uci_package*
+config_init_package(const char *config)
+{
+	struct uci_context *ctx = uci_ctx;
+	struct uci_package *p;
+
+	if (!ctx) {
+		ctx = uci_alloc_context();
+		uci_ctx = ctx;
+
+		ctx->flags &= ~UCI_FLAG_STRICT;
+		if (config_path)
+			uci_set_confdir(ctx, config_path);
+	} else {
+		p = uci_lookup_package(ctx, config);
+		if (p)
+			uci_unload(ctx, p);
+	}
+
+	if (uci_load(ctx, config, &p))
+		return NULL;
+
+	return p;
+}
+
+#ifdef CONFIG_MQTT
+static void
+config_init_globals(void)
+{
+	struct uci_section *globals = uci_lookup_section(uci_ctx, config, "rcd");
+	if (globals) {
+		global_id = uci_lookup_option_string(uci_ctx, globals, "id");
+		global_topic = uci_lookup_option_string(uci_ctx, globals, "topic");
+	}
+}
+
+static void
+config_parse_mqtt_broker(struct uci_section *s)
+{
+	const char *bind_addr, *id, *addr, *topic, *portstr;
+	int port;
+
+	addr = uci_lookup_option_string(uci_ctx, s, "addr");
+	if (!addr)
+		return;
+
+	portstr = uci_lookup_option_string(uci_ctx, s, "port");
+	port = portstr ? atoi(portstr) : MQTT_PORT;
+
+	id = uci_lookup_option_string(uci_ctx, s, "id");
+	if (!id)
+		id = global_id;
+
+	bind_addr = uci_lookup_option_string(uci_ctx, s, "bindaddr");
+	topic = uci_lookup_option_string(uci_ctx, s, "topic");
+
+	if (!id)
+		return;
+
+	mqtt_broker_add(addr, port, bind_addr, id, topic);
+}
+
+static void
+config_init_mqtt(void)
+{
+	struct uci_element *e;
+	uci_foreach_element(&config->sections, e) {
+		struct uci_section *s = uci_to_section(e);
+
+		if (strcmp(s->type, "mqtt") == 0)
+			config_parse_mqtt_broker(s);
+	}
+}
+#endif
+
+void
+rcd_config_init(void)
+{
+	char *errstr;
+
+	config = config_init_package("minstrel-rcd");
+	if (!config && uci_ctx->err != UCI_ERR_NOTFOUND) {
+		uci_get_errorstr(uci_ctx, &errstr, NULL);
+		fprintf(stderr, "ERROR: Failed to load config: %s\n", errstr);
+		free(errstr);
+		return;
+	}
+
+#ifdef CONFIG_MQTT
+	config_init_globals();
+	config_init_mqtt();
+#endif
+}
\ No newline at end of file
