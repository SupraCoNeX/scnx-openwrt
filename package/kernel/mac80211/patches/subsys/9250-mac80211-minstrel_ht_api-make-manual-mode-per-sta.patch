--- a/net/mac80211/rc80211_minstrel_ht_api.c
+++ b/net/mac80211/rc80211_minstrel_ht_api.c
@@ -16,7 +16,15 @@
 
 extern u8 sample_table[SAMPLE_COLUMNS][MCS_GROUP_RATES];
 
-enum sta_cmd {
+enum api_cmd {
+	PHY_CMD_START,
+	PHY_CMD_STOP,
+	PHY_CMD_DUMP,
+
+	/* per-STA commands */
+	STA_CMD_AUTO,
+	STA_CMD_MANUAL,
+	STA_CMD_RESET_STATS,
 	STA_CMD_PROBE,
 	STA_CMD_TPRC,
 };
@@ -52,7 +60,7 @@ minstrel_ht_read_api_info(struct seq_fil
 	        seq_printf(s, ";airtime%d", i);
         seq_printf(s, "\n");
 
-	seq_printf(s, "#sta;action;macaddr;iface;overhead_mcs;overhead_legacy");
+	seq_printf(s, "#sta;action;macaddr;iface;rc_mode;overhead_mcs;overhead_legacy");
 	for (i = 0; i < MINSTREL_GROUPS_NB; i++)
 	        seq_printf(s, ";mcs%d", i);
 	seq_printf(s, "\n");
@@ -84,6 +92,7 @@ minstrel_ht_read_api_info(struct seq_fil
 	seq_printf(s, "\n");
 
 	seq_printf(s, "#reset_stats;macaddr\n");
+	seq_printf(s, "#reset_stats;all\n");
 
 	seq_printf(s, "#set_rates_power;macaddr");
 	for (i = 0; i < IEEE80211_TX_MAX_RATES; i++)
@@ -137,7 +146,6 @@ minstrel_ht_read_phy_info(struct seq_fil
 	struct wiphy *wiphy = container_of(s->private, struct wiphy, dev);
 	struct ieee80211_local *local = wiphy_priv(wiphy);
 	struct ieee80211_sub_if_data *sdata;
-	struct minstrel_priv *mp = local->rate_ctrl->priv;
 	int i = 0;
 
 	seq_printf(s, "drv;%s\n", wiphy_dev(wiphy)->driver->name);
@@ -152,8 +160,7 @@ minstrel_ht_read_phy_info(struct seq_fil
 		}
 	}
 	mutex_unlock(&local->iflist_mtx);
-
-	seq_printf(s, "\nrc_mode;%s\n", mp->manual ? "manual" : "auto");
+	seq_printf(s, "\n");
 
 	if (ieee80211_hw_check(&local->hw, SUPPORTS_TPC_PER_PACKET)) {
 		seq_printf(s, "tpc;pkt");
@@ -215,10 +222,12 @@ minstrel_ht_dump_sta(struct minstrel_pri
 	int i;
 
 	sta_info = container_of(mi->sta, struct sta_info, sta);
-	ofs += scnprintf(info + ofs, sizeof(info) - ofs, "%llx;sta;%s;%pM;%s;%x;%x;",
-			(unsigned long long)ktime_get_real_fast_ns(), type,
-			mi->sta->addr, sta_info->sdata->name, mi->overhead,
-			mi->overhead_legacy);
+	ofs += scnprintf(info + ofs, sizeof(info) - ofs,
+			 "%llx;sta;%s;%pM;%s;%s;%x;%x;",
+			 (unsigned long long)ktime_get_real_fast_ns(), type,
+			 mi->sta->addr, sta_info->sdata->name,
+			 mi->rc_manual ? "manual" : "auto",
+			 mi->overhead, mi->overhead_legacy);
 
 	ofs += scnprintf(info + ofs, sizeof(info) - ofs, "%x",
 			 mi->supported[0]);
@@ -321,23 +330,16 @@ minstrel_ht_reset_sample_table(struct mi
 }
 
 static void
-minstrel_ht_api_set_manual(struct minstrel_priv *mp, bool manual)
+minstrel_ht_api_sta_set_rc_manual(struct minstrel_ht_sta *mi, bool manual)
 {
-	struct minstrel_ht_sta *mi;
-
-	mp->manual = manual;
-
-	rcu_read_lock();
-	list_for_each_entry_rcu(mi, &mp->stations, list) {
-		spin_lock_bh(&mi->lock);
+	spin_lock_bh(&mi->lock);
 
-		minstrel_ht_reset_sample_table(mi);
-		kfree(mi->ratetbl);
-		mi->ratetbl = NULL;
+	mi->rc_manual = manual;
+	minstrel_ht_reset_sample_table(mi);
+	kfree(mi->ratetbl);
+	mi->ratetbl = NULL;
 
-		spin_unlock_bh(&mi->lock);
-	}
-	rcu_read_unlock();
+	spin_unlock_bh(&mi->lock);
 }
 
 static struct minstrel_ht_sta *
@@ -413,6 +415,8 @@ minstrel_ht_set_probe_rate(struct minstr
 	int rate;
 	s16 max_power;
 
+	if (!mi->rc_manual)
+		return -EPERM;
 	if (!rate_str || !count_str)
 		return -EINVAL;
 
@@ -450,6 +454,8 @@ minstrel_ht_set_rates(struct minstrel_pr
 	int i;
 	s16 max_power;
 
+	if (!mi->rc_manual)
+		return -EPERM;
 	if (!stages || !stages[0] || !n_stages)
 		return -EINVAL;
 
@@ -511,8 +517,27 @@ error:
 	return err;
 }
 
+static void
+minstrel_ht_api_sta_reset_rc_stats(struct minstrel_priv *mp, struct minstrel_ht_sta *mi)
+{
+	mi->ampdu_len = 0;
+	mi->ampdu_packets = 0;
+	mi->avg_ampdu_len = MINSTREL_FRAC(1, 1);
+	memset(&mi->max_tp_rate, 0, sizeof(u16) * MAX_THR_RATES);
+	mi->max_prob_rate = 0;
+	mi->total_packets = 0;
+	mi->sample_packets = 0;
+	mi->sample_rate = 0;
+	memset(&mi->sample, 0, sizeof(struct minstrel_sample_category) *
+			       __MINSTREL_SAMPLE_TYPE_MAX);
+	memset(&mi->groups, 0, sizeof(struct minstrel_mcs_group_data) *
+			       MINSTREL_GROUPS_NB);
+
+	minstrel_ht_update_stats(mp, mi);
+}
+
 static int
-minstrel_ht_api_sta_cmd(struct minstrel_priv *mp, enum sta_cmd cmd,
+minstrel_ht_api_sta_cmd(struct minstrel_priv *mp, enum api_cmd cmd,
 			char *arg_str)
 {
 	struct minstrel_ht_sta *mi;
@@ -521,9 +546,6 @@ minstrel_ht_api_sta_cmd(struct minstrel_
 	int n_args;
 	int ret = -EINVAL;
 
-	if (!mp->manual)
-		return -EINVAL;
-
 	n_args = minstrel_ht_get_args(args, ARRAY_SIZE(args), arg_str, ";");
 	if (!args[0])
 		return -EINVAL;
@@ -544,91 +566,103 @@ minstrel_ht_api_sta_cmd(struct minstrel_
 	case STA_CMD_TPRC:
 		ret = minstrel_ht_set_rates(mp, mi, &args[1], n_args - 1);
 		break;
+	case STA_CMD_AUTO:
+		minstrel_ht_api_sta_set_rc_manual(mi, false);
+		break;
+	case STA_CMD_MANUAL:
+		minstrel_ht_api_sta_set_rc_manual(mi, true);
+		break;
+	case STA_CMD_RESET_STATS:
+		minstrel_ht_api_sta_reset_rc_stats(mp, mi);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
 	}
 
 	spin_unlock_bh(&mi->lock);
 	return ret;
 }
 
-static void
-minstrel_ht_reset_sta_rc_stats(struct minstrel_priv *mp, struct minstrel_ht_sta *mi)
-{
-	mi->ampdu_len = 0;
-	mi->ampdu_packets = 0;
-	mi->avg_ampdu_len = MINSTREL_FRAC(1, 1);
-	memset(&mi->max_tp_rate, 0, sizeof(u16) * MAX_THR_RATES);
-	mi->max_prob_rate = 0;
-	mi->total_packets = 0;
-	mi->sample_packets = 0;
-	mi->sample_rate = 0;
-	memset(&mi->sample, 0, sizeof(struct minstrel_sample_category) *
-			       __MINSTREL_SAMPLE_TYPE_MAX);
-	memset(&mi->groups, 0, sizeof(struct minstrel_mcs_group_data) *
-			       MINSTREL_GROUPS_NB);
-
-	minstrel_ht_update_stats(mp, mi);
-}
-
 static int
-minstrel_ht_reset_stats(struct minstrel_priv *mp, char *buf)
+minstrel_ht_execute_for_all(struct minstrel_priv *mp, enum api_cmd cmd)
 {
 	struct minstrel_ht_sta *mi;
-	uint8_t macaddr[ETH_ALEN];
-	int err = 0;
+	int ret = 0;
 
 	rcu_read_lock();
 
-	if (!buf) {
-		list_for_each_entry(mi, &mp->stations, list)
-			minstrel_ht_reset_sta_rc_stats(mp, mi);
-		goto out;
-	}
-
-	if (!mac_pton(buf, macaddr)) {
-		err = -EINVAL;
-		goto out;
+	switch (cmd) {
+	case STA_CMD_RESET_STATS:
+		list_for_each_entry_rcu(mi, &mp->stations, list)
+			minstrel_ht_api_sta_reset_rc_stats(mp, mi);
+		break;
+	case STA_CMD_AUTO:
+		list_for_each_entry_rcu(mi, &mp->stations, list)
+			minstrel_ht_api_sta_set_rc_manual(mi, false);
+		break;
+	case STA_CMD_MANUAL:
+		list_for_each_entry_rcu(mi, &mp->stations, list)
+			minstrel_ht_api_sta_set_rc_manual(mi, true);
+		break;
+	default:
+		ret = -EPERM;
 	}
 
-	mi = minstrel_ht_api_get_sta(mp, macaddr);
-	if (!mi) {
-		err = -ENOENT;
-		goto out;
-	}
+	rcu_read_unlock();
+	return ret;
+}
 
-	minstrel_ht_reset_sta_rc_stats(mp, mi);
+static int
+minstrel_ht_execute(struct minstrel_priv *mp, enum api_cmd cmd, char *args)
+{
+	int err = 0;
 
-out:
-	rcu_read_unlock();
+	switch (cmd) {
+	case PHY_CMD_START:
+		minstrel_ht_api_start(mp, args);
+		break;
+	case PHY_CMD_STOP:
+		minstrel_ht_api_stop(mp);
+		break;
+	case PHY_CMD_DUMP:
+		minstrel_ht_dump_stations(mp, "dump");
+		break;
+	case STA_CMD_AUTO:
+	case STA_CMD_MANUAL:
+	case STA_CMD_RESET_STATS:
+		if (args && !strncmp(args, "all", 3)) {
+			err = minstrel_ht_execute_for_all(mp, cmd);
+			break;
+		}
+		fallthrough;
+	case STA_CMD_PROBE:
+	case STA_CMD_TPRC:
+		err = minstrel_ht_api_sta_cmd(mp, cmd, args);
+		break;
+	default:
+		err = -EINVAL;
+	}
 
 	return err;
 }
 
 static int
-minstrel_ht_execute_and_echo(struct minstrel_priv *mp, char *cmd, char *args)
+minstrel_ht_execute_and_echo(struct minstrel_priv *mp, enum api_cmd cmd,
+			     char* cmd_str, char *args)
 {
 	char buf[96];
 	int err = 0, len;
 
 	len = scnprintf(buf, sizeof(buf), "%llx;%s",
-			(unsigned long long)ktime_get_real_fast_ns(), cmd);
+			(unsigned long long)ktime_get_real_fast_ns(),
+			cmd_str);
 	if (args)
 		len += scnprintf(buf + len, sizeof(buf) - len, ";%s\n", args);
 	else
 		len += scnprintf(buf + len, sizeof(buf) - len, "\n");
 
-	if (!strcmp(cmd, "start"))
-		minstrel_ht_api_start(mp, args);
-	else if (!strcmp(cmd, "stop"))
-		minstrel_ht_api_stop(mp);
-	else if (!strcmp(cmd, "manual"))
-		minstrel_ht_api_set_manual(mp, true);
-	else if (!strcmp(cmd, "auto"))
-		minstrel_ht_api_set_manual(mp, false);
-	else if (!strcmp(cmd, "reset_stats"))
-		err = minstrel_ht_reset_stats(mp, args);
-	else
-		err = -EINVAL;
-
+	err = minstrel_ht_execute(mp, cmd, args);
 	if (err)
 		return err;
 
@@ -645,10 +679,12 @@ minstrel_ht_control_write(struct file *f
 			  size_t count, loff_t *ppos)
 {
 	struct minstrel_priv *mp = file->private_data;
+	enum api_cmd cmd;
 	char *pos, *cur;
 	char buf[64];
 	size_t len = count;
 	int err;
+	bool echo = true;
 
 	if (len > sizeof(buf) - 1)
 		return -EINVAL;
@@ -666,16 +702,31 @@ minstrel_ht_control_write(struct file *f
 	pos = buf;
 	cur = strsep(&pos, ";");
 
-	err = 0;
-	if (!strcmp(cur, "dump"))
-		minstrel_ht_dump_stations(mp, "dump");
-	else if (!strcmp(cur, "set_rates_power") || !strcmp(cur, "rates"))
-		err = minstrel_ht_api_sta_cmd(mp, STA_CMD_TPRC, pos);
-	else if (!strcmp(cur, "probe"))
-		err = minstrel_ht_api_sta_cmd(mp, STA_CMD_PROBE, pos);
-	else
-		err = minstrel_ht_execute_and_echo(mp, cur, pos);
+	if (!strcmp(cur, "set_rates_power") || !strcmp(cur, "rates")) {
+		cmd = STA_CMD_TPRC;
+		echo = false;
+	} else if (!strcmp(cur, "probe")) {
+		cmd = STA_CMD_PROBE;
+		echo = false;
+	} else if (!strcmp(cur, "dump")) {
+		cmd = PHY_CMD_DUMP;
+		echo = false;
+	} else if (!strcmp(cur, "start")) {
+		cmd = PHY_CMD_START;
+	} else if (!strcmp(cur, "stop")) {
+		cmd = PHY_CMD_STOP;
+	} else if (!strcmp(cur, "auto")) {
+		cmd = STA_CMD_AUTO;
+	} else if (!strcmp(cur, "manual")) {
+		cmd = STA_CMD_MANUAL;
+	} else if (!strcmp(cur, "reset_stats")) {
+		cmd = STA_CMD_RESET_STATS;
+	} else {
+		return -EINVAL;
+	}
 
+	err = (echo) ? minstrel_ht_execute_and_echo(mp, cmd, cur, pos)
+		     : minstrel_ht_execute(mp, cmd, pos);
 	if (err)
 		return err;
 
--- a/net/mac80211/rc80211_minstrel_ht.c
+++ b/net/mac80211/rc80211_minstrel_ht.c
@@ -1157,7 +1157,7 @@ minstrel_ht_update_stats(struct minstrel
 
 	minstrel_ht_report_best_rates(mp, mi);
 
-	if (!minstrel_ht_manual_mode(mp)) {
+	if (!minstrel_ht_sta_rc_manual_mode(mi)) {
 		minstrel_ht_refill_sample_rates(mi);
 		minstrel_ht_report_sample_rates(mp, mi);
 	}
@@ -1540,7 +1540,7 @@ minstrel_ht_update_rates(struct minstrel
 	int i = 0;
 	int max_rates = min_t(int, mp->hw->max_rates, IEEE80211_TX_RATE_TABLE_SIZE);
 
-	if (minstrel_ht_manual_mode(mp) && !force) {
+	if (minstrel_ht_sta_rc_manual_mode(mi) && !force) {
 		if (mi->ratetbl) {
 			rates = kmemdup(mi->ratetbl, sizeof(*rates), GFP_ATOMIC);
 			if (rates)
@@ -1576,7 +1576,7 @@ minstrel_ht_get_sample_rate(struct minst
 {
 	u8 seq;
 
-	if (mp->hw->max_rates > 1 && !minstrel_ht_manual_mode(mp)) {
+	if (mp->hw->max_rates > 1 && !minstrel_ht_sta_rc_manual_mode(mi)) {
 		seq = mi->sample_seq;
 		mi->sample_seq = (seq + 1) % ARRAY_SIZE(minstrel_sample_seq);
 		seq = minstrel_sample_seq[seq];
@@ -1615,7 +1615,7 @@ minstrel_ht_get_rate(void *priv, struct
 	    (info->control.flags & IEEE80211_TX_CTRL_PORT_CTRL_PROTO))
 		return;
 
-	if (minstrel_ht_manual_mode(mp) && mi->user_sample_rate != -1) {
+	if (minstrel_ht_sta_rc_manual_mode(mi) && mi->user_sample_rate != -1) {
 		sample_idx = mi->user_sample_rate;
 		sample_txpower = mi->user_sample_txpower;
 		if (mi->user_sample_count != 0)
--- a/net/mac80211/rc80211_minstrel_ht.h
+++ b/net/mac80211/rc80211_minstrel_ht.h
@@ -107,7 +107,6 @@ struct minstrel_priv {
 	spinlock_t sta_wlock;
 
 	u8 monitor;
-	bool manual;
 #endif
 };
 
@@ -175,6 +174,8 @@ struct minstrel_ht_sta {
 	s16 user_sample_txpower;
 	u8 user_sample_count;
 	struct ieee80211_sta_rates *ratetbl;
+
+	bool rc_manual;
 #endif
 	struct ieee80211_sta *sta;
 	spinlock_t lock;
@@ -326,10 +327,10 @@ minstrel_ht_report_sample_rates(struct m
 }
 
 static inline bool
-minstrel_ht_manual_mode(struct minstrel_priv *mp)
+minstrel_ht_sta_rc_manual_mode(struct minstrel_ht_sta *mi)
 {
 #ifdef CPTCFG_MAC80211_RC_MINSTREL_DEBUGFS_API
-	return mp->manual;
+	return mi->rc_manual;
 #else
 	return false;
 #endif
