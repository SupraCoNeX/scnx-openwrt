--- a/net/mac80211/rc80211_minstrel_ht.c
+++ b/net/mac80211/rc80211_minstrel_ht.c
@@ -274,10 +274,6 @@ static const u8 minstrel_sample_seq[] =
 	MINSTREL_SAMPLE_TYPE_SLOW,
 };
 
-static void
-minstrel_ht_update_rates(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,
-			 bool force);
-
 /*
  * Some VHT MCSes are invalid (when Ndbps / Nes is not an integer)
  * e.g for MCS9@20MHzx1Nss: Ndbps=8x52*(5/6) Nes=1
@@ -1532,49 +1528,57 @@ minstrel_ht_get_max_amsdu_len(struct min
 	return 0;
 }
 
-static void
+void
 minstrel_ht_update_rates(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,
 			 bool force)
 {
 	struct ieee80211_sta_rates *rates;
 	int i = 0;
 	int max_rates = min_t(int, mp->hw->max_rates, IEEE80211_TX_RATE_TABLE_SIZE);
-
-	if (minstrel_ht_sta_rc_manual_mode(mi) && !force) {
-		if (mi->ratetbl) {
-			rates = kmemdup(mi->ratetbl, sizeof(*rates), GFP_ATOMIC);
-			if (rates)
-				rate_control_set_rates(mp->hw, mi->sta, rates);
-		}
-		return;
-	}
+	bool manual_rc, manual_tpc, update_stats = true;
 
 	rates = kzalloc(sizeof(*rates), GFP_ATOMIC);
 	if (!rates)
 		return;
 
-	/* Start with max_tp_rate[0] */
-	minstrel_ht_set_rate(mp, mi, rates, i, mi->max_tp_rate[0]);
-	rates->rate[i].txpower_idx = -1;
-	i++;
-
-	/* Fill up remaining, keep one entry for max_probe_rate */
-	for (; i < (max_rates - 1); i++) {
-		minstrel_ht_set_rate(mp, mi, rates, i, mi->max_tp_rate[i]);
-		rates->rate[i].txpower_idx = -1;
-	}
+	manual_rc = minstrel_ht_sta_rc_manual_mode(mi) && !force;
+	manual_tpc = minstrel_ht_sta_tpc_manual_mode(mi) && !force;
 
-	if (i < max_rates) {
-		minstrel_ht_set_rate(mp, mi, rates, i, mi->max_prob_rate);
-		rates->rate[i].txpower_idx = -1;
-		i++;
-	}
-
-	if (i < IEEE80211_TX_RATE_TABLE_SIZE)
-		rates->rate[i].idx = -1;
+	if (manual_rc) {
+		if (mi->ratetbl->rate[0].idx >= 0) {
+			memcpy(rates, mi->ratetbl, sizeof(*rates));
+		} else {
+			kfree(rates);
+			return;
+		}
+		update_stats = false;
+	} else {
+		/* Start with max_tp_rate[0] */
+		minstrel_ht_set_rate(mp, mi, rates, i++, mi->max_tp_rate[0]);
 
-	mi->sta->deflink.agg.max_rc_amsdu_len = minstrel_ht_get_max_amsdu_len(mi);
-	ieee80211_sta_recalc_aggregates(mi->sta);
+		/* Fill up remaining, keep one entry for max_probe_rate */
+		for (; i < (max_rates - 1); i++)
+			minstrel_ht_set_rate(mp, mi, rates, i, mi->max_tp_rate[i]);
+
+		if (i < max_rates)
+			minstrel_ht_set_rate(mp, mi, rates, i++, mi->max_prob_rate);
+
+		if (i < IEEE80211_TX_RATE_TABLE_SIZE)
+			rates->rate[i].idx = -1;
+	}
+
+	/* Whole ratetbl copied before so we do not need to read values again */
+	if (!manual_rc)
+		for (i = 0; i < max_rates; i++)
+			rates->rate[i].txpower_idx = manual_tpc
+					? mi->ratetbl->rate[i].txpower_idx
+					: -1;
+
+	if (update_stats) {
+		mi->sta->deflink.agg.max_rc_amsdu_len =
+			minstrel_ht_get_max_amsdu_len(mi);
+		ieee80211_sta_recalc_aggregates(mi->sta);
+	}
 	rate_control_set_rates(mp->hw, mi->sta, rates);
 }
 
@@ -1622,15 +1626,17 @@ minstrel_ht_get_rate(void *priv, struct
 	    (info->control.flags & IEEE80211_TX_CTRL_PORT_CTRL_PROTO))
 		return;
 
+	if (minstrel_ht_sta_tpc_manual_mode(mi) && mi->user_sample_txpower != -1) {
+		sample_txpower = mi->user_sample_txpower;
+		mi->user_sample_txpower = -1;
+	}
 	if (minstrel_ht_sta_rc_manual_mode(mi) && mi->user_sample_rate != -1) {
 		sample_idx = mi->user_sample_rate;
-		sample_txpower = mi->user_sample_txpower;
 		if (mi->user_sample_count != 0)
 			sample_count = mi->user_sample_count;
 
 		mi->user_sample_rate = -1;
 		mi->user_sample_count = 0;
-		mi->user_sample_txpower = -1;
 
 		goto set_rate;
 	}
@@ -1904,6 +1910,7 @@ minstrel_ht_alloc_sta(void *priv, struct
 
 #ifdef CPTCFG_MAC80211_RC_MINSTREL_DEBUGFS_API
 	INIT_LIST_HEAD(&mi->list);
+	mi->ratetbl = kzalloc(sizeof(*mi->ratetbl), gfp);
 	mi->user_sample_rate = -1;
 	mi->user_sample_count = 0;
 	mi->user_sample_txpower = -1;
--- a/net/mac80211/rc80211_minstrel_ht.h
+++ b/net/mac80211/rc80211_minstrel_ht.h
@@ -176,6 +176,7 @@ struct minstrel_ht_sta {
 	struct ieee80211_sta_rates *ratetbl;
 
 	bool rc_manual;
+	bool tpc_manual;
 #endif
 	struct ieee80211_sta *sta;
 	spinlock_t lock;
@@ -336,11 +337,23 @@ minstrel_ht_sta_rc_manual_mode(struct mi
 #endif
 }
 
+static inline bool
+minstrel_ht_sta_tpc_manual_mode(struct minstrel_ht_sta *mi)
+{
+#ifdef CPTCFG_MAC80211_RC_MINSTREL_DEBUGFS_API
+	return mi->tpc_manual;
+#else
+	return false;
+#endif
+}
+
 void minstrel_ht_set_rate(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,
 						  struct ieee80211_sta_rates *ratetbl, int offset,
 						  int index);
 int minstrel_ht_get_tp_avg(struct minstrel_ht_sta *mi, int group, int rate,
 			   int prob_avg);
+void minstrel_ht_update_rates(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,
+			      bool force);
 void minstrel_ht_update_stats(struct minstrel_priv *mp, struct minstrel_ht_sta *mi);
 
 #endif
--- a/net/mac80211/rc80211_minstrel_ht_api.c
+++ b/net/mac80211/rc80211_minstrel_ht_api.c
@@ -22,11 +22,13 @@ enum api_cmd {
 	PHY_CMD_DUMP,
 
 	/* per-STA commands */
-	STA_CMD_AUTO,
-	STA_CMD_MANUAL,
+	STA_CMD_RC_MODE,
+	STA_CMD_TPC_MODE,
 	STA_CMD_RESET_STATS,
 	STA_CMD_PROBE,
 	STA_CMD_TPRC,
+	STA_CMD_TPC,
+	STA_CMD_RC,
 };
 
 static void
@@ -60,7 +62,7 @@ minstrel_ht_read_api_info(struct seq_fil
 	        seq_printf(s, ";airtime%d", i);
         seq_printf(s, "\n");
 
-	seq_printf(s, "#sta;action;macaddr;iface;rc_mode;overhead_mcs;overhead_legacy");
+	seq_printf(s, "#sta;action;macaddr;iface;rc_mode;tpc_mode;overhead_mcs;overhead_legacy");
 	for (i = 0; i < MINSTREL_GROUPS_NB; i++)
 	        seq_printf(s, ";mcs%d", i);
 	seq_printf(s, "\n");
@@ -91,9 +93,24 @@ minstrel_ht_read_api_info(struct seq_fil
 	        seq_printf(s, ";slow%d", i);
 	seq_printf(s, "\n");
 
+	seq_printf(s, "#sample_table;cols;rows");
+	for (i = 0; i < SAMPLE_COLUMNS; i++)
+		seq_printf(s, ";column%d", i);
+	seq_printf(s, "\n");
+
 	seq_printf(s, "#reset_stats;macaddr\n");
 	seq_printf(s, "#reset_stats;all\n");
 
+	seq_printf(s, "#set_rates;macaddr");
+	for (i = 0; i < IEEE80211_TX_MAX_RATES; i++)
+		seq_printf(s, ";rate%d,count%d", i, i);
+	seq_printf(s, "\n");
+
+	seq_printf(s, "#set_power;macaddr");
+	for (i = 0; i < IEEE80211_TX_MAX_RATES; i++)
+		seq_printf(s, ";txpwr%d", i);
+	seq_printf(s, "\n");
+
 	seq_printf(s, "#set_rates_power;macaddr");
 	for (i = 0; i < IEEE80211_TX_MAX_RATES; i++)
 		seq_printf(s, ";rate%d,count%d,txpwr%d", i, i, i);
@@ -101,10 +118,10 @@ minstrel_ht_read_api_info(struct seq_fil
 
 	seq_printf(s, "#probe;macaddr;rate;count;txpwr\n");
 
-	seq_printf(s, "#sample_table;cols;rows");
-	for (i = 0; i < SAMPLE_COLUMNS; i++)
-		seq_printf(s, ";column%d", i);
-	seq_printf(s, "\n");
+	seq_printf(s, "#rc_mode;macaddr;mode\n");
+	seq_printf(s, "#rc_mode;all;mode\n");
+	seq_printf(s, "#tpc_mode;macaddr;mode\n");
+	seq_printf(s, "#tpc_mode;all;mode\n");
 
 	for (i = 0; i < MINSTREL_GROUPS_NB; i++) {
 		const struct mcs_group *g = &minstrel_mcs_groups[i];
@@ -217,16 +234,17 @@ minstrel_ht_dump_sta(struct minstrel_pri
 		     const char *type)
 {
 	struct sta_info *sta_info;
-	char info[64 + MINSTREL_GROUPS_NB * 4];
+	char info[128 + MINSTREL_GROUPS_NB * 4];
 	int ofs = 0;
 	int i;
 
 	sta_info = container_of(mi->sta, struct sta_info, sta);
 	ofs += scnprintf(info + ofs, sizeof(info) - ofs,
-			 "%llx;sta;%s;%pM;%s;%s;%x;%x;",
+			 "%llx;sta;%s;%pM;%s;%s;%s;%x;%x;",
 			 (unsigned long long)ktime_get_real_fast_ns(), type,
 			 mi->sta->addr, sta_info->sdata->name,
 			 mi->rc_manual ? "manual" : "auto",
+			 mi->tpc_manual ? "manual" : "auto",
 			 mi->overhead, mi->overhead_legacy);
 
 	ofs += scnprintf(info + ofs, sizeof(info) - ofs, "%x",
@@ -329,17 +347,51 @@ minstrel_ht_reset_sample_table(struct mi
 	mi->user_sample_txpower = -1;
 }
 
-static void
-minstrel_ht_api_sta_set_rc_manual(struct minstrel_ht_sta *mi, bool manual)
+static int
+minstrel_ht_api_sta_set_rc_mode(struct minstrel_ht_sta *mi, char *mode)
 {
-	spin_lock_bh(&mi->lock);
+	int i;
+
+	if (!mode)
+		return -EINVAL;
+
+	if (!strcmp(mode, "manual"))
+		mi->rc_manual = true;
+	else if (!strcmp(mode, "auto"))
+		mi->rc_manual = false;
+	else
+		return -EINVAL;
 
-	mi->rc_manual = manual;
 	minstrel_ht_reset_sample_table(mi);
-	kfree(mi->ratetbl);
-	mi->ratetbl = NULL;
+	for (i = 0; i < sizeof(mi->ratetbl->rate); i++) {
+		mi->ratetbl->rate[i].idx = -1;
+		mi->ratetbl->rate[i].count = 0;
+		mi->ratetbl->rate[i].count_rts = 0;
+		mi->ratetbl->rate[i].count_cts = 0;
+	}
 
-	spin_unlock_bh(&mi->lock);
+	return 0;
+}
+
+static int
+minstrel_ht_api_sta_set_tpc_mode(struct minstrel_ht_sta *mi, char *mode)
+{
+	int i;
+
+	if (!mode)
+		return -EINVAL;
+
+	if (!strcmp(mode, "manual"))
+		mi->tpc_manual = true;
+	else if (!strcmp(mode, "auto"))
+		mi->tpc_manual = false;
+	else
+		return -EINVAL;
+
+	for (i = 0; i < sizeof(mi->ratetbl->rate); i++)
+		mi->ratetbl->rate[i].txpower_idx = -1;
+
+	return 0;
 }
 
 static struct minstrel_ht_sta *
@@ -443,76 +495,102 @@ minstrel_ht_set_probe_rate(struct minstr
 }
 
 static int
-minstrel_ht_set_rates(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,
-		      char **stages, unsigned int n_stages)
+minstrel_ht_ratetbl_set_rate_count(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,
+				   char **rate_count_str, unsigned int stage)
 {
-	struct ieee80211_sta_rates *ratetbl;
-	char *parts[3];
-	unsigned int count, txpower;
-	int n_parts, rate;
-	int err = -EINVAL;
-	int i;
-	s16 max_power;
+	char *rate_str, *count_str;
+	unsigned int count;
+	int rate;
 
-	if (!mi->rc_manual)
-		return -EPERM;
-	if (!stages || !stages[0] || !n_stages)
+	rate_str = strsep(rate_count_str, ",");
+	count_str = strsep(rate_count_str, ",");
+
+	if (!rate_str || !count_str)
 		return -EINVAL;
 
-	if (!mi->ratetbl)
-		mi->ratetbl = kzalloc(sizeof(*ratetbl), GFP_ATOMIC);
+	rate = minstrel_ht_rate_from_str(mi, rate_str);
+	if (rate < 0)
+		return -EINVAL;
 
-	ratetbl = mi->ratetbl;
-	if (!ratetbl)
-		return -ENOMEM;
+	if (kstrtouint(count_str, 16, &count))
+		return -EINVAL;
 
-	max_power = ieee80211_hw_get_max_txpower_idx(mp->hw);
+	minstrel_ht_set_rate(mp, mi, mi->ratetbl, stage, rate);
+	mi->ratetbl->rate[stage].count = count;
+	mi->ratetbl->rate[stage].count_rts = count;
+	mi->ratetbl->rate[stage].count_cts = count;
 
-	memset(ratetbl, 0, sizeof(*ratetbl));
-	for (i = 0; i < n_stages; i++) {
-		n_parts = minstrel_ht_get_args(parts, ARRAY_SIZE(parts),
-					       stages[i], ",");
-		if (n_parts < 2)
-			goto error;
+	return 0;
+}
 
-		rate = minstrel_ht_rate_from_str(mi, parts[0]);
-		if (rate < 0)
-			goto error;
+static int
+minstrel_ht_ratetbl_set_txpower(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,
+			       char *txpwr_str, int stage, s16 max_power)
+{
+	int txpwr;
 
-		if (kstrtouint(parts[1], 16, &count))
-			goto error;
+	if (!txpwr_str)
+		return -EINVAL;
 
-		minstrel_ht_set_rate(mp, mi, ratetbl, i, rate);
-		ratetbl->rate[i].count = count;
-		ratetbl->rate[i].count_rts = count;
-		ratetbl->rate[i].count_cts = count;
+	if (kstrtoint(txpwr_str, 16, &txpwr))
+		return -EINVAL;
 
-		if (n_parts > 2 && !kstrtouint(parts[2], 16, &txpower)) {
-			if (txpower > max_power)
-				goto error;
+	if (txpwr > max_power)
+		return -EINVAL;
 
-			ratetbl->rate[i].txpower_idx = (s16)txpower;
-		} else {
-			ratetbl->rate[i].txpower_idx = -1;
-		}
-	}
-	if (!i)
-		goto error;
+	mi->ratetbl->rate[stage].txpower_idx = (s16)txpwr;
+	return 0;
+}
 
-	for (; i < IEEE80211_TX_RATE_TABLE_SIZE; i++)
-		ratetbl->rate[i].txpower_idx = -1;
+static int
+minstrel_ht_set_ratetbl(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,
+			enum api_cmd cmd, char **args_str, unsigned int n_args)
+{
+	struct ieee80211_sta_rates *ratetbl;
+	unsigned int i;
+	int err = 0;
+	s16 max_tx_power;
+	bool rc, tpc;
 
-	ratetbl = kmemdup(ratetbl, sizeof(*ratetbl), GFP_KERNEL);
-	if (!ratetbl)
-		return -ENOMEM;
+	if (!args_str || !n_args)
+		return -EINVAL;
 
-	rate_control_set_rates(mp->hw, mi->sta, ratetbl);
+	rc = cmd == STA_CMD_RC || cmd == STA_CMD_TPRC;
+	tpc = cmd == STA_CMD_TPC || cmd == STA_CMD_TPRC;
 
-	return 0;
+	if (rc && !minstrel_ht_sta_rc_manual_mode(mi))
+		return -EPERM;
+	if (tpc && !minstrel_ht_sta_tpc_manual_mode(mi))
+		return -EPERM;
+
+	if (tpc)
+		max_tx_power = ieee80211_hw_get_max_txpower_idx(mp->hw);
+
+	for (i = 0; i < min_t(unsigned int, n_args, sizeof(ratetbl->rate)); i++) {
+		if (rc) {
+			err = minstrel_ht_ratetbl_set_rate_count(mp, mi, &args_str[i], i);
+			if (err)
+				return err;
+		}
 
-error:
-	kfree(ratetbl);
-	mi->ratetbl = NULL;
+		if (tpc) {
+			err = minstrel_ht_ratetbl_set_txpower(mp, mi, args_str[i], i,
+							      max_tx_power);
+			if (err)
+				return err;
+		}
+	}
+	if (!i)
+		return err;
+
+	for (; i < IEEE80211_TX_RATE_TABLE_SIZE; i++) {
+		mi->ratetbl->rate[i].idx = -1;
+		mi->ratetbl->rate[i].count = 0;
+		mi->ratetbl->rate[i].txpower_idx = -1;
+		mi->txpower[i] = -1;
+	}
+
+	minstrel_ht_update_rates(mp, mi, false);
 
 	return err;
 }
@@ -563,14 +641,16 @@ minstrel_ht_api_sta_cmd(struct minstrel_
 	case STA_CMD_PROBE:
 		ret = minstrel_ht_set_probe_rate(mp, mi, args[1], args[2], args[3]);
 		break;
+	case STA_CMD_RC:
+	case STA_CMD_TPC:
 	case STA_CMD_TPRC:
-		ret = minstrel_ht_set_rates(mp, mi, &args[1], n_args - 1);
+		ret = minstrel_ht_set_ratetbl(mp, mi, cmd, &args[1], n_args - 1);
 		break;
-	case STA_CMD_AUTO:
-		minstrel_ht_api_sta_set_rc_manual(mi, false);
+	case STA_CMD_RC_MODE:
+		ret = minstrel_ht_api_sta_set_rc_mode(mi, args[1]);
 		break;
-	case STA_CMD_MANUAL:
-		minstrel_ht_api_sta_set_rc_manual(mi, true);
+	case STA_CMD_TPC_MODE:
+		ret = minstrel_ht_api_sta_set_tpc_mode(mi, args[1]);
 		break;
 	case STA_CMD_RESET_STATS:
 		minstrel_ht_api_sta_reset_rc_stats(mp, mi);
@@ -585,7 +665,7 @@ minstrel_ht_api_sta_cmd(struct minstrel_
 }
 
 static int
-minstrel_ht_execute_for_all(struct minstrel_priv *mp, enum api_cmd cmd)
+minstrel_ht_execute_for_all(struct minstrel_priv *mp, enum api_cmd cmd, char *args)
 {
 	struct minstrel_ht_sta *mi;
 	int ret = 0;
@@ -597,13 +677,13 @@ minstrel_ht_execute_for_all(struct minst
 		list_for_each_entry_rcu(mi, &mp->stations, list)
 			minstrel_ht_api_sta_reset_rc_stats(mp, mi);
 		break;
-	case STA_CMD_AUTO:
+	case STA_CMD_RC_MODE:
 		list_for_each_entry_rcu(mi, &mp->stations, list)
-			minstrel_ht_api_sta_set_rc_manual(mi, false);
+			minstrel_ht_api_sta_set_rc_mode(mi, args);
 		break;
-	case STA_CMD_MANUAL:
+	case STA_CMD_TPC_MODE:
 		list_for_each_entry_rcu(mi, &mp->stations, list)
-			minstrel_ht_api_sta_set_rc_manual(mi, true);
+			minstrel_ht_api_sta_set_tpc_mode(mi, args);
 		break;
 	default:
 		ret = -EPERM;
@@ -628,16 +708,19 @@ minstrel_ht_execute(struct minstrel_priv
 	case PHY_CMD_DUMP:
 		minstrel_ht_dump_stations(mp, "dump");
 		break;
-	case STA_CMD_AUTO:
-	case STA_CMD_MANUAL:
+	case STA_CMD_RC_MODE:
+	case STA_CMD_TPC_MODE:
 	case STA_CMD_RESET_STATS:
 		if (args && !strncmp(args, "all", 3)) {
-			err = minstrel_ht_execute_for_all(mp, cmd);
+			strsep(&args, ";");
+			err = minstrel_ht_execute_for_all(mp, cmd, args);
 			break;
 		}
 		fallthrough;
 	case STA_CMD_PROBE:
 	case STA_CMD_TPRC:
+	case STA_CMD_TPC:
+	case STA_CMD_RC:
 		err = minstrel_ht_api_sta_cmd(mp, cmd, args);
 		break;
 	default:
@@ -705,6 +788,12 @@ minstrel_ht_control_write(struct file *f
 	if (!strcmp(cur, "set_rates_power") || !strcmp(cur, "rates")) {
 		cmd = STA_CMD_TPRC;
 		echo = false;
+	} else if (!strcmp(cur, "set_power")) {
+		cmd = STA_CMD_TPC;
+		echo = false;
+	} else if (!strcmp(cur, "set_rates")) {
+		cmd = STA_CMD_RC;
+		echo = false;
 	} else if (!strcmp(cur, "probe")) {
 		cmd = STA_CMD_PROBE;
 		echo = false;
@@ -715,10 +804,10 @@ minstrel_ht_control_write(struct file *f
 		cmd = PHY_CMD_START;
 	} else if (!strcmp(cur, "stop")) {
 		cmd = PHY_CMD_STOP;
-	} else if (!strcmp(cur, "auto")) {
-		cmd = STA_CMD_AUTO;
-	} else if (!strcmp(cur, "manual")) {
-		cmd = STA_CMD_MANUAL;
+	} else if (!strcmp(cur, "rc_mode")) {
+		cmd = STA_CMD_RC_MODE;
+	} else if (!strcmp(cur, "tpc_mode")) {
+		cmd = STA_CMD_TPC_MODE;
 	} else if (!strcmp(cur, "reset_stats")) {
 		cmd = STA_CMD_RESET_STATS;
 	} else {
@@ -765,6 +854,7 @@ void minstrel_ht_sta_remove(struct minst
 
 	list_del_rcu(&mi->list);
 	INIT_LIST_HEAD_RCU(&mi->list);
+	kfree(mi->ratetbl);
 
 	spin_unlock_bh(&mp->sta_wlock);
 
