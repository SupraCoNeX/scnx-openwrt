--- a/net/mac80211/rc80211_minstrel_ht_api.c
+++ b/net/mac80211/rc80211_minstrel_ht_api.c
@@ -16,8 +16,18 @@
 
 extern u8 sample_table[SAMPLE_COLUMNS][MCS_GROUP_RATES];
 
-enum sta_cmd {
+enum api_cmd {
+	PHY_CMD_START,
+	PHY_CMD_STOP,
+	PHY_CMD_DUMP,
+
+	/* per-STA commands */
+	STA_CMD_RC_MODE,
+	STA_CMD_TPC_MODE,
+	STA_CMD_RESET_STATS,
 	STA_CMD_PROBE,
+	STA_CMD_TPRC,
+	STA_CMD_TPC,
 	STA_CMD_RC,
 };
 
@@ -52,14 +62,14 @@ minstrel_ht_read_api_info(struct seq_fil
 	        seq_printf(s, ";airtime%d", i);
         seq_printf(s, "\n");
 
-	seq_printf(s, "#sta;action;macaddr;iface;overhead_mcs;overhead_legacy");
+	seq_printf(s, "#sta;action;macaddr;iface;rc_mode;tpc_mode;overhead_mcs;overhead_legacy");
 	for (i = 0; i < MINSTREL_GROUPS_NB; i++)
 	        seq_printf(s, ";mcs%d", i);
 	seq_printf(s, "\n");
 
 	seq_printf(s, "#txs;macaddr;num_frames;num_acked;probe");
 	for (i = 0; i < IEEE80211_TX_MAX_RATES; i++)
-		seq_printf(s, ";rate%d;count%d", i, i);
+		seq_printf(s, ";rate%d;count%d;txpwr%d", i, i, i);
 	seq_printf(s, "\n");
 
 	seq_printf(s, "#rxs;macaddr;last_signal");
@@ -83,20 +93,42 @@ minstrel_ht_read_api_info(struct seq_fil
 	        seq_printf(s, ";slow%d", i);
 	seq_printf(s, "\n");
 
-	seq_printf(s, "#reset_stats;macaddr\n");
+	seq_printf(s, "#sample_table;cols;rows");
+	for (i = 0; i < SAMPLE_COLUMNS; i++)
+		seq_printf(s, ";column%d", i);
+	seq_printf(s, "\n");
 
 	seq_printf(s, "#set_rates;macaddr");
 	for (i = 0; i < IEEE80211_TX_MAX_RATES; i++)
 		seq_printf(s, ";rate%d,count%d", i, i);
 	seq_printf(s, "\n");
 
-	seq_printf(s, "#set_probe;macaddr;rate,count\n");
+	seq_printf(s, "#set_power;macaddr");
+	for (i = 0; i < IEEE80211_TX_MAX_RATES; i++)
+		seq_printf(s, ";txpwr%d", i);
+	seq_printf(s, "\n");
 
-	seq_printf(s, "#sample_table;cols;rows");
-	for (i = 0; i < SAMPLE_COLUMNS; i++)
-		seq_printf(s, ";column%d", i);
+	seq_printf(s, "#set_rates_power;macaddr");
+	for (i = 0; i < IEEE80211_TX_MAX_RATES; i++)
+		seq_printf(s, "rate%d,count%d,txpwr%d", i, i, i);
 	seq_printf(s, "\n");
 
+	seq_printf(s, "#set_probe;macaddr;rate,count,txpwr\n");
+
+	/*
+	 * Commands targeting 'all' instead of a mac address are executed for
+	 * all currently connected STAs. However, this has no effect on any
+	 * future STAs. For 'rc_mode' and 'tpc_mode', an STA is by default in
+	 * 'auto' mode after connecting.
+	 */
+	seq_printf(s, "#rc_mode;macaddr;mode\n");
+	seq_printf(s, "#rc_mode;all;mode\n");
+	seq_printf(s, "#tpc_mode;macaddr;mode\n");
+	seq_printf(s, "#tpc_mode;all;mode\n");
+
+	seq_printf(s, "#reset_stats;macaddr\n");
+	seq_printf(s, "#reset_stats;all\n");
+
 	for (i = 0; i < MINSTREL_GROUPS_NB; i++) {
 		const struct mcs_group *g = &minstrel_mcs_groups[i];
 		const char *type;
@@ -137,7 +169,6 @@ minstrel_ht_read_phy_info(struct seq_fil
 	struct wiphy *wiphy = container_of(s->private, struct wiphy, dev);
 	struct ieee80211_local *local = wiphy_priv(wiphy);
 	struct ieee80211_sub_if_data *sdata;
-	struct minstrel_priv *mp = local->rate_ctrl->priv;
 	int i = 0;
 
 	seq_printf(s, "drv;%s\n", wiphy_dev(wiphy)->driver->name);
@@ -152,9 +183,26 @@ minstrel_ht_read_phy_info(struct seq_fil
 		}
 	}
 	mutex_unlock(&local->iflist_mtx);
+	seq_printf(s, "\n");
 
-	seq_printf(s, "\nrc_mode;%s\n", mp->manual ? "manual" : "auto");
+	if (ieee80211_hw_check(&local->hw, SUPPORTS_TPC_PER_PACKET)) {
+		seq_printf(s, "tpc;pkt");
+	} else if (ieee80211_hw_check(&local->hw, SUPPORTS_TPC_PER_MRR)) {
+		seq_printf(s, "tpc;mrr");
+	} else {
+		seq_printf(s, "tpc;not\n");
+		goto skip_tpc;
+	}
 
+	seq_printf(s, ";%u", local->hw.n_txpower_ranges);
+	for (i = 0; i < local->hw.n_txpower_ranges; i++) {
+		struct ieee80211_hw_txpower_range *rng = &local->hw.txpower_ranges[i];
+		seq_printf(s, ";%x,%x,%x,%x", rng->start_idx, rng->n_levels,
+			   rng->start_pwr, rng->pwr_step);
+	}
+	seq_printf(s, "\n");
+
+skip_tpc:
 	return 0;
 }
 
@@ -192,15 +240,18 @@ minstrel_ht_dump_sta(struct minstrel_pri
 		     const char *type)
 {
 	struct sta_info *sta_info;
-	char info[64 + MINSTREL_GROUPS_NB * 4];
+	char info[128 + MINSTREL_GROUPS_NB * 4];
 	int ofs = 0;
 	int i;
 
 	sta_info = container_of(mi->sta, struct sta_info, sta);
-	ofs += scnprintf(info + ofs, sizeof(info) - ofs, "%llx;sta;%s;%pM;%s;%x;%x;",
-			(unsigned long long)ktime_get_real_fast_ns(), type,
-			mi->sta->addr, sta_info->sdata->name, mi->overhead,
-			mi->overhead_legacy);
+	ofs += scnprintf(info + ofs, sizeof(info) - ofs,
+			 "%llx;sta;%s;%pM;%s;%s;%s;%x;%x;",
+			 (unsigned long long)ktime_get_real_fast_ns(), type,
+			 mi->sta->addr, sta_info->sdata->name,
+			 mi->rc_manual ? "manual" : "auto",
+			 mi->tpc_manual ? "manual" : "auto",
+			 mi->overhead, mi->overhead_legacy);
 
 	ofs += scnprintf(info + ofs, sizeof(info) - ofs, "%x",
 			 mi->supported[0]);
@@ -254,7 +305,7 @@ static void
 minstrel_ht_api_start(struct minstrel_priv *mp, char *params)
 {
 	char *cur;
-	u8 mask = 0;
+	u8 mask = mp->monitor;
 
 	while ((cur = strsep(&params, ";")) != NULL) {
 		if (!strlen(cur))
@@ -268,6 +319,8 @@ minstrel_ht_api_start(struct minstrel_pr
 			mask |= MINSTREL_MONITOR_STA;
 		else if (!strcmp(cur, "stats"))
 			mask |= MINSTREL_MONITOR_STATS;
+		else if (!strcmp(cur, "tprc_echo"))
+			mask |= MINSTREL_ECHO_TPRC;
 	}
 
 	if (!mask)
@@ -279,10 +332,34 @@ minstrel_ht_api_start(struct minstrel_pr
 }
 
 static void
-minstrel_ht_api_stop(struct minstrel_priv *mp)
+minstrel_ht_api_stop(struct minstrel_priv *mp, char *params)
 {
+	u8 mask = 0;
+	char *cur;
+
+	if (!params || !strncmp(params, "all", 3))
+		goto set_mask;
+
+	mask = mp->monitor;
+	while ((cur = strsep(&params, ";")) != NULL) {
+		if (!strlen(cur))
+			break;
+
+		if (!strcmp(cur, "txs"))
+			mask &= ~MINSTREL_MONITOR_TXS;
+		else if (!strcmp(cur, "rxs"))
+			mask &= ~MINSTREL_MONITOR_RXS;
+		else if (!strcmp(cur, "sta"))
+			mask &= ~MINSTREL_MONITOR_STA;
+		else if (!strcmp(cur, "stats"))
+			mask &= ~MINSTREL_MONITOR_STATS;
+		else if (!strcmp(cur, "tprc_echo"))
+			mask &= ~MINSTREL_ECHO_TPRC;
+	}
+
+set_mask:
 	spin_lock_bh(&mp->relay_lock);
-	mp->monitor = 0;
+	mp->monitor = mask;
 	relay_reset(mp->relay_ev);
 	spin_unlock_bh(&mp->relay_lock);
 }
@@ -299,26 +376,54 @@ minstrel_ht_reset_sample_table(struct mi
 	mi->sample_seq = 0;
 	mi->user_sample_rate = -1;
 	mi->user_sample_count = 0;
+	mi->user_sample_txpower = -1;
 }
 
-static void
-minstrel_ht_api_set_manual(struct minstrel_priv *mp, bool manual)
+static int
+minstrel_ht_api_sta_set_rc_mode(struct minstrel_ht_sta *mi, char *mode)
 {
-	struct minstrel_ht_sta *mi;
-
-	mp->manual = manual;
+	int i;
 
-	rcu_read_lock();
-	list_for_each_entry_rcu(mi, &mp->stations, list) {
-		spin_lock_bh(&mi->lock);
+	if (!mode)
+		return -EINVAL;
 
-		minstrel_ht_reset_sample_table(mi);
-		kfree(mi->ratetbl);
-		mi->ratetbl = NULL;
+	if (!strcmp(mode, "manual"))
+		mi->rc_manual = true;
+	else if (!strcmp(mode, "auto"))
+		mi->rc_manual = false;
+	else
+		return -EINVAL;
 
-		spin_unlock_bh(&mi->lock);
+	minstrel_ht_reset_sample_table(mi);
+	for (i = 0; i < sizeof(mi->ratetbl->rate); i++) {
+		mi->ratetbl->rate[i].idx = -1;
+		mi->ratetbl->rate[i].count = 0;
+		mi->ratetbl->rate[i].count_rts = 0;
+		mi->ratetbl->rate[i].count_cts = 0;
 	}
-	rcu_read_unlock();
+
+	return 0;
+}
+
+static int
+minstrel_ht_api_sta_set_tpc_mode(struct minstrel_ht_sta *mi, char *mode)
+{
+	int i;
+
+	if (!mode)
+		return -EINVAL;
+
+	if (!strcmp(mode, "manual"))
+		mi->tpc_manual = true;
+	else if (!strcmp(mode, "auto"))
+		mi->tpc_manual = false;
+	else
+		return -EINVAL;
+
+	for (i = 0; i < sizeof(mi->ratetbl->rate); i++)
+		mi->ratetbl->rate[i].txpower_idx = -1;
+
+	return 0;
 }
 
 static struct minstrel_ht_sta *
@@ -386,17 +491,23 @@ minstrel_ht_rate_from_str(struct minstre
 }
 
 static int
-minstrel_ht_set_probe_rate(struct minstrel_ht_sta *mi, const char *arg_str)
+minstrel_ht_set_probe_rate(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,
+			   char *arg_str)
 {
-	char *rate_str, *count_str;
+	char *rate_str, *count_str, *txpwr_str;
 	unsigned int count;
 	int rate;
+	u16 raw_txpwr;
+	s16 max_power, txpwr = -1;
 
 	if (!arg_str)
 		return -EINVAL;
+	if (!mi->rc_manual)
+		return -EPERM;
 
-	count_str = arg_str;
-	rate_str = strsep(&count_str, ",");
+	txpwr_str = arg_str;
+	rate_str = strsep(&txpwr_str, ",");
+	count_str = strsep(&txpwr_str, ",");
 
 	rate = minstrel_ht_rate_from_str(mi, rate_str);
 	if (rate < 0)
@@ -405,71 +516,146 @@ minstrel_ht_set_probe_rate(struct minstr
 	if (!count_str || kstrtouint(count_str, 16, &count))
 		return -EINVAL;
 
+	if (txpwr_str) {
+		if (!mi->tpc_manual)
+			return -EPERM;
+
+		max_power = ieee80211_hw_get_max_txpower_idx(mp->hw);
+		if (kstrtou16(txpwr_str, 16, &raw_txpwr))
+			return -EINVAL;
+
+		txpwr = (raw_txpwr <= S16_MAX) ? (s16)raw_txpwr : -1;
+		if (txpwr > max_power)
+			return -ERANGE;
+	}
+
 	mi->user_sample_rate = rate;
 	mi->user_sample_count = count;
+	mi->user_sample_txpower = txpwr;
 	return 0;
 }
 
 static int
-minstrel_ht_set_rates(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,
-		      char **stages, unsigned int n_stages)
+minstrel_ht_ratetbl_set_rate_count(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,
+				   char **rate_count_str, unsigned int stage)
 {
-	struct ieee80211_sta_rates *ratetbl;
-	char *parts[2];
+	char *rate_str, *count_str;
 	unsigned int count;
-	int n_parts, rate;
-	int err = -EINVAL;
-	int i;
+	int rate;
+
+	rate_str = strsep(rate_count_str, ",");
+	count_str = strsep(rate_count_str, ",");
 
-	if (!stages || !stages[0] || !n_stages)
+	if (!rate_str || !count_str)
 		return -EINVAL;
 
-	if (!mi->ratetbl)
-		mi->ratetbl = kzalloc(sizeof(*ratetbl), GFP_ATOMIC);
+	rate = minstrel_ht_rate_from_str(mi, rate_str);
+	if (rate < 0)
+		return -EINVAL;
 
-	ratetbl = mi->ratetbl;
-	if (!ratetbl)
-		return -ENOMEM;
-
-	memset(ratetbl, 0, sizeof(*ratetbl));
-	for (i = 0; i < n_stages; i++) {
-		n_parts = minstrel_ht_get_args(parts, ARRAY_SIZE(parts),
-					       stages[i], ",");
-		if (n_parts < 2)
-			goto error;
-
-		rate = minstrel_ht_rate_from_str(mi, parts[0]);
-		if (rate < 0)
-			goto error;
-
-		if (kstrtouint(parts[1], 16, &count))
-			goto error;
-
-		minstrel_ht_set_rate(mp, mi, ratetbl, i, rate);
-		ratetbl->rate[i].count = count;
-		ratetbl->rate[i].count_rts = count;
-		ratetbl->rate[i].count_cts = count;
-	}
-	if (!i)
-		goto error;
+	if (kstrtouint(count_str, 16, &count))
+		return -EINVAL;
 
-	ratetbl = kmemdup(ratetbl, sizeof(*ratetbl), GFP_KERNEL);
-	if (!ratetbl)
-		return -ENOMEM;
+	minstrel_ht_set_rate(mp, mi, mi->ratetbl, stage, rate);
+	mi->ratetbl->rate[stage].count = count;
+	mi->ratetbl->rate[stage].count_rts = count;
+	mi->ratetbl->rate[stage].count_cts = count;
 
-	rate_control_set_rates(mp->hw, mi->sta, ratetbl);
+	return 0;
+}
+
+static int
+minstrel_ht_ratetbl_set_txpower(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,
+			       char *txpwr_str, int stage, s16 max_power)
+{
+	u16 raw;
+	s16 txpwr;
 
+	if (!txpwr_str)
+		return -EINVAL;
+
+	if (kstrtou16(txpwr_str, 16, &raw))
+		return -EINVAL;
+
+	txpwr = (raw <= S16_MAX) ? (s16)raw : -1;
+	if (txpwr > max_power)
+		return -ERANGE;
+
+	mi->ratetbl->rate[stage].txpower_idx = txpwr;
 	return 0;
+}
+
+static int
+minstrel_ht_set_ratetbl(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,
+			enum api_cmd cmd, char **args_str, unsigned int n_args)
+{
+	struct ieee80211_sta_rates *ratetbl;
+	unsigned int i;
+	int err = 0;
+	s16 max_tx_power;
+	bool rc, tpc;
+
+	if (!args_str || !n_args)
+		return -EINVAL;
+
+	rc = (cmd == STA_CMD_RC || cmd == STA_CMD_TPRC);
+	tpc = (cmd == STA_CMD_TPC || cmd == STA_CMD_TPRC);
+
+	if ((rc && !minstrel_ht_sta_rc_manual_mode(mi)) ||
+	    (tpc && !minstrel_ht_sta_tpc_manual_mode(mi)))
+		return -EPERM;
+
+	if (tpc)
+		max_tx_power = ieee80211_hw_get_max_txpower_idx(mp->hw);
+
+	for (i = 0; i < min_t(unsigned int, n_args, sizeof(ratetbl->rate)); i++) {
+		if (rc) {
+			err = minstrel_ht_ratetbl_set_rate_count(mp, mi, &args_str[i], i);
+			if (err)
+				return err;
+		}
+
+		if (tpc) {
+			err = minstrel_ht_ratetbl_set_txpower(mp, mi, args_str[i], i,
+							      max_tx_power);
+			if (err)
+				return err;
+		}
+	}
+	if (!i)
+		return err;
 
-error:
-	kfree(ratetbl);
-	mi->ratetbl = NULL;
+	for (; i < IEEE80211_TX_RATE_TABLE_SIZE; i++) {
+		mi->ratetbl->rate[i].idx = -1;
+		mi->ratetbl->rate[i].count = 0;
+		mi->ratetbl->rate[i].txpower_idx = -1;
+	}
 
+	minstrel_ht_update_rates(mp, mi, false);
 	return err;
 }
 
+static void
+minstrel_ht_api_sta_reset_rc_stats(struct minstrel_priv *mp, struct minstrel_ht_sta *mi)
+{
+	mi->ampdu_len = 0;
+	mi->ampdu_packets = 0;
+	mi->avg_ampdu_len = MINSTREL_FRAC(1, 1);
+	memset(&mi->max_tp_rate, 0, sizeof(u16) * MAX_THR_RATES);
+	mi->max_prob_rate = 0;
+	mi->total_packets = 0;
+	mi->sample_packets = 0;
+	mi->sample_rate = 0;
+	memset(&mi->sample, 0, sizeof(struct minstrel_sample_category) *
+			       __MINSTREL_SAMPLE_TYPE_MAX);
+	memset(&mi->groups, 0, sizeof(struct minstrel_mcs_group_data) *
+			       MINSTREL_GROUPS_NB);
+
+	minstrel_ht_update_stats(mp, mi);
+}
+
 static int
-minstrel_ht_api_sta_cmd(struct minstrel_priv *mp, enum sta_cmd cmd,
+minstrel_ht_api_sta_cmd(struct minstrel_priv *mp, enum api_cmd cmd,
 			char *arg_str)
 {
 	struct minstrel_ht_sta *mi;
@@ -478,9 +664,6 @@ minstrel_ht_api_sta_cmd(struct minstrel_
 	int n_args;
 	int ret = -EINVAL;
 
-	if (!mp->manual)
-		return -EINVAL;
-
 	n_args = minstrel_ht_get_args(args, ARRAY_SIZE(args), arg_str, ";");
 	if (!args[0])
 		return -EINVAL;
@@ -496,10 +679,24 @@ minstrel_ht_api_sta_cmd(struct minstrel_
 
 	switch (cmd) {
 	case STA_CMD_PROBE:
-		ret = minstrel_ht_set_probe_rate(mi, args[1]);
+		ret = minstrel_ht_set_probe_rate(mp, mi, args[1]);
 		break;
 	case STA_CMD_RC:
-		ret = minstrel_ht_set_rates(mp, mi, &args[1], n_args - 1);
+	case STA_CMD_TPC:
+	case STA_CMD_TPRC:
+		ret = minstrel_ht_set_ratetbl(mp, mi, cmd, &args[1], n_args - 1);
+		break;
+	case STA_CMD_RC_MODE:
+		ret = minstrel_ht_api_sta_set_rc_mode(mi, args[1]);
+		break;
+	case STA_CMD_TPC_MODE:
+		ret = minstrel_ht_api_sta_set_tpc_mode(mi, args[1]);
+		break;
+	case STA_CMD_RESET_STATS:
+		minstrel_ht_api_sta_reset_rc_stats(mp, mi);
+		break;
+	default:
+		ret = -EINVAL;
 		break;
 	}
 
@@ -507,88 +704,92 @@ minstrel_ht_api_sta_cmd(struct minstrel_
 	return ret;
 }
 
-static void
-minstrel_ht_reset_sta_rc_stats(struct minstrel_priv *mp, struct minstrel_ht_sta *mi)
-{
-	mi->ampdu_len = 0;
-	mi->ampdu_packets = 0;
-	mi->avg_ampdu_len = MINSTREL_FRAC(1, 1);
-	memset(&mi->max_tp_rate, 0, sizeof(u16) * MAX_THR_RATES);
-	mi->max_prob_rate = 0;
-	mi->total_packets = 0;
-	mi->sample_packets = 0;
-	mi->sample_rate = 0;
-	memset(&mi->sample, 0, sizeof(struct minstrel_sample_category) *
-			       __MINSTREL_SAMPLE_TYPE_MAX);
-	memset(&mi->groups, 0, sizeof(struct minstrel_mcs_group_data) *
-			       MINSTREL_GROUPS_NB);
-
-	minstrel_ht_update_stats(mp, mi);
-}
-
 static int
-minstrel_ht_reset_stats(struct minstrel_priv *mp, char *buf)
+minstrel_ht_api_exec_cmd_for_all(struct minstrel_priv *mp, enum api_cmd cmd,
+				 char *args)
 {
 	struct minstrel_ht_sta *mi;
-	uint8_t macaddr[ETH_ALEN];
-	int err = 0;
+	int ret = 0;
 
 	rcu_read_lock();
 
-	if (!buf) {
-		list_for_each_entry(mi, &mp->stations, list)
-			minstrel_ht_reset_sta_rc_stats(mp, mi);
-		goto out;
-	}
-
-	if (!mac_pton(buf, macaddr)) {
-		err = -EINVAL;
-		goto out;
+	switch (cmd) {
+	case STA_CMD_RESET_STATS:
+		list_for_each_entry_rcu(mi, &mp->stations, list)
+			minstrel_ht_api_sta_reset_rc_stats(mp, mi);
+		break;
+	case STA_CMD_RC_MODE:
+		list_for_each_entry_rcu(mi, &mp->stations, list)
+			minstrel_ht_api_sta_set_rc_mode(mi, args);
+		break;
+	case STA_CMD_TPC_MODE:
+		list_for_each_entry_rcu(mi, &mp->stations, list)
+			minstrel_ht_api_sta_set_tpc_mode(mi, args);
+		break;
+	default:
+		ret = -EPERM;
 	}
 
-	mi = minstrel_ht_api_get_sta(mp, macaddr);
-	if (!mi) {
-		err = -ENOENT;
-		goto out;
-	}
+	rcu_read_unlock();
+	return ret;
+}
 
-	minstrel_ht_reset_sta_rc_stats(mp, mi);
+static int
+minstrel_ht_api_exec_cmd(struct minstrel_priv *mp, enum api_cmd cmd, char *args)
+{
+	int err = 0;
 
-out:
-	rcu_read_unlock();
+	switch (cmd) {
+	case PHY_CMD_START:
+		minstrel_ht_api_start(mp, args);
+		break;
+	case PHY_CMD_STOP:
+		minstrel_ht_api_stop(mp, args);
+		break;
+	case PHY_CMD_DUMP:
+		minstrel_ht_dump_stations(mp, "dump");
+		break;
+	case STA_CMD_RC_MODE:
+	case STA_CMD_TPC_MODE:
+	case STA_CMD_RESET_STATS:
+		if (args && !strncmp(args, "all", 3)) {
+			strsep(&args, ";");
+			err = minstrel_ht_api_exec_cmd_for_all(mp, cmd, args);
+			break;
+		}
+		fallthrough;
+	case STA_CMD_PROBE:
+	case STA_CMD_TPRC:
+		err = minstrel_ht_api_sta_cmd(mp, cmd, args);
+		break;
+	default:
+		err = -EINVAL;
+	}
 
 	return err;
 }
 
 static int
-minstrel_ht_execute_and_echo(struct minstrel_priv *mp, char *cmd, char *args)
+minstrel_ht_api_exec_and_echo_cmd(struct minstrel_priv *mp, enum api_cmd cmd,
+				  char* cmd_str, char *args)
 {
 	char buf[96];
 	int err = 0, len;
 
+	/* Store command with timestamp, args may be modified later */
 	len = scnprintf(buf, sizeof(buf), "%llx;%s",
-			(unsigned long long)ktime_get_real_fast_ns(), cmd);
+			(unsigned long long)ktime_get_real_fast_ns(),
+			cmd_str);
 	if (args)
 		len += scnprintf(buf + len, sizeof(buf) - len, ";%s\n", args);
 	else
 		len += scnprintf(buf + len, sizeof(buf) - len, "\n");
 
-	if (!strcmp(cmd, "start"))
-		minstrel_ht_api_start(mp, args);
-	else if (!strcmp(cmd, "stop"))
-		minstrel_ht_api_stop(mp);
-	else if (!strcmp(cmd, "manual"))
-		minstrel_ht_api_set_manual(mp, true);
-	else if (!strcmp(cmd, "auto"))
-		minstrel_ht_api_set_manual(mp, false);
-	else if (!strcmp(cmd, "reset_stats"))
-		err = minstrel_ht_reset_stats(mp, args);
-	else
-		err = -EINVAL;
-
+	err = minstrel_ht_api_exec_cmd(mp, cmd, args);
 	if (err)
 		return err;
 
+	/* Echo command to api_event */
 	spin_lock_bh(&mp->relay_lock);
 	relay_write(mp->relay_ev, buf, len);
 	relay_flush(mp->relay_ev);
@@ -602,10 +803,12 @@ minstrel_ht_control_write(struct file *f
 			  size_t count, loff_t *ppos)
 {
 	struct minstrel_priv *mp = file->private_data;
+	enum api_cmd cmd;
 	char *pos, *cur;
 	char buf[64];
 	size_t len = count;
 	int err;
+	bool echo = true;
 
 	if (len > sizeof(buf) - 1)
 		return -EINVAL;
@@ -623,16 +826,37 @@ minstrel_ht_control_write(struct file *f
 	pos = buf;
 	cur = strsep(&pos, ";");
 
-	err = 0;
-	if (!strcmp(cur, "dump"))
-		minstrel_ht_dump_stations(mp, "dump");
-	else if (!strcmp(cur, "set_rates") || !strcmp(cur, "rates"))
-		err = minstrel_ht_api_sta_cmd(mp, STA_CMD_RC, pos);
-	else if (!strcmp(cur, "set_probe"))
-		err = minstrel_ht_api_sta_cmd(mp, STA_CMD_PROBE, pos);
-	else
-		err = minstrel_ht_execute_and_echo(mp, cur, pos);
+	if (!strcmp(cur, "set_rates_power") || !strcmp(cur, "rates")) {
+		cmd = STA_CMD_TPRC;
+		echo = (mp->monitor & MINSTREL_ECHO_TPRC);
+	} else if (!strcmp(cur, "set_power")) {
+		cmd = STA_CMD_TPC;
+		echo = (mp->monitor & MINSTREL_ECHO_TPRC);
+	} else if (!strcmp(cur, "set_rates")) {
+		cmd = STA_CMD_RC;
+		echo = (mp->monitor & MINSTREL_ECHO_TPRC);
+	} else if (!strcmp(cur, "set_probe")) {
+		cmd = STA_CMD_PROBE;
+		echo = (mp->monitor & MINSTREL_ECHO_TPRC);
+	} else if (!strcmp(cur, "dump")) {
+		cmd = PHY_CMD_DUMP;
+		echo = false;
+	} else if (!strcmp(cur, "start")) {
+		cmd = PHY_CMD_START;
+	} else if (!strcmp(cur, "stop")) {
+		cmd = PHY_CMD_STOP;
+	} else if (!strcmp(cur, "rc_mode")) {
+		cmd = STA_CMD_RC_MODE;
+	} else if (!strcmp(cur, "tpc_mode")) {
+		cmd = STA_CMD_TPC_MODE;
+	} else if (!strcmp(cur, "reset_stats")) {
+		cmd = STA_CMD_RESET_STATS;
+	} else {
+		return -EINVAL;
+	}
 
+	err = (echo) ? minstrel_ht_api_exec_and_echo_cmd(mp, cmd, cur, pos)
+		     : minstrel_ht_api_exec_cmd(mp, cmd, pos);
 	if (err)
 		return err;
 
@@ -671,6 +895,7 @@ void minstrel_ht_sta_remove(struct minst
 
 	list_del_rcu(&mi->list);
 	INIT_LIST_HEAD_RCU(&mi->list);
+	kfree(mi->ratetbl);
 
 	spin_unlock_bh(&mp->sta_wlock);
 
@@ -694,9 +919,10 @@ void __minstrel_ht_report_tx_status(stru
 				    struct minstrel_ht_sta *mi,
 				    struct ieee80211_tx_info *info,
 				    u16 *rate_list,
+				    s16 *txpwr_list,
 				    int n_rates)
 {
-	char txs[64 + IEEE80211_TX_MAX_RATES * 8];
+	char txs[64 + IEEE80211_TX_MAX_RATES * 14];
 	int ofs = 0;
 	int i;
 
@@ -712,12 +938,13 @@ void __minstrel_ht_report_tx_status(stru
 			 !!(info->flags & IEEE80211_TX_CTL_RATE_CTRL_PROBE));
 
 	for (i = 0; i < n_rates; i++)
-		ofs += scnprintf(txs + ofs, sizeof(txs) - ofs, ";%x;%x",
+		ofs += scnprintf(txs + ofs, sizeof(txs) - ofs, ";%x,%x,%x",
 				 rate_list[i],
-				 info->status.rates[i].count);
+				 info->status.rates[i].count,
+				 (u16)(txpwr_list[i]));
 
 	for (; i < IEEE80211_TX_MAX_RATES; i++)
-		ofs += scnprintf(txs + ofs, sizeof(txs) - ofs, ";ffff;0");
+		ofs += scnprintf(txs + ofs, sizeof(txs) - ofs, ";,,");
 
 	ofs += scnprintf(txs + ofs, sizeof(txs) - ofs, "\n");
 
--- a/net/mac80211/rc80211_minstrel_ht.c
+++ b/net/mac80211/rc80211_minstrel_ht.c
@@ -274,10 +274,6 @@ static const u8 minstrel_sample_seq[] =
 	MINSTREL_SAMPLE_TYPE_SLOW,
 };
 
-static void
-minstrel_ht_update_rates(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,
-			 bool force);
-
 /*
  * Some VHT MCSes are invalid (when Ndbps / Nes is not an integer)
  * e.g for MCS9@20MHzx1Nss: Ndbps=8x52*(5/6) Nes=1
@@ -1157,7 +1153,7 @@ minstrel_ht_update_stats(struct minstrel
 
 	minstrel_ht_report_best_rates(mp, mi);
 
-	if (!minstrel_ht_manual_mode(mp)) {
+	if (!minstrel_ht_sta_rc_manual_mode(mi)) {
 		minstrel_ht_refill_sample_rates(mi);
 		minstrel_ht_report_sample_rates(mp, mi);
 	}
@@ -1269,6 +1265,7 @@ minstrel_ht_tx_status(void *priv, struct
 	u32 update_interval = mp->update_interval;
 	bool last, update = false;
 	u16 rate_list[IEEE80211_TX_MAX_RATES] = {};
+	s16 txpwr_list[IEEE80211_TX_MAX_RATES] = {};
 	int i;
 
 	/* Ignore packet that was sent with noAck flag */
@@ -1317,6 +1314,7 @@ minstrel_ht_tx_status(void *priv, struct
 
 			rate->attempts += st->rates[i].try_count *
 					  info->status.ampdu_len;
+			txpwr_list[i] = st->rates[i].txpower_idx;
 		}
 	} else {
 		last = !minstrel_ht_txstat_valid(mp, mi, &ar[0]);
@@ -1330,10 +1328,11 @@ minstrel_ht_tx_status(void *priv, struct
 				rate->success += info->status.ampdu_ack_len;
 
 			rate->attempts += ar[i].count * info->status.ampdu_len;
+			txpwr_list[i] = -1;
 		}
 	}
 
-	minstrel_ht_report_tx_status(mp, mi, info, rate_list, i);
+	minstrel_ht_report_tx_status(mp, mi, info, rate_list, txpwr_list, i);
 
 	if (mp->hw->max_rates > 1) {
 		/*
@@ -1529,49 +1528,57 @@ minstrel_ht_get_max_amsdu_len(struct min
 	return 0;
 }
 
-static void
+void
 minstrel_ht_update_rates(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,
 			 bool force)
 {
 	struct ieee80211_sta_rates *rates;
 	int i = 0;
 	int max_rates = min_t(int, mp->hw->max_rates, IEEE80211_TX_RATE_TABLE_SIZE);
-
-	if (minstrel_ht_manual_mode(mp) && !force) {
-		if (mi->ratetbl) {
-			rates = kmemdup(mi->ratetbl, sizeof(*rates), GFP_ATOMIC);
-			if (rates)
-				rate_control_set_rates(mp->hw, mi->sta, rates);
-		}
-		return;
-	}
+	bool manual_rc, manual_tpc, update_stats = true;
 
 	rates = kzalloc(sizeof(*rates), GFP_ATOMIC);
 	if (!rates)
 		return;
 
-	/* Start with max_tp_rate[0] */
-	minstrel_ht_set_rate(mp, mi, rates, i, mi->max_tp_rate[0]);
-	rates->rate[i].txpower_idx = -1;
-	i++;
-
-	/* Fill up remaining, keep one entry for max_probe_rate */
-	for (; i < (max_rates - 1); i++) {
-		minstrel_ht_set_rate(mp, mi, rates, i, mi->max_tp_rate[i]);
-		rates->rate[i].txpower_idx = -1;
-	}
-
-	if (i < max_rates) {
-		minstrel_ht_set_rate(mp, mi, rates, i, mi->max_prob_rate);
-		rates->rate[i].txpower_idx = -1;
-		i++;
-	}
+	manual_rc = minstrel_ht_sta_rc_manual_mode(mi) && !force;
+	manual_tpc = minstrel_ht_sta_tpc_manual_mode(mi) && !force;
 
-	if (i < IEEE80211_TX_RATE_TABLE_SIZE)
-		rates->rate[i].idx = -1;
+	if (manual_rc) {
+		if (mi->ratetbl->rate[0].idx >= 0) {
+			memcpy(rates, mi->ratetbl, sizeof(*rates));
+		} else {
+			kfree(rates);
+			return;
+		}
+		update_stats = false;
+	} else {
+		/* Start with max_tp_rate[0] */
+		minstrel_ht_set_rate(mp, mi, rates, i++, mi->max_tp_rate[0]);
 
-	mi->sta->deflink.agg.max_rc_amsdu_len = minstrel_ht_get_max_amsdu_len(mi);
-	ieee80211_sta_recalc_aggregates(mi->sta);
+		/* Fill up remaining, keep one entry for max_probe_rate */
+		for (; i < (max_rates - 1); i++)
+			minstrel_ht_set_rate(mp, mi, rates, i, mi->max_tp_rate[i]);
+
+		if (i < max_rates)
+			minstrel_ht_set_rate(mp, mi, rates, i++, mi->max_prob_rate);
+
+		if (i < IEEE80211_TX_RATE_TABLE_SIZE)
+			rates->rate[i].idx = -1;
+	}
+
+	/* Whole ratetbl copied before so we do not need to read values again */
+	if (!manual_rc)
+		for (i = 0; i < max_rates; i++)
+			rates->rate[i].txpower_idx = manual_tpc
+					? mi->ratetbl->rate[i].txpower_idx
+					: -1;
+
+	if (update_stats) {
+		mi->sta->deflink.agg.max_rc_amsdu_len =
+			minstrel_ht_get_max_amsdu_len(mi);
+		ieee80211_sta_recalc_aggregates(mi->sta);
+	}
 	rate_control_set_rates(mp->hw, mi->sta, rates);
 }
 
@@ -1580,7 +1587,7 @@ minstrel_ht_get_sample_rate(struct minst
 {
 	u8 seq;
 
-	if (mp->hw->max_rates > 1 && !minstrel_ht_manual_mode(mp)) {
+	if (mp->hw->max_rates > 1 && !minstrel_ht_sta_rc_manual_mode(mi)) {
 		seq = mi->sample_seq;
 		mi->sample_seq = (seq + 1) % ARRAY_SIZE(minstrel_sample_seq);
 		seq = minstrel_sample_seq[seq];
@@ -1619,7 +1626,11 @@ minstrel_ht_get_rate(void *priv, struct
 	    (info->control.flags & IEEE80211_TX_CTRL_PORT_CTRL_PROTO))
 		return;
 
-	if (minstrel_ht_manual_mode(mp) && mi->user_sample_rate != -1) {
+	if (minstrel_ht_sta_tpc_manual_mode(mi) && mi->user_sample_txpower != -1) {
+		sample_txpower = mi->user_sample_txpower;
+		mi->user_sample_txpower = -1;
+	}
+	if (minstrel_ht_sta_rc_manual_mode(mi) && mi->user_sample_rate != -1) {
 		sample_idx = mi->user_sample_rate;
 		if (mi->user_sample_count > 0 &&
 		    mi->user_sample_count <= IEEE80211_MAX_TX_RETRY)
@@ -1900,8 +1911,10 @@ minstrel_ht_alloc_sta(void *priv, struct
 
 #ifdef CPTCFG_MAC80211_RC_MINSTREL_DEBUGFS_API
 	INIT_LIST_HEAD(&mi->list);
+	mi->ratetbl = kzalloc(sizeof(*mi->ratetbl), gfp);
 	mi->user_sample_rate = -1;
 	mi->user_sample_count = 0;
+	mi->user_sample_txpower = -1;
 #endif
 
 	return mi;
--- a/net/mac80211/rc80211_minstrel_ht.h
+++ b/net/mac80211/rc80211_minstrel_ht.h
@@ -76,6 +76,7 @@
 #define MINSTREL_MONITOR_TXS		BIT(1)
 #define MINSTREL_MONITOR_RXS		BIT(2)
 #define MINSTREL_MONITOR_STATS		BIT(3)
+#define MINSTREL_ECHO_TPRC		BIT(7)
 
 struct minstrel_priv {
 	struct ieee80211_hw *hw;
@@ -107,7 +108,6 @@ struct minstrel_priv {
 	spinlock_t sta_wlock;
 
 	u8 monitor;
-	bool manual;
 #endif
 };
 
@@ -172,8 +172,12 @@ struct minstrel_ht_sta {
 #ifdef CPTCFG_MAC80211_RC_MINSTREL_DEBUGFS_API
 	struct list_head list;
 	u32 user_sample_rate;
+	s16 user_sample_txpower;
 	u8 user_sample_count;
 	struct ieee80211_sta_rates *ratetbl;
+
+	bool rc_manual;
+	bool tpc_manual;
 #endif
 	struct ieee80211_sta *sta;
 	spinlock_t lock;
@@ -227,7 +231,7 @@ void minstrel_ht_sta_remove(struct minst
 void __minstrel_ht_report_tx_status(struct minstrel_priv *mp,
 				    struct minstrel_ht_sta *mi,
 				    struct ieee80211_tx_info *info,
-				    u16 *rate_list, int n_rates);
+				    u16 *rate_list, s16* txpwr_list, int n_rates);
 void __minstrel_ht_report_rx_status(struct minstrel_priv *mp, u8 *addr,
                                     int last_signal, u8 chain_status,
                                     s8 *chain_signal);
@@ -265,13 +269,14 @@ static inline void
 minstrel_ht_report_tx_status(struct minstrel_priv *mp,
 			     struct minstrel_ht_sta *mi,
 			     struct ieee80211_tx_info *info,
-			     u16 *rate_list, int n_rates)
+			     u16 *rate_list, s16 *txpwr_list, int n_rates)
 {
 #ifdef CPTCFG_MAC80211_RC_MINSTREL_DEBUGFS_API
 	if (!(mp->monitor & MINSTREL_MONITOR_TXS))
 		return;
 
-	__minstrel_ht_report_tx_status(mp, mi, info, rate_list, n_rates);
+	__minstrel_ht_report_tx_status(mp, mi, info, rate_list, txpwr_list,
+				       n_rates);
 #endif
 }
 
@@ -324,10 +329,20 @@ minstrel_ht_report_sample_rates(struct m
 }
 
 static inline bool
-minstrel_ht_manual_mode(struct minstrel_priv *mp)
+minstrel_ht_sta_rc_manual_mode(struct minstrel_ht_sta *mi)
+{
+#ifdef CPTCFG_MAC80211_RC_MINSTREL_DEBUGFS_API
+	return mi->rc_manual;
+#else
+	return false;
+#endif
+}
+
+static inline bool
+minstrel_ht_sta_tpc_manual_mode(struct minstrel_ht_sta *mi)
 {
 #ifdef CPTCFG_MAC80211_RC_MINSTREL_DEBUGFS_API
-	return mp->manual;
+	return mi->tpc_manual;
 #else
 	return false;
 #endif
@@ -338,6 +353,8 @@ void minstrel_ht_set_rate(struct minstre
 						  int index);
 int minstrel_ht_get_tp_avg(struct minstrel_ht_sta *mi, int group, int rate,
 			   int prob_avg);
+void minstrel_ht_update_rates(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,
+			      bool force);
 void minstrel_ht_update_stats(struct minstrel_priv *mp, struct minstrel_ht_sta *mi);
 
 #endif
