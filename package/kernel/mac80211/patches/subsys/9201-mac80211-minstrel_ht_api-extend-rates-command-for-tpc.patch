--- a/net/mac80211/rc80211_minstrel_ht_api.c
+++ b/net/mac80211/rc80211_minstrel_ht_api.c
@@ -402,11 +402,12 @@ minstrel_ht_set_rates(struct minstrel_pr
 		      char **stages, unsigned int n_stages)
 {
 	struct ieee80211_sta_rates *ratetbl;
-	char *parts[2];
+	char *parts[3];
 	unsigned int count;
-	int n_parts, rate;
+	int n_parts, rate, txpwr;
 	int err = -EINVAL;
 	int i;
+	s16 max_power;
 
 	if (!stages || !stages[0] || !n_stages)
 		return -EINVAL;
@@ -418,6 +419,8 @@ minstrel_ht_set_rates(struct minstrel_pr
 	if (!ratetbl)
 		return -ENOMEM;
 
+	max_power = ieee80211_hw_get_max_txpower_idx(mp->hw);
+
 	memset(ratetbl, 0, sizeof(*ratetbl));
 	for (i = 0; i < n_stages; i++) {
 		n_parts = minstrel_ht_get_args(parts, ARRAY_SIZE(parts),
@@ -436,10 +439,22 @@ minstrel_ht_set_rates(struct minstrel_pr
 		ratetbl->rate[i].count = count;
 		ratetbl->rate[i].count_rts = count;
 		ratetbl->rate[i].count_cts = count;
+
+		if (n_parts > 2 && !kstrtoint(parts[2], 16, &txpwr)) {
+			if (txpwr > max_power)
+				goto error;
+
+			ratetbl->rate[i].txpower_idx = (s16)txpwr;
+		} else {
+			ratetbl->rate[i].txpower_idx = -1;
+		}
 	}
 	if (!i)
 		goto error;
 
+	for (; i < IEEE80211_TX_RATE_TABLE_SIZE; i++)
+		ratetbl->rate[i].txpower_idx = -1;
+
 	ratetbl = kmemdup(ratetbl, sizeof(*ratetbl), GFP_KERNEL);
 	if (!ratetbl)
 		return -ENOMEM;
@@ -461,7 +476,7 @@ minstrel_ht_api_sta_cmd(struct minstrel_
 {
 	struct minstrel_ht_sta *mi;
 	uint8_t macaddr[ETH_ALEN];
-	char *args[3];
+	char *args[4];
 	int n_args;
 	int ret = -EINVAL;
 
