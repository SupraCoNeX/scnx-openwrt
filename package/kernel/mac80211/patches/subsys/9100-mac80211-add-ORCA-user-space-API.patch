--- a/net/mac80211/rx.c
+++ b/net/mac80211/rx.c
@@ -32,6 +32,7 @@
 #include "tkip.h"
 #include "wme.h"
 #include "rate.h"
+#include "rc80211_minstrel_ht.h"
 
 /*
  * monitor mode reception
@@ -1778,6 +1779,12 @@ ieee80211_rx_h_sta_process(struct ieee80
 		}
 	}
 
+	if (rx->local->rate_ctrl && test_sta_flag(sta, WLAN_STA_RATE_CONTROL)) {
+		orca_report_rx_status(rx->local->rate_ctrl->priv, sta->addr,
+			(!(status->flag & RX_FLAG_NO_SIGNAL_VAL) ? status->signal : -1),
+			status->chains, status->chain_signal);
+	}
+
 	if (ieee80211_is_s1g_beacon(hdr->frame_control))
 		return RX_CONTINUE;
 
--- a/local-symbols
+++ b/local-symbols
@@ -41,6 +41,7 @@ LIB80211_DEBUG=
 MAC80211=
 MAC80211_HAS_RC=
 MAC80211_RC_MINSTREL=
+MAC80211_ORCA_UAPI=
 MAC80211_RC_DEFAULT_MINSTREL=
 MAC80211_RC_DEFAULT=
 MAC80211_MESH=
--- a/net/mac80211/Kconfig
+++ b/net/mac80211/Kconfig
@@ -98,6 +98,15 @@ config MAC80211_MESSAGE_TRACING
 	  need to be present in the binary and formatted at
 	  runtime for tracing.
 
+config MAC80211_ORCA_UAPI
+        bool "ORCA Userspace API"
+        depends on MAC80211_RC_MINSTREL
+        depends on MAC80211_DEBUGFS
+        select RELAY
+        help
+          This option creates debugfs files that allow user space to observe
+          and/or control minstrel rate selection behavior
+
 menuconfig MAC80211_DEBUG_MENU
 	bool "Select mac80211 debugging features"
 	depends on MAC80211
--- a/net/mac80211/Makefile
+++ b/net/mac80211/Makefile
@@ -63,6 +63,9 @@ rc80211_minstrel-y := \
 rc80211_minstrel-$(CPTCFG_MAC80211_DEBUGFS) += \
 	rc80211_minstrel_ht_debugfs.o
 
+rc80211_minstrel-$(CPTCFG_MAC80211_ORCA_UAPI) += \
+	orca_uapi.o
+
 mac80211-$(CPTCFG_MAC80211_RC_MINSTREL) += $(rc80211_minstrel-y)
 
 ccflags-y += -DDEBUG
--- a/net/mac80211/rc80211_minstrel_ht.c
+++ b/net/mac80211/rc80211_minstrel_ht.c
@@ -264,7 +264,7 @@ const struct mcs_group minstrel_mcs_grou
 
 const s16 minstrel_cck_bitrates[4] = { 10, 20, 55, 110 };
 const s16 minstrel_ofdm_bitrates[8] = { 60, 90, 120, 180, 240, 360, 480, 540 };
-static u8 sample_table[SAMPLE_COLUMNS][MCS_GROUP_RATES] __read_mostly;
+u8 sample_table[SAMPLE_COLUMNS][MCS_GROUP_RATES] __read_mostly;
 static const u8 minstrel_sample_seq[] = {
 	MINSTREL_SAMPLE_TYPE_INC,
 	MINSTREL_SAMPLE_TYPE_JUMP,
@@ -274,9 +274,6 @@ static const u8 minstrel_sample_seq[] =
 	MINSTREL_SAMPLE_TYPE_SLOW,
 };
 
-static void
-minstrel_ht_update_rates(struct minstrel_priv *mp, struct minstrel_ht_sta *mi);
-
 /*
  * Some VHT MCSes are invalid (when Ndbps / Nes is not an integer)
  * e.g for MCS9@20MHzx1Nss: Ndbps=8x52*(5/6) Nes=1
@@ -368,7 +365,7 @@ minstrel_vht_ri_get_group_idx(struct rat
 
 static struct minstrel_rate_stats *
 minstrel_ht_get_stats(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,
-		      struct ieee80211_tx_rate *rate)
+		      struct ieee80211_tx_rate *rate, u16 *dest_idx)
 {
 	int group, idx;
 
@@ -406,6 +403,7 @@ minstrel_ht_get_stats(struct minstrel_pr
 
 	idx = 0;
 out:
+	*dest_idx = MI_RATE(group, idx);
 	return &mi->groups[group].rates[idx];
 }
 
@@ -414,7 +412,8 @@ out:
  */
 static struct minstrel_rate_stats *
 minstrel_ht_ri_get_stats(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,
-			  struct ieee80211_rate_status *rate_status)
+			 struct ieee80211_rate_status *rate_status,
+			 u16 *dest_idx)
 {
 	int group, idx;
 	struct rate_info *rate = &rate_status->rate_idx;
@@ -450,6 +449,7 @@ minstrel_ht_ri_get_stats(struct minstrel
 
 	idx = 0;
 out:
+	*dest_idx = MI_RATE(group, idx);
 	return &mi->groups[group].rates[idx];
 }
 
@@ -1025,7 +1025,7 @@ minstrel_ht_refill_sample_rates(struct m
  *  - as long as the max prob rate has a probability of more than 75%, pick
  *    higher throughput rates, even if the probablity is a bit lower
  */
-static void
+void
 minstrel_ht_update_stats(struct minstrel_priv *mp, struct minstrel_ht_sta *mi)
 {
 	struct minstrel_mcs_group_data *mg;
@@ -1089,6 +1089,8 @@ minstrel_ht_update_stats(struct minstrel
 			tp_rate = tmp_legacy_tp_rate;
 
 		for (i = MCS_GROUP_RATES - 1; i >= 0; i--) {
+			bool changed;
+
 			if (!(mi->supported[group] & BIT(i)))
 				continue;
 
@@ -1096,7 +1098,11 @@ minstrel_ht_update_stats(struct minstrel
 
 			mrs = &mg->rates[i];
 			mrs->retry_updated = false;
+			changed = mrs->attempts > 0;
 			minstrel_ht_calc_rate_stats(mp, mrs);
+			if (changed)
+				orca_report_rate_update(mp, mi, index,
+							       mrs);
 
 			if (mrs->att_hist)
 				last_prob = max(last_prob, mrs->prob_avg);
@@ -1145,7 +1151,12 @@ minstrel_ht_update_stats(struct minstrel
 
 	mi->max_prob_rate = tmp_max_prob_rate;
 
-	minstrel_ht_refill_sample_rates(mi);
+	orca_report_best_rates(mp, mi);
+
+	if (!orca_sta_rc_manual_mode(mi)) {
+		minstrel_ht_refill_sample_rates(mi);
+		orca_report_sample_rates(mp, mi);
+	}
 
 #ifdef CPTCFG_MAC80211_DEBUGFS
 	/* use fixed index if set */
@@ -1253,6 +1264,8 @@ minstrel_ht_tx_status(void *priv, struct
 	struct minstrel_priv *mp = priv;
 	u32 update_interval = mp->update_interval;
 	bool last, update = false;
+	u16 rate_list[IEEE80211_TX_MAX_RATES] = {};
+	s16 txpwr_list[IEEE80211_TX_MAX_RATES] = {};
 	int i;
 
 	/* Ignore packet that was sent with noAck flag */
@@ -1270,6 +1283,8 @@ minstrel_ht_tx_status(void *priv, struct
 		info->status.ampdu_len = 1;
 	}
 
+	spin_lock_bh(&mi->lock);
+
 	/* wraparound */
 	if (mi->total_packets >= ~0 - info->status.ampdu_len) {
 		mi->total_packets = 0;
@@ -1291,13 +1306,15 @@ minstrel_ht_tx_status(void *priv, struct
 							&(st->rates[i + 1]));
 
 			rate = minstrel_ht_ri_get_stats(mp, mi,
-							&(st->rates[i]));
+							&(st->rates[i]),
+							&rate_list[i]);
 
 			if (last)
 				rate->success += info->status.ampdu_ack_len;
 
 			rate->attempts += st->rates[i].try_count *
 					  info->status.ampdu_len;
+			txpwr_list[i] = st->rates[i].txpower_idx;
 		}
 	} else {
 		last = !minstrel_ht_txstat_valid(mp, mi, &ar[0]);
@@ -1305,14 +1322,18 @@ minstrel_ht_tx_status(void *priv, struct
 			last = (i == IEEE80211_TX_MAX_RATES - 1) ||
 				!minstrel_ht_txstat_valid(mp, mi, &ar[i + 1]);
 
-			rate = minstrel_ht_get_stats(mp, mi, &ar[i]);
+			rate = minstrel_ht_get_stats(mp, mi, &ar[i], &rate_list[i]);
+
 			if (last)
 				rate->success += info->status.ampdu_ack_len;
 
 			rate->attempts += ar[i].count * info->status.ampdu_len;
+			txpwr_list[i] = -1;
 		}
 	}
 
+	orca_report_tx_status(mp, mi, info, rate_list, txpwr_list, i);
+
 	if (mp->hw->max_rates > 1) {
 		/*
 		 * check for sudden death of spatial multiplexing,
@@ -1334,7 +1355,9 @@ minstrel_ht_tx_status(void *priv, struct
 	}
 
 	if (update)
-		minstrel_ht_update_rates(mp, mi);
+		minstrel_ht_update_rates(mp, mi, false);
+
+	spin_unlock_bh(&mi->lock);
 }
 
 static void
@@ -1397,7 +1420,7 @@ minstrel_calc_retransmit(struct minstrel
 }
 
 
-static void
+void
 minstrel_ht_set_rate(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,
                      struct ieee80211_sta_rates *ratetbl, int offset, int index)
 {
@@ -1505,39 +1528,57 @@ minstrel_ht_get_max_amsdu_len(struct min
 	return 0;
 }
 
-static void
-minstrel_ht_update_rates(struct minstrel_priv *mp, struct minstrel_ht_sta *mi)
+void
+minstrel_ht_update_rates(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,
+			 bool force)
 {
 	struct ieee80211_sta_rates *rates;
 	int i = 0;
 	int max_rates = min_t(int, mp->hw->max_rates, IEEE80211_TX_RATE_TABLE_SIZE);
+	bool manual_rc, manual_tpc, update_stats = true;
 
 	rates = kzalloc(sizeof(*rates), GFP_ATOMIC);
 	if (!rates)
 		return;
 
-	/* Start with max_tp_rate[0] */
-	minstrel_ht_set_rate(mp, mi, rates, i, mi->max_tp_rate[0]);
-	rates->rate[i].txpower_idx = -1;
-	i++;
-
-	/* Fill up remaining, keep one entry for max_probe_rate */
-	for (; i < (max_rates - 1); i++) {
-		minstrel_ht_set_rate(mp, mi, rates, i, mi->max_tp_rate[i]);
-		rates->rate[i].txpower_idx = -1;
-	}
-
-	if (i < max_rates) {
-		minstrel_ht_set_rate(mp, mi, rates, i, mi->max_prob_rate);
-		rates->rate[i].txpower_idx = -1;
-		i++;
-	}
+	manual_rc = orca_sta_rc_manual_mode(mi) && !force;
+	manual_tpc = orca_sta_tpc_manual_mode(mi) && !force;
 
-	if (i < IEEE80211_TX_RATE_TABLE_SIZE)
-		rates->rate[i].idx = -1;
+	if (manual_rc) {
+		if (mi->ratetbl->rate[0].idx >= 0) {
+			memcpy(rates, mi->ratetbl, sizeof(*rates));
+		} else {
+			kfree(rates);
+			return;
+		}
+		update_stats = false;
+	} else {
+		/* Start with max_tp_rate[0] */
+		minstrel_ht_set_rate(mp, mi, rates, i++, mi->max_tp_rate[0]);
 
-	mi->sta->deflink.agg.max_rc_amsdu_len = minstrel_ht_get_max_amsdu_len(mi);
-	ieee80211_sta_recalc_aggregates(mi->sta);
+		/* Fill up remaining, keep one entry for max_probe_rate */
+		for (; i < (max_rates - 1); i++)
+			minstrel_ht_set_rate(mp, mi, rates, i, mi->max_tp_rate[i]);
+
+		if (i < max_rates)
+			minstrel_ht_set_rate(mp, mi, rates, i++, mi->max_prob_rate);
+
+		if (i < IEEE80211_TX_RATE_TABLE_SIZE)
+			rates->rate[i].idx = -1;
+	}
+
+	/* Whole ratetbl copied before so we do not need to read values again */
+	if (!manual_rc)
+		for (i = 0; i < max_rates; i++)
+			rates->rate[i].txpower_idx = manual_tpc
+					? mi->ratetbl->rate[i].txpower_idx
+					: -1;
+
+	if (update_stats) {
+		mi->sta->deflink.agg.max_rc_amsdu_len =
+			minstrel_ht_get_max_amsdu_len(mi);
+		ieee80211_sta_recalc_aggregates(mi->sta);
+	}
 	rate_control_set_rates(mp->hw, mi->sta, rates);
 }
 
@@ -1546,7 +1587,7 @@ minstrel_ht_get_sample_rate(struct minst
 {
 	u8 seq;
 
-	if (mp->hw->max_rates > 1) {
+	if (mp->hw->max_rates > 1 && !orca_sta_rc_manual_mode(mi)) {
 		seq = mi->sample_seq;
 		mi->sample_seq = (seq + 1) % ARRAY_SIZE(minstrel_sample_seq);
 		seq = minstrel_sample_seq[seq];
@@ -1567,6 +1608,8 @@ minstrel_ht_get_rate(void *priv, struct
 	struct minstrel_ht_sta *mi = priv_sta;
 	struct minstrel_priv *mp = priv;
 	u16 sample_idx;
+	u32 sampling_interval = MINSTREL_SAMPLE_INTERVAL;
+	u8 sample_count = 1;
 	s16 sample_txpower = -1;
 
 	info->flags |= mi->tx_flags;
@@ -1574,6 +1617,8 @@ minstrel_ht_get_rate(void *priv, struct
 #ifdef CPTCFG_MAC80211_DEBUGFS
 	if (mp->fixed_rate_idx != -1)
 		return;
+
+	sampling_interval = mp->sampling_interval;
 #endif
 
 	/* Don't use EAPOL frames for sampling on non-mrr hw */
@@ -1581,14 +1626,34 @@ minstrel_ht_get_rate(void *priv, struct
 	    (info->control.flags & IEEE80211_TX_CTRL_PORT_CTRL_PROTO))
 		return;
 
+	if (orca_sta_tpc_manual_mode(mi) && mi->user_sample_txpower != -1) {
+		sample_txpower = mi->user_sample_txpower;
+		mi->user_sample_txpower = -1;
+	}
+	if (orca_sta_rc_manual_mode(mi) && mi->user_sample_rate != -1) {
+		sample_idx = mi->user_sample_rate;
+		if (mi->user_sample_count > 0 &&
+		    mi->user_sample_count <= IEEE80211_MAX_TX_RETRY)
+			sample_count = mi->user_sample_count;
+
+		mi->user_sample_rate = -1;
+		mi->user_sample_count = 0;
+
+		goto set_rate;
+	}
+
 	if (time_is_after_jiffies(mi->sample_time))
 		return;
 
-	mi->sample_time = jiffies + MINSTREL_SAMPLE_INTERVAL;
+	spin_lock_bh(&mi->lock);
+
+	mi->sample_time = jiffies + sampling_interval;
 	sample_idx = minstrel_ht_get_sample_rate(mp, mi);
+	spin_unlock_bh(&mi->lock);
 	if (!sample_idx)
 		return;
 
+set_rate:
 	sample_group = &minstrel_mcs_groups[MI_RATE_GROUP(sample_idx)];
 	sample_idx = MI_RATE_IDX(sample_idx);
 
@@ -1597,7 +1662,7 @@ minstrel_ht_get_rate(void *priv, struct
 		return;
 
 	info->flags |= IEEE80211_TX_CTL_RATE_CTRL_PROBE;
-	rate->count = 1;
+	rate->count = min_t(u8, sample_count, mp->max_retry);
 
 	if (sample_group == &minstrel_mcs_groups[MINSTREL_CCK_GROUP]) {
 		int idx = sample_idx % ARRAY_SIZE(mp->cck_rates);
@@ -1687,7 +1752,7 @@ minstrel_ht_update_caps(void *priv, stru
 	else
 		use_vht = 0;
 
-	memset(mi, 0, sizeof(*mi));
+	spin_lock_bh(&mi->lock);
 
 	mi->sta = sta;
 	mi->band = sband->band;
@@ -1795,7 +1860,11 @@ minstrel_ht_update_caps(void *priv, stru
 
 	/* create an initial rate table with the lowest supported rates */
 	minstrel_ht_update_stats(mp, mi);
-	minstrel_ht_update_rates(mp, mi);
+	minstrel_ht_update_rates(mp, mi, true);
+
+	orca_sta_update(mp, mi);
+
+	spin_unlock_bh(&mi->lock);
 }
 
 static void
@@ -1831,12 +1900,24 @@ minstrel_ht_alloc_sta(void *priv, struct
 			max_rates = sband->n_bitrates;
 	}
 
-	return kzalloc(sizeof(*mi), gfp);
+	mi = kzalloc(sizeof(*mi), gfp);
+	spin_lock_init(&mi->lock);
+
+#ifdef CPTCFG_MAC80211_ORCA_UAPI
+	INIT_LIST_HEAD(&mi->list);
+	mi->ratetbl = kzalloc(sizeof(*mi->ratetbl), gfp);
+	mi->user_sample_rate = -1;
+	mi->user_sample_count = 0;
+	mi->user_sample_txpower = -1;
+#endif
+
+	return mi;
 }
 
 static void
 minstrel_ht_free_sta(void *priv, struct ieee80211_sta *sta, void *priv_sta)
 {
+	orca_sta_remove(priv, priv_sta);
 	kfree(priv_sta);
 }
 
@@ -1927,6 +2008,9 @@ minstrel_ht_alloc(struct ieee80211_hw *h
 
 	mp->hw = hw;
 	mp->update_interval = HZ / 20;
+#ifdef CPTCFG_MAC80211_DEBUGFS
+	mp->sampling_interval = MINSTREL_SAMPLE_INTERVAL;
+#endif
 
 	minstrel_ht_init_cck_rates(mp);
 	for (i = 0; i < ARRAY_SIZE(mp->hw->wiphy->bands); i++)
@@ -1936,6 +2020,41 @@ minstrel_ht_alloc(struct ieee80211_hw *h
 }
 
 #ifdef CPTCFG_MAC80211_DEBUGFS
+
+static int minstrel_ht_debugfs_hz_get(void *data, u64 *val)
+{
+	unsigned int tmp = *(unsigned int *)data;
+	if (tmp)
+		*val = HZ / *(unsigned int *)data;
+	else
+		*val = 0;
+	return 0;
+}
+
+static int minstrel_ht_debugfs_hz_set(void *data, u64 val)
+{
+	if (!val || val > HZ)
+		return -EINVAL;
+
+	*(unsigned int *)data = val ? (HZ / (u32)val) : val;
+	return 0;
+}
+
+static int minstrel_ht_debugfs_hz_open(struct inode *inode, struct file *file)
+{
+	return simple_attr_open(inode, file, minstrel_ht_debugfs_hz_get,
+				minstrel_ht_debugfs_hz_set, "%llu\n");
+}
+
+static const struct file_operations minstrel_ht_debugfs_hz_fops = {
+	.owner = THIS_MODULE,
+	.open = minstrel_ht_debugfs_hz_open,
+	.release = simple_attr_release,
+	.read = debugfs_attr_read,
+	.write = debugfs_attr_write,
+	.llseek = no_llseek,
+};
+
 static void minstrel_ht_add_debugfs(struct ieee80211_hw *hw, void *priv,
 				    struct dentry *debugfsdir)
 {
@@ -1944,12 +2063,22 @@ static void minstrel_ht_add_debugfs(stru
 	mp->fixed_rate_idx = (u32) -1;
 	debugfs_create_u32("fixed_rate_idx", S_IRUGO | S_IWUGO, debugfsdir,
 			   &mp->fixed_rate_idx);
+
+	debugfs_create_file_unsafe("update_freq", 0666, debugfsdir,
+	                  	   &mp->update_interval,
+				   &minstrel_ht_debugfs_hz_fops);
+	debugfs_create_file_unsafe("sampling_freq", 0666, debugfsdir,
+				   &mp->sampling_interval,
+				   &minstrel_ht_debugfs_hz_fops);
+
+	orca_add_debugfs_api(hw, priv, debugfsdir);
 }
 #endif
 
 static void
 minstrel_ht_free(void *priv)
 {
+	orca_remove_debugfs_api(priv);
 	kfree(priv);
 }
 
--- a/net/mac80211/rc80211_minstrel_ht.h
+++ b/net/mac80211/rc80211_minstrel_ht.h
@@ -72,6 +72,11 @@
 #define MINSTREL_SAMPLE_RATES		5 /* rates per sample type */
 #define MINSTREL_SAMPLE_INTERVAL	(HZ / 50)
 
+#define ORCA_MONITOR_TXS		BIT(0)
+#define ORCA_MONITOR_RXS		BIT(1)
+#define ORCA_MONITOR_STATS		BIT(2)
+#define ORCA_ECHO_TPRC			BIT(7)
+
 struct minstrel_priv {
 	struct ieee80211_hw *hw;
 	unsigned int cw_min;
@@ -91,6 +96,16 @@ struct minstrel_priv {
 	 *   - setting will be applied on next update
 	 */
 	u32 fixed_rate_idx;
+	unsigned int sampling_interval;
+#endif
+#ifdef CPTCFG_MAC80211_ORCA_UAPI
+	struct rchan *relay_ev;
+	spinlock_t relay_lock;
+
+	struct list_head stations;
+	spinlock_t sta_wlock;
+
+	u8 monitor;
 #endif
 };
 
@@ -152,7 +167,18 @@ struct minstrel_sample_category {
 };
 
 struct minstrel_ht_sta {
+#ifdef CPTCFG_MAC80211_ORCA_UAPI
+	struct list_head list;
+	u32 user_sample_rate;
+	s16 user_sample_txpower;
+	u8 user_sample_count;
+	struct ieee80211_sta_rates *ratetbl;
+
+	bool rc_manual;
+	bool tpc_manual;
+#endif
 	struct ieee80211_sta *sta;
+	spinlock_t lock;
 
 	/* ampdu length (average, per sampling interval) */
 	unsigned int ampdu_len;
@@ -196,7 +222,134 @@ struct minstrel_ht_sta {
 };
 
 void minstrel_ht_add_sta_debugfs(void *priv, void *priv_sta, struct dentry *dir);
+
+#ifdef CPTCFG_MAC80211_ORCA_UAPI
+void orca_sta_update(struct minstrel_priv *mp, struct minstrel_ht_sta *mi);
+void orca_sta_remove(struct minstrel_priv *mp, struct minstrel_ht_sta *mi);
+void __orca_report_tx_status(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,
+			     struct ieee80211_tx_info *info,
+			     u16 *rate_list, s16* txpwr_list, int n_rates);
+void __orca_report_rx_status(struct minstrel_priv *mp, u8 *addr,
+			     s8 last_signal, u8 chain_status,
+			     s8 *chain_signal);
+void __orca_report_rate_update(struct minstrel_priv *mp,
+			       struct minstrel_ht_sta *mi, u16 rate,
+			       struct minstrel_rate_stats *mrs);
+void __orca_report_best_rates(struct minstrel_priv *mp,
+			      struct minstrel_ht_sta *mi);
+void __orca_report_sample_rates(struct minstrel_priv *mp,
+				struct minstrel_ht_sta *mi);
+void orca_add_debugfs_api(struct ieee80211_hw *hw, void *priv,
+				 struct dentry *dir);
+void orca_remove_debugfs_api(void *priv);
+#else
+static inline void
+orca_sta_update(struct minstrel_priv *mp, struct minstrel_ht_sta *mi)
+{
+}
+static inline void
+orca_sta_remove(struct minstrel_priv *mp, struct minstrel_ht_sta *mi)
+{
+}
+static inline void
+orca_add_debugfs_api(struct ieee80211_hw *hw, void *priv,
+			    struct dentry *dir)
+{
+}
+static inline void
+orca_remove_debugfs_api(void *priv)
+{
+}
+#endif
+
+static inline void
+orca_report_tx_status(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,
+		      struct ieee80211_tx_info *info,
+		      u16 *rate_list, s16 *txpwr_list, int n_rates)
+{
+#ifdef CPTCFG_MAC80211_ORCA_UAPI
+	if (!(mp->monitor & ORCA_MONITOR_TXS))
+		return;
+
+	__orca_report_tx_status(mp, mi, info, rate_list, txpwr_list,
+				       n_rates);
+#endif
+}
+
+static inline void
+orca_report_rx_status(struct minstrel_priv *mp, u8 *addr, s8 last_signal,
+		      u8 chain_status, s8 *chain_signal)
+{
+#ifdef CPTCFG_MAC80211_ORCA_UAPI
+	if (!(mp->monitor & ORCA_MONITOR_RXS))
+		return;
+
+	__orca_report_rx_status(mp, addr, last_signal, chain_status, chain_signal);
+#endif
+}
+
+static inline void
+orca_report_rate_update(struct minstrel_priv *mp,
+			struct minstrel_ht_sta *mi, u16 rate,
+			struct minstrel_rate_stats *mrs)
+{
+#ifdef CPTCFG_MAC80211_ORCA_UAPI
+	if (!(mp->monitor & ORCA_MONITOR_STATS))
+		return;
+
+	__orca_report_rate_update(mp, mi, rate, mrs);
+#endif
+}
+
+static inline void
+orca_report_best_rates(struct minstrel_priv *mp, struct minstrel_ht_sta *mi)
+{
+#ifdef CPTCFG_MAC80211_ORCA_UAPI
+	if (!(mp->monitor & ORCA_MONITOR_STATS))
+		return;
+
+	__orca_report_best_rates(mp, mi);
+#endif
+}
+
+static inline void
+orca_report_sample_rates(struct minstrel_priv *mp, struct minstrel_ht_sta *mi)
+{
+#ifdef CPTCFG_MAC80211_ORCA_UAPI
+	if (!(mp->monitor & ORCA_MONITOR_STATS))
+		return;
+
+	__orca_report_sample_rates(mp, mi);
+#endif
+}
+
+static inline bool
+orca_sta_rc_manual_mode(struct minstrel_ht_sta *mi)
+{
+#ifdef CPTCFG_MAC80211_ORCA_UAPI
+	return mi->rc_manual;
+#else
+	return false;
+#endif
+}
+
+static inline bool
+orca_sta_tpc_manual_mode(struct minstrel_ht_sta *mi)
+{
+#ifdef CPTCFG_MAC80211_ORCA_UAPI
+	return mi->tpc_manual;
+#else
+	return false;
+#endif
+}
+
+void minstrel_ht_set_rate(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,
+						  struct ieee80211_sta_rates *ratetbl, int offset,
+						  int index);
 int minstrel_ht_get_tp_avg(struct minstrel_ht_sta *mi, int group, int rate,
 			   int prob_avg);
+void minstrel_ht_update_rates(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,
+			      bool force);
+void minstrel_ht_update_stats(struct minstrel_priv *mp, struct minstrel_ht_sta *mi);
 
 #endif
--- /dev/null
+++ b/net/mac80211/orca_uapi.c
@@ -0,0 +1,1218 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * ORCA - Open-Source Resource Control API
+ *
+ * Copyright (C) 2021 Felix Fietkau <nbd@nbd.name>
+ * Copyright (C) 2021-2023 SupraCoNeX <supraconex@gmail.com>
+ */
+#include <linux/kernel.h>
+#include <linux/debugfs.h>
+#include <linux/relay.h>
+#include <net/mac80211.h>
+#include "ieee80211_i.h"
+#include "rate.h"
+#include "rc80211_minstrel_ht.h"
+
+/* IMPORTANT: always change patch version when you make any change here! */
+#define ORCA_MAJOR_VERSION 2
+#define ORCA_PATCH_VERSION 5
+
+extern u8 sample_table[SAMPLE_COLUMNS][MCS_GROUP_RATES];
+
+/* IMPORTANT: make sure that the order matches the order of
+ * enum ieee80211_feature_ctrl in mac80211.h ! */
+static char *feature_pretty[] = { "adaptive_sens", "tpc" };
+
+enum api_cmd {
+	PHY_CMD_START,
+	PHY_CMD_STOP,
+	PHY_CMD_DUMP,
+	PHY_CMD_SET_FEATURE,
+
+	/* per-STA commands */
+	STA_CMD_RC_MODE,
+	STA_CMD_TPC_MODE,
+	STA_CMD_RESET_STATS,
+	STA_CMD_PROBE,
+	STA_CMD_TPRC,
+	STA_CMD_TPC,
+	STA_CMD_RC,
+};
+
+static void
+orca_print_rate_durations(struct seq_file *s, int group)
+{
+	const struct mcs_group *g = &minstrel_mcs_groups[group];
+	int n_rates;
+	int i;
+
+	if (g->flags & IEEE80211_TX_RC_VHT_MCS)
+		n_rates = 10;
+	else
+		n_rates = 8;
+
+	seq_printf(s, "%x", g->duration[0] << g->shift);
+	for (i = 1; i < n_rates; i++)
+		seq_printf(s, ";%x", g->duration[i] << g->shift);
+
+	for (; i < MCS_GROUP_RATES; i++)
+		seq_printf(s, ";");
+}
+
+static int
+orca_read_api_info(struct seq_file *s, void *data)
+{
+	int i, j;
+	seq_printf(s, "orca_version;%x;%x\n", ORCA_MAJOR_VERSION, ORCA_PATCH_VERSION);
+
+	seq_printf(s, "#group;index;offset;type;nss;bw;gi");
+	for (i = 0; i < MCS_GROUP_RATES; i++)
+	        seq_printf(s, ";airtime%d", i);
+        seq_printf(s, "\n");
+
+	seq_printf(s, "#sta;action;macaddr;iface;rc_mode;tpc_mode;overhead_mcs;overhead_legacy");
+	for (i = 0; i < MINSTREL_GROUPS_NB; i++)
+	        seq_printf(s, ";mcs%d", i);
+	seq_printf(s, "\n");
+
+	seq_printf(s, "#txs;macaddr;num_frames;num_acked;probe");
+	for (i = 0; i < IEEE80211_TX_MAX_RATES; i++)
+		seq_printf(s, ";rate%d,count%d,txpwr%d", i, i, i);
+	seq_printf(s, "\n");
+
+	seq_printf(s, "#rxs;macaddr;last_signal");
+	for (i = 0; i < IEEE80211_MAX_CHAINS; i++)
+		seq_printf(s, ";signal%d", i);
+	seq_printf(s, "\n");
+
+	seq_printf(s, "#stats;macaddr;rate;avg_prob;avg_tp;cur_success;"
+		      "cur_attempts;hist_success;hist_attempts\n");
+	seq_printf(s, "#best_rates;macaddr");
+	for (i = 0; i < MAX_THR_RATES; i++)
+		seq_printf(s, ";maxtp%d", i);
+	seq_printf(s, ";maxprob\n");
+
+	seq_printf(s, "#sample_rates;macaddr");
+	for (i = 0; i < MINSTREL_SAMPLE_RATES; i++)
+	        seq_printf(s, ";inc%d", i);
+	for (i = 0; i < MINSTREL_SAMPLE_RATES; i++)
+	        seq_printf(s, ";jump%d", i);
+	for (i = 0; i < MINSTREL_SAMPLE_RATES; i++)
+	        seq_printf(s, ";slow%d", i);
+	seq_printf(s, "\n");
+
+	seq_printf(s, "#sample_table;cols;rows");
+	for (i = 0; i < SAMPLE_COLUMNS; i++)
+		seq_printf(s, ";column%d", i);
+	seq_printf(s, "\n");
+
+	seq_printf(s, "#start;txs;rxs;stats;sta;tprc_echo\n");
+	seq_printf(s, "#stop;txs;rxs;stats;sta;tprc_echo\n");
+
+	seq_printf(s, "#set_rates;macaddr");
+	for (i = 0; i < IEEE80211_TX_MAX_RATES; i++)
+		seq_printf(s, ";rate%d,count%d", i, i);
+	seq_printf(s, "\n");
+
+	seq_printf(s, "#set_power;macaddr");
+	for (i = 0; i < IEEE80211_TX_MAX_RATES; i++)
+		seq_printf(s, ";txpwr%d", i);
+	seq_printf(s, "\n");
+
+	seq_printf(s, "#set_rates_power;macaddr");
+	for (i = 0; i < IEEE80211_TX_MAX_RATES; i++)
+		seq_printf(s, ";rate%d,count%d,txpwr%d", i, i, i);
+	seq_printf(s, "\n");
+
+	seq_printf(s, "#set_probe;macaddr;rate,count,txpwr\n");
+
+	/*
+	 * Commands targeting 'all' instead of a mac address are executed for
+	 * all currently connected STAs. However, this has no effect on any
+	 * future STAs. For 'rc_mode' and 'tpc_mode', an STA is by default in
+	 * 'auto' mode after connecting.
+	 */
+	seq_printf(s, "#rc_mode;macaddr;mode\n");
+	seq_printf(s, "#rc_mode;all;mode\n");
+	seq_printf(s, "#tpc_mode;macaddr;mode\n");
+	seq_printf(s, "#tpc_mode;all;mode\n");
+
+	seq_printf(s, "#reset_stats;macaddr\n");
+	seq_printf(s, "#reset_stats;all\n");
+
+	seq_printf(s, "#set_feature;feature;on-or-off\n");
+
+	for (i = 0; i < MINSTREL_GROUPS_NB; i++) {
+		const struct mcs_group *g = &minstrel_mcs_groups[i];
+		const char *type;
+
+		if (i == MINSTREL_CCK_GROUP)
+			type = "cck";
+		else if (i == MINSTREL_OFDM_GROUP)
+			type = "ofdm";
+		else if (g->flags & IEEE80211_TX_RC_VHT_MCS)
+			type = "vht";
+		else
+			type = "ht";
+
+		seq_printf(s, "group;%x;%x;%s;%x;%x;%x;",
+			   i, (u32) MI_RATE(i, 0), type, g->streams, g->bw,
+			   !!(g->flags & IEEE80211_TX_RC_SHORT_GI));
+		orca_print_rate_durations(s, i);
+		seq_printf(s, "\n");
+	}
+	seq_printf(s, "sample_table;%x;%x", SAMPLE_COLUMNS, MCS_GROUP_RATES);
+	for (i = 0; i < SAMPLE_COLUMNS; i++) {
+		seq_printf(s, ";");
+		for (j = 0; j < MCS_GROUP_RATES; j++) {
+			if (j == 0)
+				seq_printf(s, "%x", sample_table[i][j]);
+			else
+				seq_printf(s, ",%x", sample_table[i][j]);
+		}
+	}
+	seq_printf(s, "\n");
+
+	return 0;
+}
+
+static int
+orca_read_phy_info(struct seq_file *s, void *data)
+{
+	struct wiphy *wiphy = container_of(s->private, struct wiphy, dev);
+	struct ieee80211_local *local = wiphy_priv(wiphy);
+	struct ieee80211_sub_if_data *sdata;
+	struct sta_info *sta_info;
+	struct minstrel_priv *mp = local->rate_ctrl->priv;
+	struct minstrel_ht_sta *mi;
+	char tmp[64] = {};
+	int len, ofs = 0;
+	int power_limit, i = 0;
+
+	seq_printf(s, "drv;%s\n", wiphy_dev(wiphy)->driver->name);
+
+	mutex_lock(&local->iflist_mtx);
+	sdata = list_first_entry_or_null(&local->interfaces,
+					 struct ieee80211_sub_if_data, list);
+	if (sdata) {
+		seq_printf(s, "if;%s", sdata->name);
+		list_for_each_entry_continue(sdata, &local->interfaces, list)
+			seq_printf(s, ",%s", sdata->name);
+
+		seq_printf(s, "\n");
+	}
+	mutex_unlock(&local->iflist_mtx);
+
+	if (ieee80211_hw_check(&local->hw, SUPPORTS_TPC_PER_PACKET)) {
+		seq_printf(s, "tpc;pkt");
+	} else if (ieee80211_hw_check(&local->hw, SUPPORTS_TPC_PER_MRR)) {
+		seq_printf(s, "tpc;mrr");
+	} else {
+		seq_printf(s, "tpc;not\n");
+		goto skip_tpc;
+	}
+
+	seq_printf(s, ";%u", local->hw.n_txpower_ranges);
+	for (i = 0; i < local->hw.n_txpower_ranges; i++) {
+		struct ieee80211_hw_txpower_range *rng = &local->hw.txpower_ranges[i];
+		seq_printf(s, ";%x,%x,%x,%x", rng->start_idx, rng->n_levels,
+			   (u8)rng->start_pwr, (u8)rng->pwr_step);
+	}
+	seq_printf(s, "\n");
+
+skip_tpc:
+	if (local->ops->get_txpower) {
+		if (!local->ops->get_txpower(&local->hw, NULL, &power_limit))
+			/* double it, it's better for ath9k and driver using
+			 * get_txpower use 0.5 dBm steps anyway */
+			seq_printf(s, "pwr_limit;%x\n", power_limit * 2);
+	}
+
+	/* Current monitor modes states */
+	if (mp->monitor & ORCA_MONITOR_TXS)
+		ofs += sprintf(tmp, "txs,");
+	if (mp->monitor & ORCA_MONITOR_RXS)
+		ofs += sprintf(tmp + ofs, "rxs,");
+	if (mp->monitor & ORCA_MONITOR_STATS)
+		ofs += sprintf(tmp + ofs, "stats,");
+	if (mp->monitor & ORCA_ECHO_TPRC)
+		ofs += sprintf(tmp + ofs, "tprc_echo,");
+
+	len = strlen(tmp);
+	if (len)
+		tmp[len - 1] = 0;
+
+	seq_printf(s, "mon;%s\n", tmp);
+
+	/* Controllable feature information */
+	if (!local->ops->get_feature_state || mp->hw->feature_ctrl == 0)
+		goto skip_ftrs;
+
+	seq_printf(s, "ftrs;%u", hweight_long(mp->hw->feature_ctrl));
+	for (i = 0; i < NUM_IEEE80211_FTRCTRL; i++) {
+		u32 state;
+
+		if (!ieee80211_feature_ctrl_has(mp->hw, i))
+			continue;
+
+		state = local->ops->get_feature_state(mp->hw, i);
+		seq_printf(s, ";%s,%u", feature_pretty[i], state);
+	}
+	seq_printf(s, "\n");
+
+skip_ftrs:
+	/* keep this block last! */
+	rcu_read_lock();
+	list_for_each_entry_rcu(mi, &mp->stations, list) {
+		sta_info = container_of(mi->sta, struct sta_info, sta);
+		seq_printf(s, "sta;%pM;%s;%s;%s;%x;%x;",
+			   mi->sta->addr, sta_info->sdata->name,
+			   mi->rc_manual ? "manual" : "auto",
+			   mi->tpc_manual ? "manual" : "auto",
+			   mi->overhead, mi->overhead_legacy);
+
+		seq_printf(s, "%x", mi->supported[0]);
+		for (i = 1; i < MINSTREL_GROUPS_NB; i++)
+			seq_printf(s, ";%x", mi->supported[i]);
+
+		seq_printf(s, "\n");
+	}
+	rcu_read_unlock();
+
+	return 0;
+}
+
+static struct dentry *
+create_buf_file_cb(const char *filename, struct dentry *parent, umode_t mode,
+		   struct rchan_buf *buf, int *is_global)
+{
+	struct dentry *f;
+
+	f = debugfs_create_file("api_event", mode, parent, buf,
+				&relay_file_operations);
+	if (IS_ERR(f))
+		return NULL;
+
+	*is_global = 1;
+
+	return f;
+}
+
+static int
+remove_buf_file_cb(struct dentry *f)
+{
+	debugfs_remove(f);
+
+	return 0;
+}
+
+static struct rchan_callbacks relay_ev_cb = {
+	.create_buf_file = create_buf_file_cb,
+	.remove_buf_file = remove_buf_file_cb,
+};
+
+static void
+orca_dump_sta(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,
+	      const char *type)
+{
+	struct sta_info *sta_info;
+	char info[128 + MINSTREL_GROUPS_NB * 4];
+	int ofs = 0;
+	int i;
+
+	sta_info = container_of(mi->sta, struct sta_info, sta);
+	ofs += scnprintf(info + ofs, sizeof(info) - ofs,
+			 "%llx;sta;%s;%pM;%s;%s;%s;%x;%x;",
+			 (unsigned long long)ktime_get_real_fast_ns(), type,
+			 mi->sta->addr, sta_info->sdata->name,
+			 mi->rc_manual ? "manual" : "auto",
+			 mi->tpc_manual ? "manual" : "auto",
+			 mi->overhead, mi->overhead_legacy);
+
+	ofs += scnprintf(info + ofs, sizeof(info) - ofs, "%x",
+			 mi->supported[0]);
+	for (i = 1; i < MINSTREL_GROUPS_NB; i++)
+		ofs += scnprintf(info + ofs, sizeof(info) - ofs, ";%x",
+				 mi->supported[i]);
+
+	ofs += scnprintf(info + ofs, sizeof(info) - ofs, "\n");
+
+	relay_write(mp->relay_ev, info, ofs);
+	relay_flush(mp->relay_ev);
+}
+
+void __orca_report_sample_rates(struct minstrel_priv *mp,
+				struct minstrel_ht_sta *mi)
+{
+	char line[128];
+	int i, j, ofs;
+
+	ofs = scnprintf(line, sizeof(line), "%llx;sample_rates;%pM",
+			(unsigned long long)ktime_get_real_fast_ns(),
+			mi->sta->addr);
+
+	for (i = 0; i < __MINSTREL_SAMPLE_TYPE_MAX; i++)
+		for (j = 0; j < MINSTREL_SAMPLE_RATES; j++)
+			ofs += scnprintf(line + ofs, sizeof(line), ";%x",
+					 mi->sample[i].cur_sample_rates[j]);
+
+	ofs += scnprintf(line + ofs, sizeof(line), "\n");
+
+	spin_lock_bh(&mp->relay_lock);
+
+	relay_write(mp->relay_ev, line, ofs);
+	relay_flush(mp->relay_ev);
+
+	spin_unlock_bh(&mp->relay_lock);
+}
+
+static void
+orca_dump_stations(struct minstrel_priv *mp, const char *type)
+{
+	struct minstrel_ht_sta *mi;
+
+	rcu_read_lock();
+	spin_lock_bh(&mp->relay_lock);
+
+	list_for_each_entry_rcu(mi, &mp->stations, list)
+		orca_dump_sta(mp, mi, type);
+
+	spin_unlock_bh(&mp->relay_lock);
+	rcu_read_unlock();
+}
+
+static void
+orca_start_monitoring(struct minstrel_priv *mp, char *params)
+{
+	char *cur;
+	u8 mask = mp->monitor;
+
+	while ((cur = strsep(&params, ";")) != NULL) {
+		if (!strlen(cur))
+			break;
+
+		if (!strcmp(cur, "txs"))
+			mask |= ORCA_MONITOR_TXS;
+		else if (!strcmp(cur, "rxs"))
+			mask |= ORCA_MONITOR_RXS;
+		else if (!strcmp(cur, "stats"))
+			mask |= ORCA_MONITOR_STATS;
+		else if (!strcmp(cur, "tprc_echo"))
+			mask |= ORCA_ECHO_TPRC;
+	}
+
+	if (!mask)
+		mask = ORCA_MONITOR_TXS;
+
+	if (!mp->monitor)
+		orca_dump_stations(mp, "add");
+	mp->monitor = mask;
+}
+
+static void
+orca_stop_monitoring(struct minstrel_priv *mp, char *params)
+{
+	u8 mask = 0;
+	char *cur;
+
+	if (!params || !strncmp(params, "all", 3))
+		goto set_mask;
+
+	mask = mp->monitor;
+	while ((cur = strsep(&params, ";")) != NULL) {
+		if (!strlen(cur))
+			break;
+
+		if (!strcmp(cur, "txs"))
+			mask &= ~ORCA_MONITOR_TXS;
+		else if (!strcmp(cur, "rxs"))
+			mask &= ~ORCA_MONITOR_RXS;
+		else if (!strcmp(cur, "stats"))
+			mask &= ~ORCA_MONITOR_STATS;
+		else if (!strcmp(cur, "tprc_echo"))
+			mask &= ~ORCA_ECHO_TPRC;
+	}
+
+set_mask:
+	spin_lock_bh(&mp->relay_lock);
+	mp->monitor = mask;
+	relay_reset(mp->relay_ev);
+	spin_unlock_bh(&mp->relay_lock);
+}
+
+static void
+orca_reset_sample_table(struct minstrel_ht_sta *mi)
+{
+	int i;
+
+	for (i = 0; i < __MINSTREL_SAMPLE_TYPE_MAX; i++)
+		memset(mi->sample[i].sample_rates, 0,
+		       sizeof(mi->sample[i].sample_rates));
+
+	mi->sample_seq = 0;
+	mi->user_sample_rate = -1;
+	mi->user_sample_count = 0;
+	mi->user_sample_txpower = -1;
+}
+
+/**
+ * orca_is_phy_tpc_ready - check if TPC can be used for a PHY
+ *
+ * TPC is ready if hardware/driver supports it and it is enabled in
+ * the driver.
+ */
+static inline bool
+orca_is_phy_tpc_ready(struct ieee80211_hw *hw)
+{
+	struct ieee80211_local *local = hw_to_local(hw);
+
+	return (ieee80211_hw_check(hw, SUPPORTS_TPC_PER_PACKET) ||
+		ieee80211_hw_check(hw, SUPPORTS_TPC_PER_MRR)) &&
+		/*
+		 * this returns 1 for active, 0 for inactive and -1 for unsupported.
+		 * because hw_flag is set, assume it is always active in driver.
+		 */
+	       local->ops->get_feature_state(hw, IEEE80211_FTRCTRL_TPC);
+}
+
+static int
+orca_phy_set_feature(struct minstrel_priv *mp, char *args)
+{
+	struct ieee80211_local *local = hw_to_local(mp->hw);
+	enum ieee80211_feature_ctrl feature = -1;
+	char *feature_str, *arg;
+	u32 state;
+	int i, res;
+	bool allow_str = true;
+
+	/* We need at least the feature name and one argument */
+	feature_str = strsep(&args, ";");
+	arg = strsep(&args, ";");
+	if (!feature_str || !arg)
+		return -EINVAL;
+
+	if (!local->ops->set_feature_state)
+		return -EPERM;
+
+	/* This only works if feature_pretty and enum ieee80211_feature_ctrl
+	 * (in mac80211.h) are equally ordered! */
+	for (i = 0; i < ARRAY_SIZE(feature_pretty); i++) {
+		if (!strcmp(feature_str, feature_pretty[i])) {
+			feature = i;
+			break;
+		}
+	}
+
+	if (feature == -1)
+		return -ENOENT;
+
+	if (allow_str && !strcmp(arg, "on")) {
+		state = 1;
+	} else if (allow_str && !strcmp(arg, "off")) {
+		state = 0;
+	} else {
+		if (kstrtou32(arg, 16, &state) || state == U32_MAX)
+			return -EINVAL;
+	}
+
+	/* Check if the hardware/driver supports the given feature ctrl */
+	if (!ieee80211_feature_ctrl_has(mp->hw, feature))
+		return -EPERM;
+
+	res = local->ops->set_feature_state(mp->hw, feature, state);
+	if (res)
+		return -EIO; /* TODO: more suitable error? */
+
+	return 0;
+}
+
+static int
+orca_sta_set_rc_mode(struct minstrel_ht_sta *mi, char *mode)
+{
+	int i;
+
+	if (!mode)
+		return -EINVAL;
+	if (!mi->ratetbl)
+		return -EFAULT;
+
+	if (!strcmp(mode, "manual"))
+		mi->rc_manual = true;
+	else if (!strcmp(mode, "auto"))
+		mi->rc_manual = false;
+	else
+		return -EINVAL;
+
+	orca_reset_sample_table(mi);
+	for (i = 0; i < ARRAY_SIZE(mi->ratetbl->rate); i++) {
+		mi->ratetbl->rate[i].idx = -1;
+		mi->ratetbl->rate[i].count = 0;
+		mi->ratetbl->rate[i].count_rts = 0;
+		mi->ratetbl->rate[i].count_cts = 0;
+	}
+
+	return 0;
+}
+
+static int
+orca_sta_set_tpc_mode(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,
+		      char *mode)
+{
+	int i;
+
+	if (!orca_is_phy_tpc_ready(mp->hw))
+		return -EPERM;
+
+	if (!mode)
+		return -EINVAL;
+	if (!mi->ratetbl)
+		return -EFAULT;
+
+	if (!strcmp(mode, "manual"))
+		mi->tpc_manual = true;
+	else if (!strcmp(mode, "auto"))
+		mi->tpc_manual = false;
+	else
+		return -EINVAL;
+
+	for (i = 0; i < ARRAY_SIZE(mi->ratetbl->rate); i++)
+		mi->ratetbl->rate[i].txpower_idx = -1;
+
+	return 0;
+}
+
+static struct minstrel_ht_sta *
+orca_get_sta(struct minstrel_priv *mp, const u8 *macaddr)
+{
+	struct minstrel_ht_sta *mi;
+
+	rcu_read_lock();
+	list_for_each_entry_rcu(mi, &mp->stations, list) {
+		if (!memcmp(mi->sta->addr, macaddr, ETH_ALEN))
+			goto out;
+	}
+	mi = NULL;
+
+out:
+	rcu_read_unlock();
+	return mi;
+}
+
+static int
+orca_get_args(char **dest, int dest_size, char *str, char *sep)
+{
+	int i, n;
+
+	for (i = 0, n = 0; i < dest_size; i++) {
+		if (!str) {
+			dest[i] = NULL;
+			continue;
+		}
+
+		dest[i] = strsep(&str, sep);
+		if (dest[i])
+			n++;
+	}
+
+	return n;
+}
+
+static bool
+orca_is_valid_rate(struct minstrel_ht_sta *mi, u32 rate)
+{
+	int group, idx;
+
+	group = MI_RATE_GROUP(rate);
+	if (group >= MINSTREL_GROUPS_NB)
+		return false;
+
+	idx = MI_RATE_IDX(rate);
+
+	return !!(mi->supported[group] & BIT(idx));
+}
+
+static int
+orca_rate_from_str(struct minstrel_ht_sta *mi, const char *str)
+{
+	unsigned int rate;
+
+	if (kstrtouint(str, 16, &rate))
+		return -EINVAL;
+
+	if (!orca_is_valid_rate(mi, rate))
+		return -EINVAL;
+
+	return rate;
+}
+
+static int
+orca_set_probe(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,
+	       char *arg_str)
+{
+	char *rate_str, *count_str, *txpwr_str;
+	unsigned int count;
+	int rate;
+	u16 raw_txpwr;
+	s16 max_power, txpwr = -1;
+
+	if (!arg_str)
+		return -EINVAL;
+	if (!mi->rc_manual)
+		return -EPERM;
+
+	txpwr_str = arg_str;
+	rate_str = strsep(&txpwr_str, ",");
+	count_str = strsep(&txpwr_str, ",");
+
+	rate = orca_rate_from_str(mi, rate_str);
+	if (rate < 0)
+		return rate;
+
+	if (!count_str || kstrtouint(count_str, 16, &count))
+		return -EINVAL;
+
+	if (txpwr_str) {
+		if (!mi->tpc_manual)
+			return -EPERM;
+
+		max_power = ieee80211_hw_get_max_txpower_idx(mp->hw);
+		if (kstrtou16(txpwr_str, 16, &raw_txpwr))
+			return -EINVAL;
+
+		txpwr = (raw_txpwr <= S16_MAX) ? (s16)raw_txpwr : -1;
+		if (txpwr > max_power)
+			return -ERANGE;
+	}
+
+	mi->user_sample_rate = rate;
+	mi->user_sample_count = count;
+	mi->user_sample_txpower = txpwr;
+	return 0;
+}
+
+static int
+orca_ratetbl_set_rate_count(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,
+			    char **rate_count_str, unsigned int stage)
+{
+	char *rate_str, *count_str;
+	unsigned int count;
+	int rate;
+
+	rate_str = strsep(rate_count_str, ",");
+	count_str = strsep(rate_count_str, ",");
+
+	if (!rate_str || !count_str)
+		return -EINVAL;
+
+	rate = orca_rate_from_str(mi, rate_str);
+	if (rate < 0)
+		return -EINVAL;
+
+	if (kstrtouint(count_str, 16, &count))
+		return -EINVAL;
+
+	minstrel_ht_set_rate(mp, mi, mi->ratetbl, stage, rate);
+	mi->ratetbl->rate[stage].count = count;
+	mi->ratetbl->rate[stage].count_rts = count;
+	mi->ratetbl->rate[stage].count_cts = count;
+
+	return 0;
+}
+
+static int
+orca_ratetbl_set_txpower(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,
+			 char *txpwr_str, int stage, s16 max_power)
+{
+	u16 raw;
+	s16 txpwr;
+
+	if (!txpwr_str || kstrtou16(txpwr_str, 16, &raw))
+		return -EINVAL;
+
+	txpwr = (raw <= S16_MAX) ? (s16)raw : -1;
+	if (txpwr > max_power)
+		return -ERANGE;
+
+	mi->ratetbl->rate[stage].txpower_idx = txpwr;
+	return 0;
+}
+
+static int
+orca_set_ratetbl(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,
+		 enum api_cmd cmd, char **args_str, unsigned int n_args)
+{
+	struct ieee80211_sta_rates *ratetbl;
+	int i, err = 0;
+	s16 max_tx_power;
+	bool rc, tpc;
+
+	if (!args_str || !n_args)
+		return -EINVAL;
+
+	rc = (cmd == STA_CMD_RC || cmd == STA_CMD_TPRC);
+	tpc = (cmd == STA_CMD_TPC || cmd == STA_CMD_TPRC);
+
+	if ((rc && !orca_sta_rc_manual_mode(mi)) ||
+	    (tpc && (!orca_is_phy_tpc_ready(mp->hw) || !orca_sta_tpc_manual_mode(mi))))
+		return -EPERM;
+
+	if (tpc)
+		max_tx_power = ieee80211_hw_get_max_txpower_idx(mp->hw);
+
+	for (i = 0; i < min_t(unsigned int, n_args, ARRAY_SIZE(ratetbl->rate)); i++) {
+		if (rc) {
+			err = orca_ratetbl_set_rate_count(mp, mi, &args_str[i], i);
+			if (err)
+				return err;
+		}
+
+		if (tpc) {
+			err = orca_ratetbl_set_txpower(mp, mi, args_str[i], i,
+						       max_tx_power);
+			if (err)
+				return err;
+		}
+	}
+	if (!i)
+		return -EINVAL;
+
+	for (; i < ARRAY_SIZE(ratetbl->rate); i++) {
+		mi->ratetbl->rate[i].idx = -1;
+		mi->ratetbl->rate[i].count = 0;
+		mi->ratetbl->rate[i].txpower_idx = -1;
+	}
+
+	minstrel_ht_update_rates(mp, mi, false);
+	return err;
+}
+
+static void
+orca_sta_reset_rc_stats(struct minstrel_priv *mp, struct minstrel_ht_sta *mi)
+{
+	mi->ampdu_len = 0;
+	mi->ampdu_packets = 0;
+	mi->avg_ampdu_len = MINSTREL_FRAC(1, 1);
+	memset(&mi->max_tp_rate, 0, sizeof(u16) * MAX_THR_RATES);
+	mi->max_prob_rate = 0;
+	mi->total_packets = 0;
+	mi->sample_packets = 0;
+	mi->sample_rate = 0;
+	memset(&mi->sample, 0, sizeof(struct minstrel_sample_category) *
+			       __MINSTREL_SAMPLE_TYPE_MAX);
+	memset(&mi->groups, 0, sizeof(struct minstrel_mcs_group_data) *
+			       MINSTREL_GROUPS_NB);
+
+	minstrel_ht_update_stats(mp, mi);
+}
+
+static int
+orca_sta_cmd(struct minstrel_priv *mp, enum api_cmd cmd, char *arg_str)
+{
+	struct minstrel_ht_sta *mi;
+	uint8_t macaddr[ETH_ALEN];
+	char *args[5];
+	int n_args;
+	int ret = 0;
+
+	n_args = orca_get_args(args, ARRAY_SIZE(args), arg_str, ";");
+	if (!args[0] || !mac_pton(args[0], macaddr))
+		return -EINVAL;
+
+	mi = orca_get_sta(mp, macaddr);
+	if (!mi)
+		return -ENOENT;
+
+	spin_lock_bh(&mi->lock);
+
+	switch (cmd) {
+	case STA_CMD_PROBE:
+		ret = orca_set_probe(mp, mi, args[1]);
+		break;
+	case STA_CMD_RC:
+	case STA_CMD_TPC:
+	case STA_CMD_TPRC:
+		ret = orca_set_ratetbl(mp, mi, cmd, &args[1], n_args - 1);
+		break;
+	case STA_CMD_RC_MODE:
+		ret = orca_sta_set_rc_mode(mi, args[1]);
+		break;
+	case STA_CMD_TPC_MODE:
+		ret = orca_sta_set_tpc_mode(mp, mi, args[1]);
+		break;
+	case STA_CMD_RESET_STATS:
+		orca_sta_reset_rc_stats(mp, mi);
+		break;
+	default:
+		ret = -EINVAL;
+	}
+
+	spin_unlock_bh(&mi->lock);
+	return ret;
+}
+
+static int
+orca_exec_cmd_for_all(struct minstrel_priv *mp, enum api_cmd cmd, char *args)
+{
+	struct minstrel_ht_sta *mi;
+	int ret = 0;
+
+	rcu_read_lock();
+
+	switch (cmd) {
+	case STA_CMD_RESET_STATS:
+		list_for_each_entry_rcu(mi, &mp->stations, list)
+			orca_sta_reset_rc_stats(mp, mi);
+		break;
+	case STA_CMD_RC_MODE:
+		list_for_each_entry_rcu(mi, &mp->stations, list)
+			orca_sta_set_rc_mode(mi, args);
+		break;
+	case STA_CMD_TPC_MODE:
+		list_for_each_entry_rcu(mi, &mp->stations, list)
+			orca_sta_set_tpc_mode(mp, mi, args);
+		break;
+	default:
+		ret = -EPERM;
+	}
+
+	rcu_read_unlock();
+	return ret;
+}
+
+static int
+orca_exec_cmd(struct minstrel_priv *mp, enum api_cmd cmd, char *args)
+{
+	int err = 0;
+
+	switch (cmd) {
+	case PHY_CMD_START:
+		orca_start_monitoring(mp, args);
+		break;
+	case PHY_CMD_STOP:
+		orca_stop_monitoring(mp, args);
+		break;
+	case PHY_CMD_DUMP:
+		orca_dump_stations(mp, "dump");
+		break;
+	case STA_CMD_RC_MODE:
+	case STA_CMD_TPC_MODE:
+	case STA_CMD_RESET_STATS:
+		if (args && !strncmp(args, "all", 3)) {
+			strsep(&args, ";");
+			err = orca_exec_cmd_for_all(mp, cmd, args);
+			break;
+		}
+		fallthrough;
+	case STA_CMD_RC:
+	case STA_CMD_TPC:
+	case STA_CMD_TPRC:
+	case STA_CMD_PROBE:
+		err = orca_sta_cmd(mp, cmd, args);
+		break;
+	case PHY_CMD_SET_FEATURE:
+		err = orca_phy_set_feature(mp, args);
+		break;
+	default:
+		err = -EINVAL;
+	}
+
+	return err;
+}
+
+static int
+orca_exec_and_echo_cmd(struct minstrel_priv *mp, enum api_cmd cmd,
+		       char* cmd_str, char *args)
+{
+	char buf[128];
+	int err = 0, len;
+
+	/* Store command with timestamp, args may be modified later */
+	len = scnprintf(buf, sizeof(buf), "%llx;%s",
+			(unsigned long long)ktime_get_real_fast_ns(),
+			cmd_str);
+	if (args)
+		len += scnprintf(buf + len, sizeof(buf) - len, ";%s\n", args);
+	else
+		len += scnprintf(buf + len, sizeof(buf) - len, "\n");
+
+	err = orca_exec_cmd(mp, cmd, args);
+	if (err)
+		return err;
+
+	/* Echo command to api_event */
+	spin_lock_bh(&mp->relay_lock);
+
+	relay_write(mp->relay_ev, buf, len);
+	relay_flush(mp->relay_ev);
+
+	spin_unlock_bh(&mp->relay_lock);
+
+	return 0;
+}
+
+static ssize_t
+orca_control_write(struct file *file, const char __user *userbuf, size_t count,
+		   loff_t *ppos)
+{
+	struct minstrel_priv *mp = file->private_data;
+	enum api_cmd cmd;
+	char *pos, *cur;
+	char buf[96];
+	size_t len = count;
+	int err;
+	bool echo = true;
+
+	if (len > sizeof(buf) - 1)
+		return -EMSGSIZE;
+
+	if (copy_from_user(buf, userbuf, len))
+		return -EFAULT;
+
+	if (count > 0 && buf[len - 1] == '\n')
+		len--;
+
+	buf[len] = 0;
+	if (!len)
+		return count;
+
+	pos = buf;
+	cur = strsep(&pos, ";");
+
+	if (!strcmp(cur, "set_rates_power") || !strcmp(cur, "rates")) {
+		cmd = STA_CMD_TPRC;
+		echo = (mp->monitor & ORCA_ECHO_TPRC);
+	} else if (!strcmp(cur, "set_power")) {
+		cmd = STA_CMD_TPC;
+		echo = (mp->monitor & ORCA_ECHO_TPRC);
+	} else if (!strcmp(cur, "set_rates")) {
+		cmd = STA_CMD_RC;
+		echo = (mp->monitor & ORCA_ECHO_TPRC);
+	} else if (!strcmp(cur, "set_probe")) {
+		cmd = STA_CMD_PROBE;
+		echo = (mp->monitor & ORCA_ECHO_TPRC);
+	} else if (!strcmp(cur, "dump")) {
+		cmd = PHY_CMD_DUMP;
+		echo = false;
+	} else if (!strcmp(cur, "start")) {
+		cmd = PHY_CMD_START;
+	} else if (!strcmp(cur, "stop")) {
+		cmd = PHY_CMD_STOP;
+	} else if (!strcmp(cur, "rc_mode")) {
+		cmd = STA_CMD_RC_MODE;
+	} else if (!strcmp(cur, "tpc_mode")) {
+		cmd = STA_CMD_TPC_MODE;
+	} else if (!strcmp(cur, "reset_stats")) {
+		cmd = STA_CMD_RESET_STATS;
+	} else if (!strcmp(cur, "set_feature")) {
+		cmd = PHY_CMD_SET_FEATURE;
+	} else {
+		return -EINVAL;
+	}
+
+	err = (echo) ? orca_exec_and_echo_cmd(mp, cmd, cur, pos)
+		     : orca_exec_cmd(mp, cmd, pos);
+	if (err)
+		return err;
+
+	return count;
+}
+
+static const struct file_operations fops_control = {
+	.open = simple_open,
+	.llseek = generic_file_llseek,
+	.write = orca_control_write,
+};
+
+void orca_sta_update(struct minstrel_priv *mp, struct minstrel_ht_sta *mi)
+{
+	bool add = list_empty(&mi->list);
+
+	if (add) {
+		spin_lock_bh(&mp->sta_wlock);
+		list_add_rcu(&mi->list, &mp->stations);
+		spin_unlock_bh(&mp->sta_wlock);
+	}
+
+	spin_lock_bh(&mp->relay_lock);
+	orca_dump_sta(mp, mi, add ? "add" : "update");
+	spin_unlock_bh(&mp->relay_lock);
+}
+
+void orca_sta_remove(struct minstrel_priv *mp, struct minstrel_ht_sta *mi)
+{
+	struct ieee80211_sta_rates *ratetbl = mi->ratetbl;
+	char info[64];
+	int ofs = 0;
+
+	spin_lock_bh(&mp->sta_wlock);
+
+	list_del_rcu(&mi->list);
+	INIT_LIST_HEAD_RCU(&mi->list);
+
+	spin_lock(&mi->lock);
+
+	mi->ratetbl = NULL;
+	kfree(ratetbl);
+
+	spin_unlock(&mi->lock);
+	spin_unlock_bh(&mp->sta_wlock);
+
+	ofs = scnprintf(info, sizeof(info), "%llx;sta;remove;%pM;;;\n",
+			(unsigned long long)ktime_get_real_fast_ns(),
+			mi->sta->addr);
+
+	spin_lock_bh(&mp->relay_lock);
+
+	relay_write(mp->relay_ev, info, ofs);
+	relay_flush(mp->relay_ev);
+
+	spin_unlock_bh(&mp->relay_lock);
+}
+
+void __orca_report_tx_status(struct minstrel_priv *mp,
+			     struct minstrel_ht_sta *mi,
+			     struct ieee80211_tx_info *info,
+			     u16 *rate_list, s16 *txpwr_list, int n_rates)
+{
+	char txs[64 + IEEE80211_TX_MAX_RATES * 14];
+	int ofs = 0;
+	int i;
+
+	if (!n_rates)
+		return;
+
+	ofs += scnprintf(txs, sizeof(txs), "%llx;txs;%pM;%x;%x;%x",
+			 (unsigned long long)ktime_get_real_fast_ns(),
+			 mi->sta->addr,
+			 info->status.ampdu_len,
+			 info->status.ampdu_ack_len,
+			 !!(info->flags & IEEE80211_TX_CTL_RATE_CTRL_PROBE));
+
+	for (i = 0; i < n_rates; i++) {
+		ofs += scnprintf(txs + ofs, sizeof(txs) - ofs, ";%x,%x,",
+				 rate_list[i], info->status.rates[i].count);
+		if (txpwr_list[i] < 0)
+			continue;
+
+		ofs += scnprintf(txs + ofs, sizeof(txs) - ofs, "%x",
+				 (u16)(txpwr_list[i]));
+	}
+
+	for (; i < IEEE80211_TX_MAX_RATES; i++)
+		ofs += scnprintf(txs + ofs, sizeof(txs) - ofs, ";,,");
+
+	ofs += scnprintf(txs + ofs, sizeof(txs) - ofs, "\n");
+
+	spin_lock_bh(&mp->relay_lock);
+
+	relay_write(mp->relay_ev, txs, ofs);
+	relay_flush(mp->relay_ev);
+
+	spin_unlock_bh(&mp->relay_lock);
+}
+
+void __orca_report_rx_status(struct minstrel_priv *mp, u8 *addr, s8 last_signal,
+			     u8 chain_status, s8 *chain_signal)
+{
+	char rxs[64 + IEEE80211_MAX_CHAINS * 8];
+	int ofs = 0;
+	int i;
+
+	/* Cast signal to u8 to avoid having ffffff for negative values */
+	ofs += scnprintf(rxs, sizeof(rxs), "%llx;rxs;%pM;%x",
+			 (unsigned long long)ktime_get_real_fast_ns(),
+			 addr, (u8)last_signal);
+
+	for (i = 0; i < IEEE80211_MAX_CHAINS; i++)
+	ofs += scnprintf(rxs + ofs, sizeof(rxs) - ofs, ";%x",
+			 (chain_status & BIT(i) ? (u8)chain_signal[i] : 0x7f));
+
+	ofs += scnprintf(rxs + ofs, sizeof(rxs) - ofs, "\n");
+
+	spin_lock_bh(&mp->relay_lock);
+
+	relay_write(mp->relay_ev, rxs, ofs);
+	relay_flush(mp->relay_ev);
+
+	spin_unlock_bh(&mp->relay_lock);
+}
+
+void __orca_report_rate_update(struct minstrel_priv *mp,
+			       struct minstrel_ht_sta *mi, u16 rate,
+			       struct minstrel_rate_stats *mrs)
+{
+	char stat[100];
+	int ofs;
+	int tp;
+
+	tp = minstrel_ht_get_tp_avg(mi, MI_RATE_GROUP(rate), MI_RATE_IDX(rate),
+				    mrs->prob_avg);
+
+	ofs = scnprintf(stat, sizeof(stat),
+			"%llx;stats;%pM;%x;%x;%x;%x;%x;%x;%x\n",
+			(unsigned long long)ktime_get_real_fast_ns(),
+			mi->sta->addr, rate,
+			MINSTREL_TRUNC(mrs->prob_avg * 1000), tp,
+			mrs->last_success,
+			mrs->last_attempts,
+			mrs->succ_hist, mrs->att_hist);
+
+	spin_lock_bh(&mp->relay_lock);
+
+	relay_write(mp->relay_ev, stat, ofs);
+	relay_flush(mp->relay_ev);
+
+	spin_unlock_bh(&mp->relay_lock);
+}
+
+void __orca_report_best_rates(struct minstrel_priv *mp, struct minstrel_ht_sta *mi)
+{
+	char line[128];
+	int i, ofs;
+
+	ofs = scnprintf(line, sizeof(line), "%llx;best_rates;%pM",
+	                (unsigned long long)ktime_get_real_fast_ns(),
+	                mi->sta->addr);
+
+	for (i = 0; i < MAX_THR_RATES; i++)
+		ofs += scnprintf(line + ofs, sizeof(line), ";%x", mi->max_tp_rate[i]);
+
+	ofs += scnprintf(line + ofs, sizeof(line), ";%x\n", mi->max_prob_rate);
+
+	spin_lock_bh(&mp->relay_lock);
+
+	relay_write(mp->relay_ev, line, ofs);
+	relay_flush(mp->relay_ev);
+
+	spin_unlock_bh(&mp->relay_lock);
+}
+
+void orca_add_debugfs_api(struct ieee80211_hw *hw, void *priv, struct dentry *dir)
+{
+	struct minstrel_priv *mp = priv;
+
+	BUILD_BUG_ON(ARRAY_SIZE(feature_pretty) != NUM_IEEE80211_FTRCTRL);
+
+	spin_lock_init(&mp->relay_lock);
+	spin_lock_init(&mp->sta_wlock);
+
+	INIT_LIST_HEAD_RCU(&mp->stations);
+	mp->relay_ev = relay_open("api_event", dir, 256, 512, &relay_ev_cb,
+				  NULL);
+	debugfs_create_devm_seqfile(&hw->wiphy->dev, "api_info",
+				    dir, orca_read_api_info);
+	debugfs_create_devm_seqfile(&hw->wiphy->dev, "api_phy",
+				    dir, orca_read_phy_info);
+	debugfs_create_file("api_control", 0200, dir, mp, &fops_control);
+}
+
+void orca_remove_debugfs_api(void *priv)
+{
+	struct minstrel_priv *mp = priv;
+
+	spin_lock_bh(&mp->relay_lock);
+	if (mp->relay_ev)
+		relay_close(mp->relay_ev);
+
+	spin_unlock_bh(&mp->relay_lock);
+}
