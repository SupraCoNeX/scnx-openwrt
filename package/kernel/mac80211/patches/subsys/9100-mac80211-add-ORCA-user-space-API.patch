--- a/net/mac80211/rx.c
+++ b/net/mac80211/rx.c
@@ -33,6 +33,7 @@
 #include "tkip.h"
 #include "wme.h"
 #include "rate.h"
+#include "rc80211_minstrel_ht.h"
 
 /*
  * monitor mode reception
@@ -5452,6 +5453,14 @@ void ieee80211_rx_list(struct ieee80211_
 			ieee80211_is_data_present(hdr->frame_control))
 			ieee80211_tpt_led_trig_rx(local, skb->len);
 
+		if (pubsta && local->rate_ctrl) {
+			struct sta_info *sta = container_of(pubsta, struct sta_info, sta);
+
+			if (test_sta_flag(sta, WLAN_STA_RATE_CONTROL)) {
+				orca_report_rx_status(local->rate_ctrl->priv, sta, status);
+			}
+		}
+
 		if (status->flag & RX_FLAG_8023)
 			__ieee80211_rx_handle_8023(hw, pubsta, skb, list);
 		else
--- a/local-symbols
+++ b/local-symbols
@@ -34,6 +34,7 @@ LIB80211_DEBUG=
 MAC80211=
 MAC80211_HAS_RC=
 MAC80211_RC_MINSTREL=
+MAC80211_ORCA_UAPI=
 MAC80211_RC_DEFAULT_MINSTREL=
 MAC80211_RC_DEFAULT=
 MAC80211_KUNIT_TEST=
--- a/net/mac80211/Kconfig
+++ b/net/mac80211/Kconfig
@@ -109,6 +109,15 @@ config MAC80211_MESSAGE_TRACING
 	  need to be present in the binary and formatted at
 	  runtime for tracing.
 
+config MAC80211_ORCA_UAPI
+        bool "ORCA Userspace API"
+        depends on MAC80211_RC_MINSTREL
+        depends on MAC80211_DEBUGFS
+        select RELAY
+        help
+          This option creates debugfs files that allow user space to observe
+          and/or control minstrel rate selection behavior
+
 menuconfig MAC80211_DEBUG_MENU
 	bool "Select mac80211 debugging features"
 	depends on MAC80211
--- a/net/mac80211/Makefile
+++ b/net/mac80211/Makefile
@@ -63,6 +63,9 @@ rc80211_minstrel-y := \
 rc80211_minstrel-$(CPTCFG_MAC80211_DEBUGFS) += \
 	rc80211_minstrel_ht_debugfs.o
 
+rc80211_minstrel-$(CPTCFG_MAC80211_ORCA_UAPI) += \
+	orca_uapi.o
+
 mac80211-$(CPTCFG_MAC80211_RC_MINSTREL) += $(rc80211_minstrel-y)
 
 obj-y += tests/
--- a/net/mac80211/rc80211_minstrel_ht.c
+++ b/net/mac80211/rc80211_minstrel_ht.c
@@ -264,7 +264,7 @@ const struct mcs_group minstrel_mcs_grou
 
 const s16 minstrel_cck_bitrates[4] = { 10, 20, 55, 110 };
 const s16 minstrel_ofdm_bitrates[8] = { 60, 90, 120, 180, 240, 360, 480, 540 };
-static u8 sample_table[SAMPLE_COLUMNS][MCS_GROUP_RATES] __read_mostly;
+u8 sample_table[SAMPLE_COLUMNS][MCS_GROUP_RATES] __read_mostly;
 static const u8 minstrel_sample_seq[] = {
 	MINSTREL_SAMPLE_TYPE_INC,
 	MINSTREL_SAMPLE_TYPE_JUMP,
@@ -274,9 +274,6 @@ static const u8 minstrel_sample_seq[] =
 	MINSTREL_SAMPLE_TYPE_SLOW,
 };
 
-static void
-minstrel_ht_update_rates(struct minstrel_priv *mp, struct minstrel_ht_sta *mi);
-
 /*
  * Some VHT MCSes are invalid (when Ndbps / Nes is not an integer)
  * e.g for MCS9@20MHzx1Nss: Ndbps=8x52*(5/6) Nes=1
@@ -368,7 +365,7 @@ minstrel_vht_ri_get_group_idx(struct rat
 
 static struct minstrel_rate_stats *
 minstrel_ht_get_stats(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,
-		      struct ieee80211_tx_rate *rate)
+		      struct ieee80211_tx_rate *rate, u16 *dest_idx)
 {
 	int group, idx;
 
@@ -406,6 +403,7 @@ minstrel_ht_get_stats(struct minstrel_pr
 
 	idx = 0;
 out:
+	*dest_idx = MI_RATE(group, idx);
 	return &mi->groups[group].rates[idx];
 }
 
@@ -414,7 +412,8 @@ out:
  */
 static struct minstrel_rate_stats *
 minstrel_ht_ri_get_stats(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,
-			 struct ieee80211_rate_status *rate_status)
+			 struct ieee80211_rate_status *rate_status,
+			 u16 *dest_idx)
 {
 	int group, idx, rate_idx;
 	struct rate_info *rate = &rate_status->rate_idx;
@@ -454,6 +453,7 @@ minstrel_ht_ri_get_stats(struct minstrel
 
 	idx = 0;
 out:
+	*dest_idx = MI_RATE(group, idx);
 	return &mi->groups[group].rates[idx];
 }
 
@@ -1029,7 +1029,7 @@ minstrel_ht_refill_sample_rates(struct m
  *  - as long as the max prob rate has a probability of more than 75%, pick
  *    higher throughput rates, even if the probablity is a bit lower
  */
-static void
+void
 minstrel_ht_update_stats(struct minstrel_priv *mp, struct minstrel_ht_sta *mi)
 {
 	struct minstrel_mcs_group_data *mg;
@@ -1093,6 +1093,8 @@ minstrel_ht_update_stats(struct minstrel
 			tp_rate = tmp_legacy_tp_rate;
 
 		for (i = MCS_GROUP_RATES - 1; i >= 0; i--) {
+			bool changed;
+
 			if (!(mi->supported[group] & BIT(i)))
 				continue;
 
@@ -1100,7 +1102,11 @@ minstrel_ht_update_stats(struct minstrel
 
 			mrs = &mg->rates[i];
 			mrs->retry_updated = false;
+			changed = mrs->attempts > 0;
 			minstrel_ht_calc_rate_stats(mp, mrs);
+			if (changed)
+				orca_report_rate_update(mp, mi, index,
+							       mrs);
 
 			if (mrs->att_hist)
 				last_prob = max(last_prob, mrs->prob_avg);
@@ -1149,7 +1155,13 @@ minstrel_ht_update_stats(struct minstrel
 
 	mi->max_prob_rate = tmp_max_prob_rate;
 
-	minstrel_ht_refill_sample_rates(mi);
+	orca_report_best_rates(mp, mi);
+	orca_report_estimated_throughput(mp, mi);
+
+	if (!orca_sta_rc_manual_mode(mi)) {
+		minstrel_ht_refill_sample_rates(mi);
+		orca_report_sample_rates(mp, mi);
+	}
 
 #ifdef CPTCFG_MAC80211_DEBUGFS
 	/* use fixed index if set */
@@ -1256,8 +1268,10 @@ minstrel_ht_tx_status(void *priv, struct
 	struct ieee80211_tx_rate *ar = info->status.rates;
 	struct minstrel_rate_stats *rate;
 	struct minstrel_priv *mp = priv;
-	u32 update_interval = mp->update_interval;
+	u32 update_interval = MINSTREL_UPDATE_INTERVAL;
 	bool last, update = false;
+	u16 rate_list[IEEE80211_TX_MAX_RATES] = {};
+	s16 txpwr_list[IEEE80211_TX_MAX_RATES] = {};
 	int i;
 
 	/* Ignore packet that was sent with noAck flag */
@@ -1269,12 +1283,18 @@ minstrel_ht_tx_status(void *priv, struct
 	    !(info->flags & IEEE80211_TX_STAT_AMPDU))
 		return;
 
+#ifdef CPTCFG_MAC80211_ORCA_UAPI
+	update_interval = mi->update_interval;
+#endif
+
 	if (!(info->flags & IEEE80211_TX_STAT_AMPDU)) {
 		info->status.ampdu_ack_len =
 			(info->flags & IEEE80211_TX_STAT_ACK ? 1 : 0);
 		info->status.ampdu_len = 1;
 	}
 
+	spin_lock_bh(&mi->lock);
+
 	/* wraparound */
 	if (mi->total_packets >= ~0 - info->status.ampdu_len) {
 		mi->total_packets = 0;
@@ -1296,13 +1316,15 @@ minstrel_ht_tx_status(void *priv, struct
 							&(st->rates[i + 1]));
 
 			rate = minstrel_ht_ri_get_stats(mp, mi,
-							&(st->rates[i]));
+							&(st->rates[i]),
+							&rate_list[i]);
 
 			if (last)
 				rate->success += info->status.ampdu_ack_len;
 
 			rate->attempts += st->rates[i].try_count *
 					  info->status.ampdu_len;
+			txpwr_list[i] = st->rates[i].txpower_idx;
 		}
 	} else {
 		last = !minstrel_ht_txstat_valid(mp, mi, &ar[0]);
@@ -1310,14 +1332,18 @@ minstrel_ht_tx_status(void *priv, struct
 			last = (i == IEEE80211_TX_MAX_RATES - 1) ||
 				!minstrel_ht_txstat_valid(mp, mi, &ar[i + 1]);
 
-			rate = minstrel_ht_get_stats(mp, mi, &ar[i]);
+			rate = minstrel_ht_get_stats(mp, mi, &ar[i], &rate_list[i]);
+
 			if (last)
 				rate->success += info->status.ampdu_ack_len;
 
 			rate->attempts += ar[i].count * info->status.ampdu_len;
+			txpwr_list[i] = -1;
 		}
 	}
 
+	orca_report_tx_status(mp, mi, info, rate_list, txpwr_list, i);
+
 	if (mp->hw->max_rates > 1) {
 		/*
 		 * check for sudden death of spatial multiplexing,
@@ -1339,7 +1365,9 @@ minstrel_ht_tx_status(void *priv, struct
 	}
 
 	if (update)
-		minstrel_ht_update_rates(mp, mi);
+		minstrel_ht_update_rates(mp, mi, false);
+
+	spin_unlock_bh(&mi->lock);
 }
 
 static void
@@ -1402,7 +1430,7 @@ minstrel_calc_retransmit(struct minstrel
 }
 
 
-static void
+void
 minstrel_ht_set_rate(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,
                      struct ieee80211_sta_rates *ratetbl, int offset, int index)
 {
@@ -1510,39 +1538,55 @@ minstrel_ht_get_max_amsdu_len(struct min
 	return 0;
 }
 
-static void
-minstrel_ht_update_rates(struct minstrel_priv *mp, struct minstrel_ht_sta *mi)
+void
+minstrel_ht_update_rates(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,
+			 bool force)
 {
 	struct ieee80211_sta_rates *rates;
 	int i = 0;
 	int max_rates = min_t(int, mp->hw->max_rates, IEEE80211_TX_RATE_TABLE_SIZE);
+	bool manual_rc, manual_tpc, update_stats = true;
 
 	rates = kzalloc(sizeof(*rates), GFP_ATOMIC);
 	if (!rates)
 		return;
 
-	/* Start with max_tp_rate[0] */
-	minstrel_ht_set_rate(mp, mi, rates, i, mi->max_tp_rate[0]);
-	rates->rate[i].txpower_idx = -1;
-	i++;
-
-	/* Fill up remaining, keep one entry for max_probe_rate */
-	for (; i < (max_rates - 1); i++) {
-		minstrel_ht_set_rate(mp, mi, rates, i, mi->max_tp_rate[i]);
-		rates->rate[i].txpower_idx = -1;
-	}
+	manual_rc = orca_sta_rc_manual_mode(mi) && !force;
+	manual_tpc = orca_sta_tpc_manual_mode(mi) && !force;
 
-	if (i < max_rates) {
-		minstrel_ht_set_rate(mp, mi, rates, i, mi->max_prob_rate);
-		rates->rate[i].txpower_idx = -1;
-		i++;
-	}
+	if (manual_rc) {
+		if (mi->ratetbl->rate[0].idx >= 0) {
+			memcpy(rates, mi->ratetbl, sizeof(*rates));
+		} else {
+			kfree(rates);
+			return;
+		}
+		update_stats = false;
+	} else {
+		/* Start with max_tp_rate[0] */
+		minstrel_ht_set_rate(mp, mi, rates, i++, mi->max_tp_rate[0]);
 
-	if (i < IEEE80211_TX_RATE_TABLE_SIZE)
-		rates->rate[i].idx = -1;
+		/* Fill up remaining, keep one entry for max_probe_rate */
+		for (; i < (max_rates - 1); i++)
+			minstrel_ht_set_rate(mp, mi, rates, i, mi->max_tp_rate[i]);
 
-	mi->sta->deflink.agg.max_rc_amsdu_len = minstrel_ht_get_max_amsdu_len(mi);
-	ieee80211_sta_recalc_aggregates(mi->sta);
+		if (i < max_rates)
+			minstrel_ht_set_rate(mp, mi, rates, i++, mi->max_prob_rate);
+
+		if (i < IEEE80211_TX_RATE_TABLE_SIZE)
+			rates->rate[i].idx = -1;
+
+		/* Read power from ratetbl because we did not memcpy the whole ratetbl. */
+		for (i = 0; i < max_rates; i++)
+			rates->rate[i].txpower_idx = manual_tpc ? mi->ratetbl->rate[i].txpower_idx
+								: -1;
+	}
+
+	if (update_stats) {
+		mi->sta->deflink.agg.max_rc_amsdu_len =
+			minstrel_ht_get_max_amsdu_len(mi);
+		ieee80211_sta_recalc_aggregates(mi->sta);
+	}
 	rate_control_set_rates(mp->hw, mi->sta, rates);
 }
 
@@ -1551,7 +1595,7 @@ minstrel_ht_get_sample_rate(struct minst
 {
 	u8 seq;
 
-	if (mp->hw->max_rates > 1) {
+	if (mp->hw->max_rates > 1 && !orca_sta_rc_manual_mode(mi)) {
 		seq = mi->sample_seq;
 		mi->sample_seq = (seq + 1) % ARRAY_SIZE(minstrel_sample_seq);
 		seq = minstrel_sample_seq[seq];
@@ -1572,6 +1616,8 @@ minstrel_ht_get_rate(void *priv, struct
 	struct minstrel_ht_sta *mi = priv_sta;
 	struct minstrel_priv *mp = priv;
 	u16 sample_idx;
+	u32 sampling_interval = MINSTREL_SAMPLE_INTERVAL;
+	u8 sample_count = 1;
 	s16 sample_txpower = -1;
 
 	info->flags |= mi->tx_flags;
@@ -1579,6 +1625,8 @@ minstrel_ht_get_rate(void *priv, struct
 #ifdef CPTCFG_MAC80211_DEBUGFS
 	if (mp->fixed_rate_idx != -1)
 		return;
+
+	sampling_interval = mi->sample_interval;
 #endif
 
 	/* Don't use EAPOL frames for sampling on non-mrr hw */
@@ -1586,14 +1634,34 @@ minstrel_ht_get_rate(void *priv, struct
 	    (info->control.flags & IEEE80211_TX_CTRL_PORT_CTRL_PROTO))
 		return;
 
+	if (orca_sta_tpc_manual_mode(mi) && mi->user_sample_txpower != -1) {
+		sample_txpower = mi->user_sample_txpower;
+		mi->user_sample_txpower = -1;
+	}
+	if (orca_sta_rc_manual_mode(mi) && mi->user_sample_rate != -1) {
+		sample_idx = mi->user_sample_rate;
+		if (mi->user_sample_count > 0 &&
+		    mi->user_sample_count <= IEEE80211_MAX_TX_RETRY)
+			sample_count = mi->user_sample_count;
+
+		mi->user_sample_rate = -1;
+		mi->user_sample_count = 0;
+
+		goto set_rate;
+	}
+
 	if (time_is_after_jiffies(mi->sample_time))
 		return;
 
-	mi->sample_time = jiffies + MINSTREL_SAMPLE_INTERVAL;
+	spin_lock_bh(&mi->lock);
+
+	mi->sample_time = jiffies + sampling_interval;
 	sample_idx = minstrel_ht_get_sample_rate(mp, mi);
+	spin_unlock_bh(&mi->lock);
 	if (!sample_idx)
 		return;
 
+set_rate:
 	sample_group = &minstrel_mcs_groups[MI_RATE_GROUP(sample_idx)];
 	sample_idx = MI_RATE_IDX(sample_idx);
 
@@ -1602,7 +1670,7 @@ minstrel_ht_get_rate(void *priv, struct
 		return;
 
 	info->flags |= IEEE80211_TX_CTL_RATE_CTRL_PROBE;
-	rate->count = 1;
+	rate->count = min_t(u8, sample_count, mp->max_retry);
 
 	if (sample_group == &minstrel_mcs_groups[MINSTREL_CCK_GROUP]) {
 		int idx = sample_idx % ARRAY_SIZE(mp->cck_rates);
@@ -1692,7 +1760,7 @@ minstrel_ht_update_caps(void *priv, stru
 	else
 		use_vht = 0;
 
-	memset(mi, 0, sizeof(*mi));
+	spin_lock_bh(&mi->lock);
 
 	mi->sta = sta;
 	mi->band = sband->band;
@@ -1799,7 +1867,11 @@ minstrel_ht_update_caps(void *priv, stru
 
 	/* create an initial rate table with the lowest supported rates */
 	minstrel_ht_update_stats(mp, mi);
-	minstrel_ht_update_rates(mp, mi);
+	minstrel_ht_update_rates(mp, mi, true);
+
+	orca_sta_update(mp, mi);
+
+	spin_unlock_bh(&mi->lock);
 }
 
 static void
@@ -1835,12 +1907,30 @@ minstrel_ht_alloc_sta(void *priv, struct
 			max_rates = sband->n_bitrates;
 	}
 
-	return kzalloc(sizeof(*mi), gfp);
+	mi = kzalloc(sizeof(*mi), gfp);
+	spin_lock_init(&mi->lock);
+
+#ifdef CPTCFG_MAC80211_ORCA_UAPI
+	mi->update_interval = MINSTREL_UPDATE_INTERVAL;
+	mi->sample_interval = MINSTREL_SAMPLE_INTERVAL;
+
+	INIT_LIST_HEAD(&mi->list);
+	mi->ratetbl = kzalloc(sizeof(*mi->ratetbl), gfp);
+	for (i = 0; i < ARRAY_SIZE(mi->ratetbl->rate); i++)
+		mi->ratetbl->rate[i].txpower_idx = -1;
+
+	mi->user_sample_rate = -1;
+	mi->user_sample_count = 0;
+	mi->user_sample_txpower = -1;
+#endif
+
+	return mi;
 }
 
 static void
 minstrel_ht_free_sta(void *priv, struct ieee80211_sta *sta, void *priv_sta)
 {
+	orca_sta_remove(priv, priv_sta);
 	kfree(priv_sta);
 }
 
@@ -1930,7 +2020,6 @@ minstrel_ht_alloc(struct ieee80211_hw *h
 		mp->max_retry = 7;
 
 	mp->hw = hw;
-	mp->update_interval = HZ / 20;
 
 	minstrel_ht_init_cck_rates(mp);
 	for (i = 0; i < ARRAY_SIZE(mp->hw->wiphy->bands); i++)
@@ -1940,6 +2029,7 @@ minstrel_ht_alloc(struct ieee80211_hw *h
 }
 
 #ifdef CPTCFG_MAC80211_DEBUGFS
+
 static void minstrel_ht_add_debugfs(struct ieee80211_hw *hw, void *priv,
 				    struct dentry *debugfsdir)
 {
@@ -1948,12 +2038,15 @@ static void minstrel_ht_add_debugfs(stru
 	mp->fixed_rate_idx = (u32) -1;
 	debugfs_create_u32("fixed_rate_idx", S_IRUGO | S_IWUGO, debugfsdir,
 			   &mp->fixed_rate_idx);
+
+	orca_add_debugfs_api(hw, priv, debugfsdir);
 }
 #endif
 
 static void
 minstrel_ht_free(void *priv)
 {
+	orca_remove_debugfs_api(priv);
 	kfree(priv);
 }
 
--- a/net/mac80211/rc80211_minstrel_ht.h
+++ b/net/mac80211/rc80211_minstrel_ht.h
@@ -7,6 +7,7 @@
 #define __RC_MINSTREL_HT_H
 
 #include <linux/bitfield.h>
+#include "ieee80211_i.h"
 
 /* number of highest throughput rates to consider*/
 #define MAX_THR_RATES 4
@@ -70,7 +71,13 @@
 #define MI_RATE_GROUP(_rate) FIELD_GET(MI_RATE_GROUP_MASK, _rate)
 
 #define MINSTREL_SAMPLE_RATES		5 /* rates per sample type */
-#define MINSTREL_SAMPLE_INTERVAL	(HZ / 50)
+#define MINSTREL_SAMPLE_INTERVAL	(HZ / 50)	/* 20 ms */
+#define MINSTREL_UPDATE_INTERVAL	(HZ / 20)	/* 50 ms */
+
+#define ORCA_MONITOR_TXS		BIT(0)
+#define ORCA_MONITOR_RXS		BIT(1)
+#define ORCA_MONITOR_STATS		BIT(2)
+#define ORCA_ECHO_TPRC			BIT(7)
 
 struct minstrel_priv {
 	struct ieee80211_hw *hw;
@@ -78,7 +85,6 @@ struct minstrel_priv {
 	unsigned int cw_max;
 	unsigned int max_retry;
 	unsigned int segment_size;
-	unsigned int update_interval;
 
 	u8 cck_rates[4];
 	u8 ofdm_rates[NUM_NL80211_BANDS][8];
@@ -92,6 +98,15 @@ struct minstrel_priv {
 	 */
 	u32 fixed_rate_idx;
 #endif
+#ifdef CPTCFG_MAC80211_ORCA_UAPI
+	struct rchan *relay_ev;
+	spinlock_t relay_lock;
+
+	struct list_head stations;
+	spinlock_t sta_wlock;
+
+	u8 monitor;
+#endif
 };
 
 
@@ -152,7 +167,11 @@ struct minstrel_sample_category {
 };
 
 struct minstrel_ht_sta {
+#ifdef CPTCFG_MAC80211_ORCA_UAPI
+	struct list_head list;
+#endif
 	struct ieee80211_sta *sta;
+	spinlock_t lock;
 
 	/* ampdu length (average, per sampling interval) */
 	unsigned int ampdu_len;
@@ -193,10 +212,177 @@ struct minstrel_ht_sta {
 
 	/* MCS rate group info and statistics */
 	struct minstrel_mcs_group_data groups[MINSTREL_GROUPS_NB];
+
+#ifdef CPTCFG_MAC80211_ORCA_UAPI
+	struct ieee80211_sta_rates *ratetbl;
+	u32 user_sample_rate;
+	s16 user_sample_txpower;
+	u8 user_sample_count;
+
+	unsigned int update_interval;
+	unsigned int sample_interval;
+
+	bool rc_manual;
+	bool tpc_manual;
+#endif
 };
 
 void minstrel_ht_add_sta_debugfs(void *priv, void *priv_sta, struct dentry *dir);
+
+#ifdef CPTCFG_MAC80211_ORCA_UAPI
+void orca_sta_update(struct minstrel_priv *mp, struct minstrel_ht_sta *mi);
+void orca_sta_remove(struct minstrel_priv *mp, struct minstrel_ht_sta *mi);
+void __orca_report_tx_status(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,
+			     struct ieee80211_tx_info *info,
+			     u16 *rate_list, s16* txpwr_list, int n_rates);
+void __orca_report_rx_status(struct minstrel_priv *mp, u8 *addr,
+			     s8 last_signal, u8 chain_status,
+			     s8 *chain_signal);
+void __orca_report_rate_update(struct minstrel_priv *mp,
+			       struct minstrel_ht_sta *mi, u16 rate,
+			       struct minstrel_rate_stats *mrs);
+void __orca_report_best_rates(struct minstrel_priv *mp,
+			      struct minstrel_ht_sta *mi);
+void __orca_report_estimated_throughput(struct minstrel_priv *mp,
+					struct minstrel_ht_sta *mi);
+void __orca_report_sample_rates(struct minstrel_priv *mp,
+				struct minstrel_ht_sta *mi);
+void orca_add_debugfs_api(struct ieee80211_hw *hw, void *priv,
+				 struct dentry *dir);
+void orca_remove_debugfs_api(void *priv);
+#else
+static inline void
+orca_sta_update(struct minstrel_priv *mp, struct minstrel_ht_sta *mi)
+{
+}
+static inline void
+orca_sta_remove(struct minstrel_priv *mp, struct minstrel_ht_sta *mi)
+{
+}
+static inline void
+orca_add_debugfs_api(struct ieee80211_hw *hw, void *priv,
+			    struct dentry *dir)
+{
+}
+static inline void
+orca_remove_debugfs_api(void *priv)
+{
+}
+#endif
+
+static inline void
+orca_report_tx_status(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,
+		      struct ieee80211_tx_info *info,
+		      u16 *rate_list, s16 *txpwr_list, int n_rates)
+{
+#ifdef CPTCFG_MAC80211_ORCA_UAPI
+	struct sta_info *sta_info = container_of(mi->sta, struct sta_info, sta);
+
+	if (!(sta_info->sdata->orca_monitor & ORCA_MONITOR_TXS))
+		return;
+
+	__orca_report_tx_status(mp, mi, info, rate_list, txpwr_list,
+				       n_rates);
+#endif
+}
+
+static inline void
+orca_report_rx_status(struct minstrel_priv *mp, struct sta_info *sta,
+		      struct ieee80211_rx_status *status)
+{
+#ifdef CPTCFG_MAC80211_ORCA_UAPI
+	if (!(sta->sdata->orca_monitor & ORCA_MONITOR_RXS))
+		return;
+
+	__orca_report_rx_status(mp, sta->addr,
+				(!(status->flag & RX_FLAG_NO_SIGNAL_VAL) ? status->signal : -1),
+				status->chains,
+				status->chain_signal);
+#endif
+}
+
+static inline void
+orca_report_rate_update(struct minstrel_priv *mp,
+			struct minstrel_ht_sta *mi, u16 rate,
+			struct minstrel_rate_stats *mrs)
+{
+#ifdef CPTCFG_MAC80211_ORCA_UAPI
+	struct sta_info *sta_info = container_of(mi->sta, struct sta_info, sta);
+
+	if (!(sta_info->sdata->orca_monitor & ORCA_MONITOR_STATS))
+		return;
+
+	__orca_report_rate_update(mp, mi, rate, mrs);
+#endif
+}
+
+static inline void
+orca_report_best_rates(struct minstrel_priv *mp, struct minstrel_ht_sta *mi)
+{
+#ifdef CPTCFG_MAC80211_ORCA_UAPI
+	struct sta_info *sta_info = container_of(mi->sta, struct sta_info, sta);
+
+	if (!(sta_info->sdata->orca_monitor & ORCA_MONITOR_STATS))
+		return;
+
+	__orca_report_best_rates(mp, mi);
+#endif
+}
+
+static inline void
+orca_report_estimated_throughput(struct minstrel_priv *mp,
+				 struct minstrel_ht_sta *mi)
+{
+#ifdef CPTCFG_MAC80211_ORCA_UAPI
+	struct sta_info *sta_info = container_of(mi->sta, struct sta_info, sta);
+
+	if (!(sta_info->sdata->orca_monitor & ORCA_MONITOR_STATS))
+		return;
+
+	__orca_report_estimated_throughput(mp, mi);
+#endif
+}
+
+static inline void
+orca_report_sample_rates(struct minstrel_priv *mp, struct minstrel_ht_sta *mi)
+{
+#ifdef CPTCFG_MAC80211_ORCA_UAPI
+	struct sta_info *sta_info = container_of(mi->sta, struct sta_info, sta);
+
+	if (!(sta_info->sdata->orca_monitor & ORCA_MONITOR_STATS))
+		return;
+
+	__orca_report_sample_rates(mp, mi);
+#endif
+}
+
+static inline bool
+orca_sta_rc_manual_mode(struct minstrel_ht_sta *mi)
+{
+#ifdef CPTCFG_MAC80211_ORCA_UAPI
+	return mi->rc_manual;
+#else
+	return false;
+#endif
+}
+
+static inline bool
+orca_sta_tpc_manual_mode(struct minstrel_ht_sta *mi)
+{
+#ifdef CPTCFG_MAC80211_ORCA_UAPI
+	return mi->tpc_manual;
+#else
+	return false;
+#endif
+}
+
+void minstrel_ht_set_rate(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,
+						  struct ieee80211_sta_rates *ratetbl, int offset,
+						  int index);
 int minstrel_ht_get_tp_avg(struct minstrel_ht_sta *mi, int group, int rate,
 			   int prob_avg);
+void minstrel_ht_update_rates(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,
+			      bool force);
+void minstrel_ht_update_stats(struct minstrel_priv *mp, struct minstrel_ht_sta *mi);
 
 #endif
--- /dev/null
+++ b/net/mac80211/orca_uapi.c
@@ -0,0 +1,1369 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * ORCA - Open-Source Resource Control API
+ *
+ * Copyright (C) 2021 Felix Fietkau <nbd@nbd.name>
+ * Copyright (C) 2021-2023 SupraCoNeX <supraconex@gmail.com>
+ */
+#include <linux/kernel.h>
+#include <linux/debugfs.h>
+#include <linux/relay.h>
+#include <net/mac80211.h>
+#include "ieee80211_i.h"
+#include "rate.h"
+#include "rc80211_minstrel_ht.h"
+
+/*
+ * increase major version for breaking changes/features
+ * increase minor version for non-breaking features
+ * increase patch version for all other small, non-breaking changes
+ */
+#define ORCA_MAJOR_VERSION 3
+#define ORCA_MINOR_VERSION 0
+#define ORCA_PATCH_VERSION 1
+
+extern u8 sample_table[SAMPLE_COLUMNS][MCS_GROUP_RATES];
+
+/* IMPORTANT: make sure that the order matches the order of
+ * enum ieee80211_feature_ctrl in mac80211.h ! */
+static char *feature_pretty[] = {
+	"adaptive_sens", "tpc",
+	"pwr-ack", "pwr-rts", "pwr-chirp", "pwr-rpt",
+	"pwr-user", "force-rr"
+};
+
+typedef enum {
+	PHY_CMD_START,
+	PHY_CMD_STOP,
+	PHY_CMD_DUMP,
+	PHY_CMD_DUMP_FEATURES,
+	PHY_CMD_SET_FEATURE,
+	PHY_CMD_GET,
+
+	/* per-STA commands */
+	STA_CMD_RC_MODE,
+	STA_CMD_TPC_MODE,
+	STA_CMD_RESET_STATS,
+	STA_CMD_PROBE,
+	STA_CMD_TPRC,
+	STA_CMD_TPC,
+	STA_CMD_RC,
+
+	/* keep last, obviously */
+	NUM_API_CMDS,
+} orca_cmd;
+
+static const char *ORCA_CMD_STR[] = {
+	"start",
+	"stop",
+	"dump",
+	"dump_features",
+	"set_feature",
+	"get",
+
+	"rc_mode",
+	"tpc_mode",
+	"reset_stats",
+	"set_probe",
+	"set_rates_power",
+	"set_power",
+	"set_rates",
+};
+
+static void
+orca_print_rate_durations(struct seq_file *s, int group)
+{
+	const struct mcs_group *g = &minstrel_mcs_groups[group];
+	int n_rates;
+	int i;
+
+	if (g->flags & IEEE80211_TX_RC_VHT_MCS)
+		n_rates = 10;
+	else
+		n_rates = 8;
+
+	seq_printf(s, "%x", g->duration[0] << g->shift);
+	for (i = 1; i < n_rates; i++)
+		seq_printf(s, ";%x", g->duration[i] << g->shift);
+
+	for (; i < MCS_GROUP_RATES; i++)
+		seq_printf(s, ";");
+}
+
+static int
+orca_read_api_info(struct seq_file *s, void *data)
+{
+	int i, j;
+	seq_printf(s, "orca_version;%x;%x;%x\n", ORCA_MAJOR_VERSION,
+		   ORCA_MINOR_VERSION, ORCA_PATCH_VERSION);
+
+	seq_printf(s, "#group;index;offset;type;nss;bw;gi");
+	for (i = 0; i < MCS_GROUP_RATES; i++)
+		seq_printf(s, ";airtime%d", i);
+	seq_printf(s, "\n");
+
+	seq_printf(s, "#sta;action;macaddr;iface;rc_mode;tpc_mode;overhead_mcs;overhead_legacy;update_freq;sample_freq");
+	for (i = 0; i < MINSTREL_GROUPS_NB; i++)
+		seq_printf(s, ";mcs%d", i);
+	seq_printf(s, "\n");
+
+	seq_printf(s, "#txs;macaddr;num_frames;num_acked;probe");
+	for (i = 0; i < IEEE80211_TX_MAX_RATES; i++)
+		seq_printf(s, ";rate%d,count%d,txpwr%d", i, i, i);
+	seq_printf(s, "\n");
+
+	seq_printf(s, "#rxs;macaddr;overall_signal");
+	for (i = 0; i < IEEE80211_MAX_CHAINS; i++)
+		seq_printf(s, ";signal_chain%d", i);
+	seq_printf(s, "\n");
+
+	seq_printf(s, "#stats;macaddr;rate;avg_prob;avg_tp;cur_success;"
+		      "cur_attempts;hist_success;hist_attempts\n");
+	seq_printf(s, "#best_rates;macaddr");
+	for (i = 0; i < MAX_THR_RATES; i++)
+		seq_printf(s, ";maxtp%d", i);
+	seq_printf(s, ";maxprob\n");
+
+	seq_printf(s, "#sample_rates;macaddr");
+	for (i = 0; i < MINSTREL_SAMPLE_RATES; i++)
+		seq_printf(s, ";inc%d", i);
+	for (i = 0; i < MINSTREL_SAMPLE_RATES; i++)
+		seq_printf(s, ";jump%d", i);
+	for (i = 0; i < MINSTREL_SAMPLE_RATES; i++)
+		seq_printf(s, ";slow%d", i);
+	seq_printf(s, "\n");
+
+	seq_printf(s, "#sample_table;cols;rows");
+	for (i = 0; i < SAMPLE_COLUMNS; i++)
+		seq_printf(s, ";column%d", i);
+	seq_printf(s, "\n");
+
+	seq_printf(s, "#start;iface;txs,rxs,stats,tprc_echo\n");
+	seq_printf(s, "#stop;iface;txs,rxs,stats,tprc_echo\n");
+
+	seq_printf(s, "#set_rates;macaddr");
+	for (i = 0; i < IEEE80211_TX_MAX_RATES; i++)
+		seq_printf(s, ";rate%d,count%d", i, i);
+	seq_printf(s, "\n");
+
+	seq_printf(s, "#set_power;macaddr");
+	for (i = 0; i < IEEE80211_TX_MAX_RATES; i++)
+		seq_printf(s, ";txpwr%d", i);
+	seq_printf(s, "\n");
+
+	seq_printf(s, "#set_rates_power;macaddr");
+	for (i = 0; i < IEEE80211_TX_MAX_RATES; i++)
+		seq_printf(s, ";rate%d,count%d,txpwr%d", i, i, i);
+	seq_printf(s, "\n");
+
+	seq_printf(s, "#set_probe;macaddr;rate,count,txpwr\n");
+
+	seq_printf(s, "#rc_mode;macaddr;mode;update_freq;sample_freq\n");
+	seq_printf(s, "#tpc_mode;macaddr;mode\n");
+
+	seq_printf(s, "#reset_stats;macaddr\n");
+
+	seq_printf(s, "#dump_features\n");
+	seq_printf(s, "#set_feature;feature;state\n");
+	seq_printf(s, "#get;property\n");
+
+	for (i = 0; i < MINSTREL_GROUPS_NB; i++) {
+		const struct mcs_group *g = &minstrel_mcs_groups[i];
+		const char *type;
+
+		if (i == MINSTREL_CCK_GROUP)
+			type = "cck";
+		else if (i == MINSTREL_OFDM_GROUP)
+			type = "ofdm";
+		else if (g->flags & IEEE80211_TX_RC_VHT_MCS)
+			type = "vht";
+		else
+			type = "ht";
+
+		seq_printf(s, "group;%x;%x;%s;%x;%x;%x;",
+			   i, (u32) MI_RATE(i, 0), type, g->streams, g->bw,
+			   !!(g->flags & IEEE80211_TX_RC_SHORT_GI));
+		orca_print_rate_durations(s, i);
+		seq_printf(s, "\n");
+	}
+	seq_printf(s, "sample_table;%x;%x", SAMPLE_COLUMNS, MCS_GROUP_RATES);
+	for (i = 0; i < SAMPLE_COLUMNS; i++) {
+		seq_printf(s, ";");
+		for (j = 0; j < MCS_GROUP_RATES; j++) {
+			if (j == 0)
+				seq_printf(s, "%x", sample_table[i][j]);
+			else
+				seq_printf(s, ",%x", sample_table[i][j]);
+		}
+	}
+	seq_printf(s, "\n");
+
+	return 0;
+}
+
+static int
+__orca_dump_sta(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,
+		char *buf, unsigned int buf_size, const char *type)
+{
+	struct sta_info *sta_info;
+	int i, ofs = 0;
+
+	sta_info = container_of(mi->sta, struct sta_info, sta);
+
+	if (!type)
+		ofs = scnprintf(buf, buf_size, "sta;");
+	else
+		ofs = scnprintf(buf, buf_size, "%llx;sta;%s;",
+				(unsigned long long)ktime_get_real_fast_ns(),
+				type);
+
+	ofs += scnprintf(buf + ofs, buf_size - ofs,
+			 "%pM;%s;%s;%s;%x;%x;%x;%x",
+			 mi->sta->addr, sta_info->sdata->name,
+			 mi->rc_manual ? "manual" : "auto",
+			 mi->tpc_manual ? "manual" : "auto",
+			 mi->overhead, mi->overhead_legacy,
+			 HZ / mi->update_interval,
+			 HZ / mi->sample_interval);
+
+	for (i = 0; i < MINSTREL_GROUPS_NB; i++)
+		ofs += scnprintf(buf + ofs, buf_size - ofs, ";%x",
+				 mi->supported[i]);
+
+	ofs += scnprintf(buf + ofs, buf_size - ofs, "\n");
+	return ofs;
+}
+
+static unsigned int
+__orca_dump_features(struct minstrel_priv *mp, char *buf, unsigned int buf_size)
+{
+	struct ieee80211_local *local = hw_to_local(mp->hw);
+	unsigned int i, cnt;
+	s16 state;
+
+	cnt = scnprintf(buf, buf_size, "ftrs;%lx", hweight_long(mp->hw->feature_ctrl));
+	for (i = 0; i < NUM_IEEE80211_FTRCTRL; i++) {
+		if (!ieee80211_feature_ctrl_has(mp->hw, i))
+			continue;
+
+		state = local->ops->get_feature_state(mp->hw, i);
+		cnt += scnprintf(buf + cnt, buf_size - cnt, ";%s,%x",
+				 feature_pretty[i], (u16)state);
+	}
+
+	cnt += scnprintf(buf + cnt, buf_size - cnt, "\n");
+	return cnt;
+}
+
+static int
+orca_read_phy_info(struct seq_file *s, void *data)
+{
+	struct wiphy *wiphy = container_of(s->private, struct wiphy, dev);
+	struct ieee80211_local *local = wiphy_priv(wiphy);
+	struct ieee80211_sub_if_data *sdata;
+	struct minstrel_priv *mp = local->rate_ctrl->priv;
+	struct minstrel_ht_sta *mi;
+	char *buf_ref;
+	int i, power_limit, len;
+
+	seq_printf(s, "drv;%s\n", wiphy_dev(wiphy)->driver->name);
+
+	if (ieee80211_hw_check(&local->hw, SUPPORTS_TPC_PER_PACKET)) {
+		seq_printf(s, "tpc;pkt");
+	} else if (ieee80211_hw_check(&local->hw, SUPPORTS_TPC_PER_MRR)) {
+		seq_printf(s, "tpc;mrr");
+	} else {
+		seq_printf(s, "tpc;not\n");
+		goto skip_tpc;
+	}
+
+	seq_printf(s, ";%u", local->hw.n_txpower_ranges);
+	for (i = 0; i < local->hw.n_txpower_ranges; i++) {
+		struct ieee80211_hw_txpower_range *rng = &local->hw.txpower_ranges[i];
+		seq_printf(s, ";%x,%x,%x,%x", rng->start_idx, rng->n_levels,
+			   (u8)rng->start_pwr, (u8)rng->pwr_step);
+	}
+	seq_printf(s, "\n");
+
+skip_tpc:
+	if (local->ops->get_txpower) {
+		if (!local->ops->get_txpower(&local->hw, NULL, &power_limit))
+			/* use 0.5 dBm steps, ath9k and other drivers
+			 * implementing get_txpower use that anyway */
+			seq_printf(s, "pwr_limit;%x\n", power_limit * 2);
+	}
+
+	/* Controllable feature information */
+	if (local->ops->get_feature_state && mp->hw->feature_ctrl) {
+		len = seq_get_buf(s, &buf_ref);
+		len = __orca_dump_features(mp, buf_ref, len);
+		seq_commit(s, len);
+	}
+
+	/* keep this block last! */
+	mutex_lock(&local->iflist_mtx);
+	list_for_each_entry(sdata, &local->interfaces, list) {
+        	char tmp[64] = {};
+		int ofs = 0;
+
+		seq_printf(s, "if;%s;", sdata->name);
+
+		if (sdata->orca_monitor & ORCA_MONITOR_TXS)
+			ofs += sprintf(tmp, "txs,");
+		if (sdata->orca_monitor & ORCA_MONITOR_RXS)
+			ofs += sprintf(tmp + ofs, "rxs,");
+		if (sdata->orca_monitor & ORCA_MONITOR_STATS)
+			ofs += sprintf(tmp + ofs, "stats,");
+		if (sdata->orca_monitor & ORCA_ECHO_TPRC)
+			ofs += sprintf(tmp + ofs, "tprc_echo,");
+
+		len = strlen(tmp);
+		if (len)
+			tmp[len - 1] = 0;
+
+        	seq_printf(s, "%s\n", tmp);
+	}
+	mutex_unlock(&local->iflist_mtx);
+
+	rcu_read_lock();
+	list_for_each_entry_rcu(mi, &mp->stations, list) {
+		len = seq_get_buf(s, &buf_ref);
+		len = __orca_dump_sta(mp, mi, buf_ref, len, NULL);
+		seq_commit(s, len);
+	}
+	rcu_read_unlock();
+
+	return 0;
+}
+
+static void
+orca_dump_sta(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,
+	      const char *type)
+{
+	/* see __orca_dump_sta for that size */
+	char info[128 + MINSTREL_GROUPS_NB * 4];
+	int count;
+
+	count = __orca_dump_sta(mp, mi, info, sizeof(info), type);
+
+	relay_write(mp->relay_ev, info, count);
+	relay_flush(mp->relay_ev);
+}
+
+static void
+orca_dump_stations(struct minstrel_priv *mp, const char *type)
+{
+	struct minstrel_ht_sta *mi;
+
+	rcu_read_lock();
+	spin_lock_bh(&mp->relay_lock);
+
+	list_for_each_entry_rcu(mi, &mp->stations, list)
+		orca_dump_sta(mp, mi, type);
+
+	spin_unlock_bh(&mp->relay_lock);
+	rcu_read_unlock();
+}
+
+static void
+orca_dump_features(struct minstrel_priv *mp)
+{
+	char buf[256];
+	unsigned int cnt, size = 256;
+
+	cnt = scnprintf(buf, size, "%llx;",
+			(unsigned long long)ktime_get_real_fast_ns());
+	cnt += __orca_dump_features(mp, buf + cnt, size - cnt);
+
+	spin_lock_bh(&mp->relay_lock);
+
+	relay_write(mp->relay_ev, buf, cnt);
+	relay_flush(mp->relay_ev);
+
+	spin_unlock_bh(&mp->relay_lock);
+}
+
+static int
+orca_get_args(char **dest, int dest_size, char *str, char *sep)
+{
+	int i, n;
+
+	for (i = 0, n = 0; i < dest_size; i++) {
+		if (!str) {
+			dest[i] = NULL;
+			continue;
+		}
+
+		dest[i] = strsep(&str, sep);
+		if (dest[i])
+			n++;
+	}
+
+	return n;
+}
+
+static inline void
+orca_event_write(struct minstrel_priv *mp, char *buf, unsigned int len)
+{
+	spin_lock_bh(&mp->relay_lock);
+	relay_write(mp->relay_ev, buf, len);
+	relay_flush(mp->relay_ev);
+	spin_unlock_bh(&mp->relay_lock);
+}
+
+static void
+orca_print_cmd(struct minstrel_priv *mp, orca_cmd cmd, char **args,
+	       int n_args, const char *fmt, ...)
+{
+	va_list vargs;
+	char buf[128];
+	int i, len;
+
+	len = scnprintf(buf, sizeof(buf), "%llx;%s",
+			(unsigned long long)ktime_get_real_fast_ns(),
+			ORCA_CMD_STR[cmd]);
+
+	if (strlen(fmt) > 0) {
+		len += scnprintf(buf + len, sizeof(buf) - len, ";");
+		va_start(vargs, fmt);
+		len += vscnprintf(buf + len, sizeof(buf) - len, fmt, vargs);
+		va_end(vargs);
+	}
+
+	for (i = 0; i < n_args; i++) {
+		len += scnprintf(buf + len, sizeof(buf) - len, ";%s", args[i]);
+	}
+	len += scnprintf(buf + len, sizeof(buf) - len, "\n");
+
+	orca_event_write(mp, buf, len);
+}
+
+#define orca_print_sta_cmd(mp, mi, cmd, args, n_args) \
+	orca_print_cmd(mp, cmd, args, n_args, "%pM", mi->sta->addr)
+#define orca_print_if_cmd(mp, sdata, cmd, args, n_args) \
+	orca_print_cmd(mp, cmd, args, n_args, "%s", sdata->name)
+
+static u8
+_parse_monitor_mask(char **params)
+{
+	char *cur;
+	u8 mask = 0;
+
+	if (!strcmp(*params, "*"))
+		return (u8)(~0U);
+
+	while ((cur = strsep(params, ",")) != NULL) {
+		if (!strlen(cur))
+			break;
+
+		if (!strcmp(cur, "txs"))
+			mask |= ORCA_MONITOR_TXS;
+		else if (!strcmp(cur, "rxs"))
+			mask |= ORCA_MONITOR_RXS;
+		else if (!strcmp(cur, "stats"))
+			mask |= ORCA_MONITOR_STATS;
+		else if (!strcmp(cur, "tprc_echo"))
+			mask |= ORCA_ECHO_TPRC;
+	}
+
+	return mask;
+}
+
+static int
+orca_start_monitoring(struct minstrel_priv *mp, char *params)
+{
+	struct ieee80211_local *local = hw_to_local(mp->hw);
+	struct ieee80211_sub_if_data *sdata;
+	char buf[32], *cur, *ref;
+	int ret, i = 0;
+	u8 mask;
+	bool all;
+
+	cur = strsep(&params, ";");
+	if (!cur)
+		return -EINVAL;
+
+	strncpy(buf, params, sizeof(buf));
+	buf[sizeof(buf) - 1] = 0;
+	ref = buf;
+
+	all = !strcmp(cur, "*");
+	ret = all ? 0 : -ENOENT;
+
+	mask = _parse_monitor_mask(&params);
+	mutex_lock(&local->iflist_mtx);
+	list_for_each_entry(sdata, &local->interfaces, list) {
+		if (all) {
+			sdata->orca_monitor |= mask;
+			orca_print_if_cmd(mp, sdata, PHY_CMD_START, &ref, 1);
+		} else if (!strcmp(sdata->name, cur)) {
+			sdata->orca_monitor |= mask;
+			orca_print_if_cmd(mp, sdata, PHY_CMD_START, &ref, 1);
+
+			ret = 0;
+			break;
+		}
+	}
+	mutex_unlock(&local->iflist_mtx);
+
+	return ret;
+}
+
+static int
+orca_stop_monitoring(struct minstrel_priv *mp, char *params)
+{
+	struct ieee80211_local *local = hw_to_local(mp->hw);
+	struct ieee80211_sub_if_data *sdata;
+	char buf[32], *cur, *ref;
+	int ret;
+	u8 mask;
+	bool all;
+
+	cur = strsep(&params, ";");
+	if (!cur)
+		return -EINVAL;
+
+	strncpy(buf, params, sizeof(buf));
+	buf[sizeof(buf) - 1] = 0;
+	ref = buf;
+
+	all = !strcmp(cur, "*");
+	ret = all ? 0 : -ENOENT;
+
+	mask = _parse_monitor_mask(&params);
+
+	mutex_lock(&local->iflist_mtx);
+	list_for_each_entry(sdata, &local->interfaces, list) {
+		if (all) {
+			sdata->orca_monitor &= ~mask;
+			orca_print_if_cmd(mp, sdata, PHY_CMD_STOP, &ref, 1);
+		} else if (!strcmp(sdata->name, cur)) {
+			sdata->orca_monitor &= ~mask;
+			orca_print_if_cmd(mp, sdata, PHY_CMD_STOP, &ref, 1);
+			ret = 0;
+			break;
+		}
+	}
+	mutex_unlock(&local->iflist_mtx);
+
+	/* TODO: can we omit this? it breaks output within upper loop */
+	//spin_lock_bh(&mp->relay_lock);
+	//relay_reset(mp->relay_ev);
+	//spin_unlock_bh(&mp->relay_lock);
+
+	return ret;
+}
+
+static void
+orca_reset_sample_table(struct minstrel_ht_sta *mi)
+{
+	int i;
+
+	for (i = 0; i < __MINSTREL_SAMPLE_TYPE_MAX; i++)
+		memset(mi->sample[i].sample_rates, 0,
+		       sizeof(mi->sample[i].sample_rates));
+
+	mi->sample_seq = 0;
+	mi->user_sample_rate = -1;
+	mi->user_sample_count = 0;
+	mi->user_sample_txpower = -1;
+}
+
+/**
+ * orca_is_phy_tpc_ready - check if TPC can be used for a PHY
+ *
+ * TPC is ready if hardware/driver supports it and it is enabled in
+ * the driver.
+ */
+static inline bool
+orca_is_phy_tpc_ready(struct ieee80211_hw *hw)
+{
+	struct ieee80211_local *local = hw_to_local(hw);
+
+	return (ieee80211_hw_check(hw, SUPPORTS_TPC_PER_PACKET) ||
+		ieee80211_hw_check(hw, SUPPORTS_TPC_PER_MRR)) &&
+		/*
+		 * this returns 1 for active, 0 for inactive and -1 for unsupported.
+		 * because hw_flag is set, assume it is always active in driver.
+		 */
+	       local->ops->get_feature_state(hw, IEEE80211_FTRCTRL_TPC);
+}
+
+static int
+orca_phy_set_feature(struct minstrel_priv *mp, char *arg_str)
+{
+	struct ieee80211_local *local = hw_to_local(mp->hw);
+	enum ieee80211_feature_ctrl feature = -1;
+	char *args[2];
+	int i, res;
+	u16 state;
+
+	orca_get_args(args, ARRAY_SIZE(args), arg_str, ";");
+	if (!args[0] || !args[1])
+		return -EINVAL;
+
+	if (!local->ops->set_feature_state)
+		return -EPERM;
+
+	/* This only works if feature_pretty and enum ieee80211_feature_ctrl
+	 * (in mac80211.h) are equally ordered! */
+	for (i = 0; i < ARRAY_SIZE(feature_pretty); i++) {
+		if (!strcmp(args[0], feature_pretty[i])) {
+			feature = i;
+			break;
+		}
+	}
+	if (feature == -1)
+		return -ENOENT;
+
+	res = kstrtou16(args[1], 16, &state);
+	if (res == -ERANGE || state == (unsigned int)S16_MIN)
+		return -ERANGE;
+	else if (res)
+		return -EINVAL;
+
+	if (!ieee80211_feature_ctrl_has(mp->hw, feature))
+		return -EPERM;
+
+	res = local->ops->set_feature_state(mp->hw, feature, (s16)state);
+	if (res)
+		return -EIO; /* TODO: more suitable error? */
+
+	orca_print_cmd(mp, PHY_CMD_SET_FEATURE, args, 2, "");
+	return 0;
+}
+
+static int
+orca_phy_get(struct minstrel_priv *mp, const char *args)
+{
+	struct ieee80211_local *local = hw_to_local(mp->hw);
+	char buf[64];
+	unsigned int len, size = 64;
+
+	if (!args)
+		return -EINVAL;
+
+	len = scnprintf(buf, size, "%llx;got;",
+			(unsigned long long)ktime_get_real_fast_ns());
+	if (!strcmp(args, "pwr-limit")) {
+		int txpwr = -1;
+
+		if (!local->ops->get_txpower)
+			return -EOPNOTSUPP;
+
+		local->ops->get_txpower(mp->hw, NULL, &txpwr);
+		txpwr *= 2;
+
+		len += scnprintf(buf + len, size - len, "pwr-limit;%x", txpwr);
+	} else {
+		return -EINVAL;
+	}
+
+	len += scnprintf(buf + len, size - len, "\n");
+	orca_event_write(mp, buf, len);
+
+	return 0;
+}
+
+static int
+orca_sta_set_rc_mode(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,
+		     char **args, int n_args)
+{
+	u16 update_freq, sample_freq;
+	int i;
+
+	if (!n_args || !args[0])
+		return -EINVAL;
+	if (!mi->ratetbl)
+		return -EFAULT;
+
+	if (!strcmp(args[0], "manual"))
+		mi->rc_manual = true;
+	else if (!strcmp(args[0], "auto"))
+		mi->rc_manual = false;
+	else
+		return -EINVAL;
+
+	orca_reset_sample_table(mi);
+	for (i = 0; i < ARRAY_SIZE(mi->ratetbl->rate); i++) {
+		mi->ratetbl->rate[i].idx = -1;
+		mi->ratetbl->rate[i].count = 0;
+		mi->ratetbl->rate[i].count_rts = 0;
+		mi->ratetbl->rate[i].count_cts = 0;
+	}
+
+	if (args[1]) {
+		if (kstrtou16(args[1], 16, &update_freq))
+			return -EINVAL;
+		if (!update_freq || update_freq > HZ)
+			return -ERANGE;
+
+		mi->update_interval = HZ / update_freq;
+	}
+	if (args[2]) {
+		if (kstrtou16(args[2], 16, &sample_freq))
+			return -EINVAL;
+		if (!sample_freq || sample_freq > HZ)
+			return -ERANGE;
+
+		mi->sample_interval = HZ / sample_freq;
+	}
+
+	orca_print_sta_cmd(mp, mi, STA_CMD_RC_MODE, args, n_args);
+	return 0;
+}
+
+static int
+orca_sta_set_tpc_mode(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,
+		      char *mode)
+{
+	int i;
+
+	if (!orca_is_phy_tpc_ready(mp->hw))
+		return -EPERM;
+
+	if (!mode)
+		return -EINVAL;
+	if (!mi->ratetbl)
+		return -EFAULT;
+
+	if (!strcmp(mode, "manual"))
+		mi->tpc_manual = true;
+	else if (!strcmp(mode, "auto"))
+		mi->tpc_manual = false;
+	else
+		return -EINVAL;
+
+	for (i = 0; i < ARRAY_SIZE(mi->ratetbl->rate); i++)
+		mi->ratetbl->rate[i].txpower_idx = -1;
+
+	orca_print_sta_cmd(mp, mi, STA_CMD_TPC_MODE, &mode, 1);
+	return 0;
+}
+
+static struct minstrel_ht_sta *
+orca_get_sta(struct minstrel_priv *mp, const u8 *macaddr)
+{
+	struct minstrel_ht_sta *mi;
+
+	rcu_read_lock();
+	list_for_each_entry_rcu(mi, &mp->stations, list) {
+		if (!memcmp(mi->sta->addr, macaddr, ETH_ALEN))
+			goto out;
+	}
+	mi = NULL;
+
+out:
+	rcu_read_unlock();
+	return mi;
+}
+
+static bool
+orca_is_valid_rate(struct minstrel_ht_sta *mi, u32 rate)
+{
+	int group, idx;
+
+	group = MI_RATE_GROUP(rate);
+	if (group >= MINSTREL_GROUPS_NB)
+		return false;
+
+	idx = MI_RATE_IDX(rate);
+
+	return !!(mi->supported[group] & BIT(idx));
+}
+
+static int
+orca_rate_from_str(struct minstrel_ht_sta *mi, const char *str)
+{
+	unsigned int rate;
+
+	if (kstrtouint(str, 16, &rate))
+		return -EINVAL;
+
+	if (!orca_is_valid_rate(mi, rate))
+		return -EINVAL;
+
+	return rate;
+}
+
+static int
+orca_set_probe(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,
+	       char *arg_str)
+{
+	struct sta_info *sta_info;
+	char tmp[16], *args[3];
+	unsigned int count;
+	int rate;
+	u16 raw_txpwr;
+	s16 max_power, txpwr = -1;
+
+	if (!arg_str)
+		return -EINVAL;
+	if (!mi->rc_manual)
+		return -EPERM;
+
+	strncpy(tmp, arg_str, sizeof(tmp));
+	tmp[sizeof(tmp) - 1] = 0;
+	orca_get_args(args, ARRAY_SIZE(args), tmp, ",");
+
+	rate = orca_rate_from_str(mi, args[0]);
+	if (rate < 0)
+		return rate;
+
+	if (!args[1] || kstrtouint(args[1], 16, &count))
+		return -EINVAL;
+
+	if (args[2]) {
+		if (!mi->tpc_manual)
+			return -EPERM;
+
+		max_power = ieee80211_hw_get_max_txpower_idx(mp->hw);
+		if (kstrtou16(args[2], 16, &raw_txpwr))
+			return -EINVAL;
+
+		txpwr = (raw_txpwr <= S16_MAX) ? (s16)raw_txpwr : -1;
+		if (txpwr > max_power)
+			return -ERANGE;
+	}
+
+	mi->user_sample_rate = rate;
+	mi->user_sample_count = count;
+	mi->user_sample_txpower = txpwr;
+
+	sta_info = container_of(mi->sta, struct sta_info, sta);
+	if (sta_info->sdata->orca_monitor && ORCA_ECHO_TPRC)
+		orca_print_sta_cmd(mp, mi, STA_CMD_PROBE, &arg_str, 1);
+
+	return 0;
+}
+
+static int
+orca_ratetbl_set_rate_count(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,
+			    char *rate_str, char *count_str, unsigned int stage)
+{
+	unsigned int count;
+	int rate;
+
+	if (!rate_str || !count_str)
+		return -EINVAL;
+
+	rate = orca_rate_from_str(mi, rate_str);
+	if (rate < 0)
+		return -EINVAL;
+
+	if (kstrtouint(count_str, 16, &count))
+		return -EINVAL;
+
+	minstrel_ht_set_rate(mp, mi, mi->ratetbl, stage, rate);
+	mi->ratetbl->rate[stage].count = count;
+	mi->ratetbl->rate[stage].count_rts = count;
+	mi->ratetbl->rate[stage].count_cts = count;
+
+	return 0;
+}
+
+static int
+orca_ratetbl_set_txpower(struct minstrel_ht_sta *mi, char *txpwr_str,
+			 int stage, s16 max_power)
+{
+	u16 raw;
+	s16 txpwr;
+
+	if (!txpwr_str || kstrtou16(txpwr_str, 16, &raw))
+		return -EINVAL;
+
+	txpwr = (raw <= S16_MAX) ? (s16)raw : -1;
+	if (txpwr > max_power)
+		return -ERANGE;
+
+	mi->ratetbl->rate[stage].txpower_idx = txpwr;
+	return 0;
+}
+
+static int
+orca_set_ratetbl(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,
+		 orca_cmd cmd, char **args, unsigned int n_args)
+{
+	struct sta_info *sta_info;
+	char tmp[16], *stage[3];
+	int i, err = 0;
+	s16 max_txpwr;
+	bool rc, tpc;
+
+	if (!args || !n_args)
+		return -EINVAL;
+
+	rc = (cmd == STA_CMD_RC || cmd == STA_CMD_TPRC);
+	tpc = (cmd == STA_CMD_TPC || cmd == STA_CMD_TPRC);
+
+	if ((rc && !orca_sta_rc_manual_mode(mi)) ||
+	    (tpc && (!orca_is_phy_tpc_ready(mp->hw) || !orca_sta_tpc_manual_mode(mi))))
+		return -EPERM;
+
+	if (tpc)
+		max_txpwr = ieee80211_hw_get_max_txpower_idx(mp->hw);
+
+	for (i = 0; i < min_t(unsigned int, n_args, ARRAY_SIZE(mi->ratetbl->rate)); i++) {
+		int j = 0;
+
+		/* not doing this in-place due to echo feature! */
+		strncpy(tmp, args[i], sizeof(tmp));
+		tmp[sizeof(tmp) - 1] = 0;
+
+		orca_get_args(stage, ARRAY_SIZE(stage), tmp, ",");
+
+		if (rc) {
+			err = orca_ratetbl_set_rate_count(mp, mi, stage[0],
+							  stage[1], i);
+			if (err)
+				return err;
+
+			j = 2;
+		}
+
+		if (!tpc)
+			continue;
+
+		err = orca_ratetbl_set_txpower(mi, stage[j], i, max_txpwr);
+		if (err)
+			return err;
+	}
+	if (!i)
+		return -EINVAL;
+
+	for (; i < ARRAY_SIZE(mi->ratetbl->rate); i++) {
+		mi->ratetbl->rate[i].idx = -1;
+		mi->ratetbl->rate[i].count = 0;
+		mi->ratetbl->rate[i].txpower_idx = -1;
+	}
+
+	minstrel_ht_update_rates(mp, mi, false);
+
+	sta_info = container_of(mi->sta, struct sta_info, sta);
+	if (sta_info->sdata->orca_monitor && ORCA_ECHO_TPRC)
+		orca_print_sta_cmd(mp, mi, cmd, args, n_args);
+
+	return err;
+}
+
+static void
+orca_sta_reset_rc_stats(struct minstrel_priv *mp, struct minstrel_ht_sta *mi)
+{
+	mi->ampdu_len = 0;
+	mi->ampdu_packets = 0;
+	mi->avg_ampdu_len = MINSTREL_FRAC(1, 1);
+	memset(&mi->max_tp_rate, 0, sizeof(mi->max_tp_rate));
+	mi->max_prob_rate = 0;
+	mi->total_packets = 0;
+	mi->sample_packets = 0;
+	mi->sample_rate = 0;
+	memset(&mi->sample, 0, sizeof(mi->sample));
+	memset(&mi->groups, 0, sizeof(mi->groups));
+
+	minstrel_ht_update_stats(mp, mi);
+	orca_print_sta_cmd(mp, mi, STA_CMD_RESET_STATS, NULL, 0);
+}
+
+static int
+__orca_sta_cmd(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,
+	       orca_cmd cmd, char **args, unsigned int n_args)
+{
+	int ret = 0;
+
+	spin_lock_bh(&mi->lock);
+
+	switch (cmd) {
+	case STA_CMD_PROBE:
+		ret = orca_set_probe(mp, mi, args[0]);
+		break;
+	case STA_CMD_RC:
+	case STA_CMD_TPC:
+	case STA_CMD_TPRC:
+		ret = orca_set_ratetbl(mp, mi, cmd, args, n_args);
+		break;
+	case STA_CMD_RC_MODE:
+		ret = orca_sta_set_rc_mode(mp, mi, args, n_args);
+		break;
+	case STA_CMD_TPC_MODE:
+		ret = orca_sta_set_tpc_mode(mp, mi, args[0]);
+		break;
+	case STA_CMD_RESET_STATS:
+		orca_sta_reset_rc_stats(mp, mi);
+		break;
+	default:
+		ret = -EINVAL;
+	}
+
+	spin_unlock_bh(&mi->lock);
+	return ret;
+}
+
+static int
+orca_sta_cmd(struct minstrel_priv *mp, orca_cmd cmd, char *arg_str)
+{
+	struct minstrel_ht_sta *mi;
+	uint8_t macaddr[ETH_ALEN];
+	char *args[5];
+	int n_args, ret = 0;
+
+	n_args = orca_get_args(args, ARRAY_SIZE(args), arg_str, ";");
+	if (!args[0])
+		return -EINVAL;
+
+	if (!strcmp(args[0], "*")) {
+		switch (cmd) {
+		case STA_CMD_RC_MODE:
+		case STA_CMD_TPC_MODE:
+		case STA_CMD_RESET_STATS:
+			rcu_read_lock();
+			list_for_each_entry_rcu(mi, &mp->stations, list) {
+				if ((ret = __orca_sta_cmd(mp, mi, cmd, &args[1], n_args - 1)))
+					break;
+			}
+			rcu_read_unlock();
+			break;
+		default:
+			/* TPRC commands will fail due to how args are handled in orca_set_ratetbl! */
+			ret = -EPERM;
+		}
+	} else {
+		if (!mac_pton(args[0], macaddr))
+			return -EINVAL;
+
+		mi = orca_get_sta(mp, macaddr);
+		if (!mi)
+			return -ENOENT;
+
+		ret = __orca_sta_cmd(mp, mi, cmd, &args[1], n_args - 1);
+	}
+	return ret;
+}
+
+static int
+orca_process_cmd(struct minstrel_priv *mp, orca_cmd cmd, char *args)
+{
+	char buf[128];
+	int err = 0;
+
+	switch (cmd) {
+	case STA_CMD_RC:
+	case STA_CMD_TPC:
+	case STA_CMD_TPRC:
+	case STA_CMD_PROBE:
+	case STA_CMD_RC_MODE:
+	case STA_CMD_TPC_MODE:
+	case STA_CMD_RESET_STATS:
+		err = orca_sta_cmd(mp, cmd, args);
+		break;
+	case PHY_CMD_START:
+		err = orca_start_monitoring(mp, args);
+		break;
+	case PHY_CMD_STOP:
+		err = orca_stop_monitoring(mp, args);
+		break;
+	case PHY_CMD_DUMP:
+		orca_dump_stations(mp, "dump");
+		break;
+	case PHY_CMD_DUMP_FEATURES:
+		orca_dump_features(mp);
+		break;
+	case PHY_CMD_GET:
+		err = orca_phy_get(mp, args);
+		break;
+	case PHY_CMD_SET_FEATURE:
+		err = orca_phy_set_feature(mp, args);
+		break;
+	default:
+		err = -EINVAL;
+	}
+
+	return err;
+}
+
+static ssize_t
+orca_control_write(struct file *file, const char __user *userbuf, size_t count,
+		   loff_t *ppos)
+{
+	struct minstrel_priv *mp = file->private_data;
+	char buf[96], *pos, *cur;
+	size_t len = count;
+	int cmd = -1, i, err;
+
+	if (len > sizeof(buf) - 1)
+		return -EMSGSIZE;
+	if (copy_from_user(buf, userbuf, len))
+		return -EFAULT;
+	if (count > 0 && buf[len - 1] == '\n')
+		len--;
+
+	buf[len] = 0;
+	if (!len)
+		return count;
+
+	pos = buf;
+	cur = strsep(&pos, ";");
+	for (i = 0; i < NUM_API_CMDS; i++) {
+		if (!strcmp(cur, ORCA_CMD_STR[i])) {
+			cmd = i;
+			break;
+		}
+	}
+	if (cmd == -1)
+		return -EINVAL;
+
+	err = orca_process_cmd(mp, cmd, pos);
+	if (err)
+		return err;
+
+	return count;
+}
+
+static const struct file_operations fops_control = {
+	.open = simple_open,
+	.llseek = generic_file_llseek,
+	.write = orca_control_write,
+};
+
+void orca_sta_update(struct minstrel_priv *mp, struct minstrel_ht_sta *mi)
+{
+	bool add = list_empty(&mi->list);
+
+	if (add) {
+		spin_lock_bh(&mp->sta_wlock);
+		list_add_rcu(&mi->list, &mp->stations);
+		spin_unlock_bh(&mp->sta_wlock);
+	}
+
+	spin_lock_bh(&mp->relay_lock);
+	orca_dump_sta(mp, mi, add ? "add" : "update");
+	spin_unlock_bh(&mp->relay_lock);
+}
+
+void orca_sta_remove(struct minstrel_priv *mp, struct minstrel_ht_sta *mi)
+{
+	struct ieee80211_sta_rates *ratetbl = mi->ratetbl;
+	char info[64];
+	int ofs = 0;
+
+	spin_lock_bh(&mp->sta_wlock);
+
+	list_del_rcu(&mi->list);
+	INIT_LIST_HEAD_RCU(&mi->list);
+
+	spin_lock(&mi->lock);
+
+	mi->ratetbl = NULL;
+	kfree(ratetbl);
+
+	spin_unlock(&mi->lock);
+	spin_unlock_bh(&mp->sta_wlock);
+
+	ofs = scnprintf(info, sizeof(info), "%llx;sta;remove;%pM;;;\n",
+			(unsigned long long)ktime_get_real_fast_ns(),
+			mi->sta->addr);
+
+	spin_lock_bh(&mp->relay_lock);
+
+	relay_write(mp->relay_ev, info, ofs);
+	relay_flush(mp->relay_ev);
+
+	spin_unlock_bh(&mp->relay_lock);
+}
+
+void __orca_report_tx_status(struct minstrel_priv *mp,
+			     struct minstrel_ht_sta *mi,
+			     struct ieee80211_tx_info *info,
+			     u16 *rate_list, s16 *txpwr_list, int n_rates)
+{
+	char txs[64 + IEEE80211_TX_MAX_RATES * 14];
+	int ofs = 0;
+	int i;
+
+	if (!n_rates)
+		return;
+
+	ofs += scnprintf(txs, sizeof(txs), "%llx;txs;%pM;%x;%x;%x",
+			 (unsigned long long)ktime_get_real_fast_ns(),
+			 mi->sta->addr,
+			 info->status.ampdu_len,
+			 info->status.ampdu_ack_len,
+			 !!(info->flags & IEEE80211_TX_CTL_RATE_CTRL_PROBE));
+
+	for (i = 0; i < n_rates; i++) {
+		ofs += scnprintf(txs + ofs, sizeof(txs) - ofs, ";%x,%x,",
+				 rate_list[i], info->status.rates[i].count);
+		if (txpwr_list[i] < 0)
+			continue;
+
+		ofs += scnprintf(txs + ofs, sizeof(txs) - ofs, "%x",
+				 (u16)(txpwr_list[i]));
+	}
+
+	for (; i < IEEE80211_TX_MAX_RATES; i++) {
+		ofs += scnprintf(txs + ofs, sizeof(txs) - ofs, ";,,");
+	}
+	ofs += scnprintf(txs + ofs, sizeof(txs) - ofs, "\n");
+
+	orca_event_write(mp, txs, ofs);
+}
+
+void __orca_report_rx_status(struct minstrel_priv *mp, u8 *addr, s8 last_signal,
+			     u8 chain_status, s8 *chain_signal)
+{
+	char rxs[64 + IEEE80211_MAX_CHAINS * 8];
+	int ofs = 0;
+	int i;
+
+	/* Cast signal to u8 to avoid having ffffff for negative values */
+	ofs += scnprintf(rxs, sizeof(rxs), "%llx;rxs;%pM;%x",
+			 (unsigned long long)ktime_get_real_fast_ns(),
+			 addr, (u8)last_signal);
+
+	for (i = 0; i < IEEE80211_MAX_CHAINS; i++) {
+		ofs += scnprintf(rxs + ofs, sizeof(rxs) - ofs, ";%x",
+			 	(chain_status & BIT(i) ? (u8)chain_signal[i] : 0x7f));
+	}
+	ofs += scnprintf(rxs + ofs, sizeof(rxs) - ofs, "\n");
+
+	orca_event_write(mp, rxs, ofs);
+}
+
+void __orca_report_rate_update(struct minstrel_priv *mp,
+			       struct minstrel_ht_sta *mi, u16 rate,
+			       struct minstrel_rate_stats *mrs)
+{
+	char stat[100];
+	int ofs;
+	int tp;
+
+	tp = minstrel_ht_get_tp_avg(mi, MI_RATE_GROUP(rate), MI_RATE_IDX(rate),
+				    mrs->prob_avg);
+
+	ofs = scnprintf(stat, sizeof(stat),
+			"%llx;stats;%pM;%x;%x;%x;%x;%x;%x;%x\n",
+			(unsigned long long)ktime_get_real_fast_ns(),
+			mi->sta->addr, rate,
+			MINSTREL_TRUNC(mrs->prob_avg * 1000), tp,
+			mrs->last_success,
+			mrs->last_attempts,
+			mrs->succ_hist, mrs->att_hist);
+
+	orca_event_write(mp, stat, ofs);
+}
+
+void __orca_report_best_rates(struct minstrel_priv *mp,
+			      struct minstrel_ht_sta *mi)
+{
+	char line[128];
+	int i, ofs;
+
+	ofs = scnprintf(line, sizeof(line), "%llx;best_rates;%pM",
+	                (unsigned long long)ktime_get_real_fast_ns(),
+	                mi->sta->addr);
+
+	for (i = 0; i < MAX_THR_RATES; i++) {
+		ofs += scnprintf(line + ofs, sizeof(line), ";%x", mi->max_tp_rate[i]);
+	}
+	ofs += scnprintf(line + ofs, sizeof(line), ";%x\n", mi->max_prob_rate);
+
+	orca_event_write(mp, line, ofs);
+}
+
+void __orca_report_estimated_throughput(struct minstrel_priv *mp,
+					struct minstrel_ht_sta *mi)
+{
+	struct minstrel_rate_stats *mrs;
+	char line[128];
+	int group, idx, tp, ofs;
+
+	group = MI_RATE_GROUP(mi->max_tp_rate[0]);
+	idx = MI_RATE_IDX(mi->max_tp_rate[0]);
+	mrs = &mi->groups[group].rates[idx];
+	tp = minstrel_ht_get_tp_avg(mi, group, idx, mrs->prob_avg);
+
+	ofs = scnprintf(line, sizeof(line), "%llx;est_tp;%pM;%x\n",
+			(unsigned long long)ktime_get_real_fast_ns(),
+			mi->sta->addr, tp);
+
+	orca_event_write(mp, line, ofs);
+}
+
+void __orca_report_sample_rates(struct minstrel_priv *mp,
+				struct minstrel_ht_sta *mi)
+{
+	char line[128];
+	int i, j, ofs;
+
+	ofs = scnprintf(line, sizeof(line), "%llx;sample_rates;%pM",
+			(unsigned long long)ktime_get_real_fast_ns(),
+			mi->sta->addr);
+
+	for (i = 0; i < __MINSTREL_SAMPLE_TYPE_MAX; i++) {
+		for (j = 0; j < MINSTREL_SAMPLE_RATES; j++) {
+			ofs += scnprintf(line + ofs, sizeof(line), ";%x",
+					 mi->sample[i].cur_sample_rates[j]);
+		}
+	}
+	ofs += scnprintf(line + ofs, sizeof(line), "\n");
+
+	orca_event_write(mp, line, ofs);
+}
+
+static struct dentry *
+create_buf_file_cb(const char *filename, struct dentry *parent, umode_t mode,
+		   struct rchan_buf *buf, int *is_global)
+{
+	struct dentry *f;
+
+	f = debugfs_create_file("api_event", mode, parent, buf,
+				&relay_file_operations);
+	if (IS_ERR(f))
+		return NULL;
+
+	*is_global = 1;
+
+	return f;
+}
+
+static int
+remove_buf_file_cb(struct dentry *f)
+{
+	debugfs_remove(f);
+
+	return 0;
+}
+
+static struct rchan_callbacks relay_ev_cb = {
+	.create_buf_file = create_buf_file_cb,
+	.remove_buf_file = remove_buf_file_cb,
+};
+
+void orca_add_debugfs_api(struct ieee80211_hw *hw, void *priv, struct dentry *dir)
+{
+	struct minstrel_priv *mp = priv;
+
+	BUILD_BUG_ON(ARRAY_SIZE(feature_pretty) != NUM_IEEE80211_FTRCTRL);
+
+	spin_lock_init(&mp->relay_lock);
+	spin_lock_init(&mp->sta_wlock);
+
+	INIT_LIST_HEAD_RCU(&mp->stations);
+	mp->relay_ev = relay_open("api_event", dir, 256, 512, &relay_ev_cb,
+				  NULL);
+	debugfs_create_devm_seqfile(&hw->wiphy->dev, "api_info",
+				    dir, orca_read_api_info);
+	debugfs_create_devm_seqfile(&hw->wiphy->dev, "api_phy",
+				    dir, orca_read_phy_info);
+	debugfs_create_file("api_control", 0200, dir, mp, &fops_control);
+}
+
+void orca_remove_debugfs_api(void *priv)
+{
+	struct minstrel_priv *mp = priv;
+
+	spin_lock_bh(&mp->relay_lock);
+	if (mp->relay_ev)
+		relay_close(mp->relay_ev);
+
+	spin_unlock_bh(&mp->relay_lock);
+}
--- a/net/mac80211/ieee80211_i.h
+++ b/net/mac80211/ieee80211_i.h
@@ -1171,6 +1171,9 @@ struct ieee80211_sub_if_data {
 		struct dentry *default_beacon_key;
 	} debugfs;
 #endif
+#ifdef CPTCFG_MAC80211_ORCA_UAPI
+	u8 orca_monitor;
+#endif
 
 	/* must be last, dynamically sized area in this! */
 	struct ieee80211_vif vif;
