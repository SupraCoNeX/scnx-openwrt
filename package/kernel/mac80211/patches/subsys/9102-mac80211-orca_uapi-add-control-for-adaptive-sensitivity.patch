--- a/net/mac80211/orca_uapi.c
+++ b/net/mac80211/orca_uapi.c
@@ -21,6 +21,7 @@ enum api_cmd {
 	PHY_CMD_START,
 	PHY_CMD_STOP,
 	PHY_CMD_DUMP,
+	PHY_CMD_SET_FEATURE,
 
 	/* per-STA commands */
 	STA_CMD_RC_MODE,
@@ -384,6 +385,47 @@ orca_reset_sample_table(struct minstrel_
 }
 
 static int
+orca_phy_set_feature(struct minstrel_priv *mp, char *args)
+{
+	struct ieee80211_local *local = hw_to_local(mp->hw);
+	enum ieee80211_feature_ctrl feature;
+	char *feature_str, *arg;
+	int res;
+	bool enable;
+
+	/* We need at least the feature name and one argument */
+	feature_str = strsep(&args, ";");
+	arg = strsep(&args, ";");
+	if (!feature_str || !arg)
+		return -EINVAL;
+
+	if (!strcmp(arg, "on"))
+		enable = true;
+	else if (!strcmp(arg, "off"))
+		enable = false;
+	else
+		return -EPERM;
+
+	if (!local->ops->set_feature_state)
+		return -EPERM;
+
+	if (!strcmp(feature_str, "adaptive_sens"))
+		feature = IEEE80211_FTRCTRL_ADAPTIVE_SENSITIVITY;
+	else
+		return -ENOENT;
+
+	/* Check if the hardware/driver supports the given feature ctrl */
+	if (!(mp->hw->feature_ctrl & feature))
+		return -EPERM;
+
+	res = local->ops->set_feature_state(mp->hw, feature, enable);
+	if (!res)
+		return -EIO; /* TODO: more suitable error? */
+
+	return 0;
+}
+
+static int
 orca_sta_set_rc_mode(struct minstrel_ht_sta *mi, char *mode)
 {
 	int i;
@@ -766,6 +808,9 @@ orca_exec_cmd(struct minstrel_priv *mp,
 	case STA_CMD_PROBE:
 		err = orca_sta_cmd(mp, cmd, args);
 		break;
+	case PHY_CMD_SET_FEATURE:
+		err = orca_phy_set_feature(mp, args);
+		break;
 	default:
 		err = -EINVAL;
 	}
@@ -855,6 +900,8 @@ orca_control_write(struct file *file, co
 		cmd = STA_CMD_TPC_MODE;
 	} else if (!strcmp(cur, "reset_stats")) {
 		cmd = STA_CMD_RESET_STATS;
+	} else if (!strcmp(cur, "set_feature")) {
+		cmd = PHY_CMD_SET_FEATURE;
 	} else {
 		return -EINVAL;
 	}
