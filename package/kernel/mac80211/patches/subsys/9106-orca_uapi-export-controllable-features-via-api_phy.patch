--- a/net/mac80211/orca_uapi.c
+++ b/net/mac80211/orca_uapi.c
@@ -177,8 +177,9 @@ orca_read_phy_info(struct seq_file *s, v
 	struct sta_info *sta_info;
 	struct minstrel_priv *mp = local->rate_ctrl->priv;
 	struct minstrel_ht_sta *mi;
-	char tmp[32] = {};
-	int len, ofs = 0;
+	char tmp_on[64] = {};
+	char tmp_off[64] = {};
+	int len, ofs_on = 0, ofs_off = 0;
 	int i = 0;
 
 	seq_printf(s, "drv;%s\n", wiphy_dev(wiphy)->driver->name);
@@ -213,22 +214,55 @@ orca_read_phy_info(struct seq_file *s, v
 	seq_printf(s, "\n");
 
 skip_tpc:
-
+	/* Current monitor modes states */
 	if (mp->monitor & ORCA_MONITOR_TXS)
-		ofs += sprintf(tmp, "txs,");
+		ofs_on += sprintf(tmp_on, "txs,");
 	if (mp->monitor & ORCA_MONITOR_RXS)
-		ofs += sprintf(tmp + ofs, "rxs,");
+		ofs_on += sprintf(tmp_on + ofs_on, "rxs,");
 	if (mp->monitor & ORCA_MONITOR_STATS)
-		ofs += sprintf(tmp + ofs, "stats,");
+		ofs_on += sprintf(tmp_on + ofs_on, "stats,");
 	if (mp->monitor & ORCA_ECHO_TPRC)
-		ofs += sprintf(tmp + ofs, "tprc_echo,");
+		ofs_on += sprintf(tmp_on + ofs_on, "tprc_echo,");
+
+	len = strlen(tmp_on);
+	if (len)
+		tmp_on[len - 1] = 0;
+
+	seq_printf(s, "mon;%s\n", tmp_on);
+
+	/* Controllable feature information */
+	if (!local->ops->get_feature_state)
+		goto skip_ftrs;
+
+	tmp_on[0] = 0;
+	ofs_on = 0;
+	if (ieee80211_hw_check(mp->hw, ADAPTIVE_SENSITIVITY_CTRL)) {
+		if (local->ops->get_feature_state(mp->hw, IEEE80211_FEAT_ADAPTIVE_SENSITIVITY))
+			ofs_on += sprintf(tmp_on, "adaptive_sens,");
+		else
+			ofs_off += sprintf(tmp_off, "adaptive_sens,");
+	}
+	if (ieee80211_hw_check(mp->hw, SUPPORTS_TPC_PER_PACKET) ||
+	    ieee80211_hw_check(mp->hw, SUPPORTS_TPC_PER_MRR))
+	{
+		if (local->ops->get_feature_state(mp->hw, IEEE80211_FEAT_TPC))
+			ofs_on += sprintf(tmp_on + ofs_on, "tpc,");
+		else
+			ofs_off += sprintf(tmp_off + ofs_off, "tpc,");
+	}
+
+	len = strlen(tmp_on);
+	if (len)
+		tmp_on[len - 1] = 0;
 
-	len = strlen(tmp);
+	len = strlen(tmp_off);
 	if (len)
-		tmp[len - 1] = 0;
+		tmp_off[len - 1] = 0;
 
-	seq_printf(s, "mon;%s\n", tmp);
+	seq_printf(s, "ftrs;on;%s\n", tmp_on);
+	seq_printf(s, "ftrs;off;%s\n", tmp_off);
 
+skip_ftrs:
 	/* keep this block last! */
 	rcu_read_lock();
 	list_for_each_entry_rcu(mi, &mp->stations, list) {
