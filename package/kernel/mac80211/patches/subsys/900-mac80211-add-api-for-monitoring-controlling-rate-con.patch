From ad045a0f171b56773cf41fdaf4f0dd315901ee70 Mon Sep 17 00:00:00 2001
From: Felix Fietkau <nbd@nbd.name>
Date: Mon, 20 Feb 2023 10:10:00 +0100
Subject: [PATCH] mac80211: add api for monitoring/controlling rate control
 from user space

Signed-off-by: Felix Fietkau <nbd@nbd.name>
---
 net/mac80211/Kconfig                   |   9 +
 net/mac80211/Makefile                  |   3 +
 net/mac80211/rc80211_minstrel_ht.c     | 142 ++++-
 net/mac80211/rc80211_minstrel_ht.h     | 139 +++++
 net/mac80211/rc80211_minstrel_ht_api.c | 757 +++++++++++++++++++++++++
 net/mac80211/rx.c                      |   7 +
 6 files changed, 1041 insertions(+), 16 deletions(-)
 create mode 100644 net/mac80211/rc80211_minstrel_ht_api.c

--- a/net/mac80211/Kconfig
+++ b/net/mac80211/Kconfig
@@ -29,6 +29,15 @@ config MAC80211_RC_MINSTREL
 	help
 	  This option enables the 'minstrel' TX rate control algorithm
 
+config MAC80211_RC_MINSTREL_DEBUGFS_API
+	bool "Minstrel debugfs userspace control API"
+	depends on MAC80211_RC_MINSTREL
+	depends on MAC80211_DEBUGFS
+	select RELAY
+	help
+	  This option creates debugfs files that allow user space to observe
+	  and/or control minstrel rate selection behavior
+
 choice
 	prompt "Default rate control algorithm"
 	depends on MAC80211_HAS_RC
--- a/net/mac80211/Makefile
+++ b/net/mac80211/Makefile
@@ -63,6 +63,9 @@ rc80211_minstrel-y := \
 rc80211_minstrel-$(CPTCFG_MAC80211_DEBUGFS) += \
 	rc80211_minstrel_ht_debugfs.o
 
+rc80211_minstrel-$(CPTCFG_MAC80211_RC_MINSTREL_DEBUGFS_API) += \
+	rc80211_minstrel_ht_api.o
+
 mac80211-$(CPTCFG_MAC80211_RC_MINSTREL) += $(rc80211_minstrel-y)
 
 ccflags-y += -DDEBUG
--- a/net/mac80211/rc80211_minstrel_ht.c
+++ b/net/mac80211/rc80211_minstrel_ht.c
@@ -264,7 +264,7 @@ const struct mcs_group minstrel_mcs_grou
 
 const s16 minstrel_cck_bitrates[4] = { 10, 20, 55, 110 };
 const s16 minstrel_ofdm_bitrates[8] = { 60, 90, 120, 180, 240, 360, 480, 540 };
-static u8 sample_table[SAMPLE_COLUMNS][MCS_GROUP_RATES] __read_mostly;
+u8 sample_table[SAMPLE_COLUMNS][MCS_GROUP_RATES] __read_mostly;
 static const u8 minstrel_sample_seq[] = {
 	MINSTREL_SAMPLE_TYPE_INC,
 	MINSTREL_SAMPLE_TYPE_JUMP,
@@ -275,7 +275,8 @@ static const u8 minstrel_sample_seq[] =
 };
 
 static void
-minstrel_ht_update_rates(struct minstrel_priv *mp, struct minstrel_ht_sta *mi);
+minstrel_ht_update_rates(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,
+			 bool force);
 
 /*
  * Some VHT MCSes are invalid (when Ndbps / Nes is not an integer)
@@ -368,7 +369,7 @@ minstrel_vht_ri_get_group_idx(struct rat
 
 static struct minstrel_rate_stats *
 minstrel_ht_get_stats(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,
-		      struct ieee80211_tx_rate *rate)
+		      struct ieee80211_tx_rate *rate, u16 *dest_idx)
 {
 	int group, idx;
 
@@ -406,6 +407,7 @@ minstrel_ht_get_stats(struct minstrel_pr
 
 	idx = 0;
 out:
+	*dest_idx = MI_RATE(group, idx);
 	return &mi->groups[group].rates[idx];
 }
 
@@ -414,7 +416,8 @@ out:
  */
 static struct minstrel_rate_stats *
 minstrel_ht_ri_get_stats(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,
-			  struct ieee80211_rate_status *rate_status)
+			 struct ieee80211_rate_status *rate_status,
+			 u16 *dest_idx)
 {
 	int group, idx;
 	struct rate_info *rate = &rate_status->rate_idx;
@@ -450,6 +453,7 @@ minstrel_ht_ri_get_stats(struct minstrel
 
 	idx = 0;
 out:
+	*dest_idx = MI_RATE(group, idx);
 	return &mi->groups[group].rates[idx];
 }
 
@@ -1025,7 +1029,7 @@ minstrel_ht_refill_sample_rates(struct m
  *  - as long as the max prob rate has a probability of more than 75%, pick
  *    higher throughput rates, even if the probablity is a bit lower
  */
-static void
+void
 minstrel_ht_update_stats(struct minstrel_priv *mp, struct minstrel_ht_sta *mi)
 {
 	struct minstrel_mcs_group_data *mg;
@@ -1089,6 +1093,8 @@ minstrel_ht_update_stats(struct minstrel
 			tp_rate = tmp_legacy_tp_rate;
 
 		for (i = MCS_GROUP_RATES - 1; i >= 0; i--) {
+			bool changed;
+
 			if (!(mi->supported[group] & BIT(i)))
 				continue;
 
@@ -1096,7 +1102,11 @@ minstrel_ht_update_stats(struct minstrel
 
 			mrs = &mg->rates[i];
 			mrs->retry_updated = false;
+			changed = mrs->attempts > 0;
 			minstrel_ht_calc_rate_stats(mp, mrs);
+			if (changed)
+				minstrel_ht_report_rate_update(mp, mi, index,
+							       mrs);
 
 			if (mrs->att_hist)
 				last_prob = max(last_prob, mrs->prob_avg);
@@ -1145,7 +1155,12 @@ minstrel_ht_update_stats(struct minstrel
 
 	mi->max_prob_rate = tmp_max_prob_rate;
 
-	minstrel_ht_refill_sample_rates(mi);
+	minstrel_ht_report_best_rates(mp, mi);
+
+	if (!minstrel_ht_manual_mode(mp)) {
+		minstrel_ht_refill_sample_rates(mi);
+		minstrel_ht_report_sample_rates(mp, mi);
+	}
 
 #ifdef CPTCFG_MAC80211_DEBUGFS
 	/* use fixed index if set */
@@ -1253,6 +1268,7 @@ minstrel_ht_tx_status(void *priv, struct
 	struct minstrel_priv *mp = priv;
 	u32 update_interval = mp->update_interval;
 	bool last, update = false;
+	u16 rate_list[IEEE80211_TX_MAX_RATES] = {};
 	int i;
 
 	/* Ignore packet that was sent with noAck flag */
@@ -1270,6 +1286,8 @@ minstrel_ht_tx_status(void *priv, struct
 		info->status.ampdu_len = 1;
 	}
 
+	spin_lock_bh(&mi->lock);
+
 	/* wraparound */
 	if (mi->total_packets >= ~0 - info->status.ampdu_len) {
 		mi->total_packets = 0;
@@ -1291,7 +1309,8 @@ minstrel_ht_tx_status(void *priv, struct
 							&(st->rates[i + 1]));
 
 			rate = minstrel_ht_ri_get_stats(mp, mi,
-							&(st->rates[i]));
+							&(st->rates[i]),
+							&rate_list[i]);
 
 			if (last)
 				rate->success += info->status.ampdu_ack_len;
@@ -1305,7 +1324,8 @@ minstrel_ht_tx_status(void *priv, struct
 			last = (i == IEEE80211_TX_MAX_RATES - 1) ||
 				!minstrel_ht_txstat_valid(mp, mi, &ar[i + 1]);
 
-			rate = minstrel_ht_get_stats(mp, mi, &ar[i]);
+			rate = minstrel_ht_get_stats(mp, mi, &ar[i], &rate_list[i]);
+
 			if (last)
 				rate->success += info->status.ampdu_ack_len;
 
@@ -1313,6 +1333,8 @@ minstrel_ht_tx_status(void *priv, struct
 		}
 	}
 
+	minstrel_ht_report_tx_status(mp, mi, info, rate_list, i);
+
 	if (mp->hw->max_rates > 1) {
 		/*
 		 * check for sudden death of spatial multiplexing,
@@ -1334,7 +1356,9 @@ minstrel_ht_tx_status(void *priv, struct
 	}
 
 	if (update)
-		minstrel_ht_update_rates(mp, mi);
+		minstrel_ht_update_rates(mp, mi, false);
+
+	spin_unlock_bh(&mi->lock);
 }
 
 static void
@@ -1397,7 +1421,7 @@ minstrel_calc_retransmit(struct minstrel
 }
 
 
-static void
+void
 minstrel_ht_set_rate(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,
                      struct ieee80211_sta_rates *ratetbl, int offset, int index)
 {
@@ -1506,12 +1530,25 @@ minstrel_ht_get_max_amsdu_len(struct min
 }
 
 static void
-minstrel_ht_update_rates(struct minstrel_priv *mp, struct minstrel_ht_sta *mi)
+minstrel_ht_update_rates(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,
+			 bool force)
 {
 	struct ieee80211_sta_rates *rates;
 	int i = 0;
 	int max_rates = min_t(int, mp->hw->max_rates, IEEE80211_TX_RATE_TABLE_SIZE);
 
+	if (minstrel_ht_manual_mode(mp) && !force) {
+		spin_lock_bh(&mi->lock);
+		if (mi->ratetbl) {
+			rates = kmemdup(mi->ratetbl, sizeof(*rates), GFP_ATOMIC);
+			if (rates)
+				rate_control_set_rates(mp->hw, mi->sta, rates);
+		}
+		spin_unlock_bh(&mi->lock);
+
+		return;
+	}
+
 	rates = kzalloc(sizeof(*rates), GFP_ATOMIC);
 	if (!rates)
 		return;
@@ -1539,7 +1576,7 @@ minstrel_ht_get_sample_rate(struct minst
 {
 	u8 seq;
 
-	if (mp->hw->max_rates > 1) {
+	if (mp->hw->max_rates > 1 && !minstrel_ht_manual_mode(mp)) {
 		seq = mi->sample_seq;
 		mi->sample_seq = (seq + 1) % ARRAY_SIZE(minstrel_sample_seq);
 		seq = minstrel_sample_seq[seq];
@@ -1560,12 +1597,15 @@ minstrel_ht_get_rate(void *priv, struct
 	struct minstrel_ht_sta *mi = priv_sta;
 	struct minstrel_priv *mp = priv;
 	u16 sample_idx;
+	u32 sampling_interval = MINSTREL_SAMPLE_INTERVAL;
 
 	info->flags |= mi->tx_flags;
 
 #ifdef CPTCFG_MAC80211_DEBUGFS
 	if (mp->fixed_rate_idx != -1)
 		return;
+
+	sampling_interval = mp->sampling_interval;
 #endif
 
 	/* Don't use EAPOL frames for sampling on non-mrr hw */
@@ -1573,14 +1613,24 @@ minstrel_ht_get_rate(void *priv, struct
 	    (info->control.flags & IEEE80211_TX_CTRL_PORT_CTRL_PROTO))
 		return;
 
+	if (minstrel_ht_manual_mode(mp) && mi->user_sample_rate != -1) {
+		sample_idx = mi->user_sample_rate;
+		mi->user_sample_rate = -1;
+		goto set_rate;
+	}
+
 	if (time_is_after_jiffies(mi->sample_time))
 		return;
 
-	mi->sample_time = jiffies + MINSTREL_SAMPLE_INTERVAL;
+	spin_lock_bh(&mi->lock);
+
+	mi->sample_time = jiffies + sampling_interval;
 	sample_idx = minstrel_ht_get_sample_rate(mp, mi);
+	spin_unlock_bh(&mi->lock);
 	if (!sample_idx)
 		return;
 
+set_rate:
 	sample_group = &minstrel_mcs_groups[MI_RATE_GROUP(sample_idx)];
 	sample_idx = MI_RATE_IDX(sample_idx);
 
@@ -1679,7 +1729,7 @@ minstrel_ht_update_caps(void *priv, stru
 	else
 		use_vht = 0;
 
-	memset(mi, 0, sizeof(*mi));
+	spin_lock_bh(&mi->lock);
 
 	mi->sta = sta;
 	mi->band = sband->band;
@@ -1792,7 +1842,11 @@ minstrel_ht_update_caps(void *priv, stru
 
 	/* create an initial rate table with the lowest supported rates */
 	minstrel_ht_update_stats(mp, mi);
-	minstrel_ht_update_rates(mp, mi);
+	minstrel_ht_update_rates(mp, mi, true);
+
+	minstrel_ht_sta_update(mp, mi);
+
+	spin_unlock_bh(&mi->lock);
 }
 
 static void
@@ -1828,12 +1882,20 @@ minstrel_ht_alloc_sta(void *priv, struct
 			max_rates = sband->n_bitrates;
 	}
 
-	return kzalloc(sizeof(*mi), gfp);
+	mi = kzalloc(sizeof(*mi), gfp);
+	spin_lock_init(&mi->lock);
+#ifdef CPTCFG_MAC80211_RC_MINSTREL_DEBUGFS_API
+	INIT_LIST_HEAD(&mi->list);
+	mi->user_sample_rate = -1;
+#endif
+
+	return mi;
 }
 
 static void
 minstrel_ht_free_sta(void *priv, struct ieee80211_sta *sta, void *priv_sta)
 {
+	minstrel_ht_sta_remove(priv, priv_sta);
 	kfree(priv_sta);
 }
 
@@ -1927,6 +1989,9 @@ minstrel_ht_alloc(struct ieee80211_hw *h
 
 	mp->hw = hw;
 	mp->update_interval = HZ / 20;
+#ifdef CPTCFG_MAC80211_DEBUGFS
+	mp->sampling_interval = MINSTREL_SAMPLE_INTERVAL;
+#endif
 
 	minstrel_ht_init_cck_rates(mp);
 	for (i = 0; i < ARRAY_SIZE(mp->hw->wiphy->bands); i++)
@@ -1936,6 +2001,41 @@ minstrel_ht_alloc(struct ieee80211_hw *h
 }
 
 #ifdef CPTCFG_MAC80211_DEBUGFS
+
+static int minstrel_ht_debugfs_hz_get(void *data, u64 *val)
+{
+	unsigned int tmp = *(unsigned int *)data;
+	if (tmp)
+		*val = HZ / *(unsigned int *)data;
+	else
+		*val = 0;
+	return 0;
+}
+
+static int minstrel_ht_debugfs_hz_set(void *data, u64 val)
+{
+	if (!val || val > HZ)
+		return -EINVAL;
+
+	*(unsigned int *)data = val ? (HZ / val) : val;
+	return 0;
+}
+
+static int minstrel_ht_debugfs_hz_open(struct inode *inode, struct file *file)
+{
+	return simple_attr_open(inode, file, minstrel_ht_debugfs_hz_get,
+				minstrel_ht_debugfs_hz_set, "%llu\n");
+}
+
+static const struct file_operations minstrel_ht_debugfs_hz_fops = {
+	.owner = THIS_MODULE,
+	.open = minstrel_ht_debugfs_hz_open,
+	.release = simple_attr_release,
+	.read = debugfs_attr_read,
+	.write = debugfs_attr_write,
+	.llseek = no_llseek,
+};
+
 static void minstrel_ht_add_debugfs(struct ieee80211_hw *hw, void *priv,
 				    struct dentry *debugfsdir)
 {
@@ -1944,12 +2044,22 @@ static void minstrel_ht_add_debugfs(stru
 	mp->fixed_rate_idx = (u32) -1;
 	debugfs_create_u32("fixed_rate_idx", S_IRUGO | S_IWUGO, debugfsdir,
 			   &mp->fixed_rate_idx);
+
+	debugfs_create_file_unsafe("update_freq", 0666, debugfsdir,
+	                  	   &mp->update_interval,
+				   &minstrel_ht_debugfs_hz_fops);
+	debugfs_create_file_unsafe("sampling_freq", 0666, debugfsdir,
+				   &mp->sampling_interval,
+				   &minstrel_ht_debugfs_hz_fops);
+
+	minstrel_ht_add_debugfs_api(hw, priv, debugfsdir);
 }
 #endif
 
 static void
 minstrel_ht_free(void *priv)
 {
+	minstrel_ht_remove_debugfs_api(priv);
 	kfree(priv);
 }
 
--- a/net/mac80211/rc80211_minstrel_ht.h
+++ b/net/mac80211/rc80211_minstrel_ht.h
@@ -72,6 +72,11 @@
 #define MINSTREL_SAMPLE_RATES		5 /* rates per sample type */
 #define MINSTREL_SAMPLE_INTERVAL	(HZ / 50)
 
+#define MINSTREL_MONITOR_STA		BIT(0)
+#define MINSTREL_MONITOR_TXS		BIT(1)
+#define MINSTREL_MONITOR_RXS		BIT(2)
+#define MINSTREL_MONITOR_STATS		BIT(3)
+
 struct minstrel_priv {
 	struct ieee80211_hw *hw;
 	bool has_mrr;
@@ -92,6 +97,17 @@ struct minstrel_priv {
 	 *   - setting will be applied on next update
 	 */
 	u32 fixed_rate_idx;
+	unsigned int sampling_interval;
+#endif
+#ifdef CPTCFG_MAC80211_RC_MINSTREL_DEBUGFS_API
+	struct rchan *relay_ev;
+	spinlock_t relay_lock;
+
+	struct list_head stations;
+	spinlock_t sta_wlock;
+
+	u8 monitor;
+	bool manual;
 #endif
 };
 
@@ -153,7 +169,13 @@ struct minstrel_sample_category {
 };
 
 struct minstrel_ht_sta {
+#ifdef CPTCFG_MAC80211_RC_MINSTREL_DEBUGFS_API
+	struct list_head list;
+	u32 user_sample_rate;
+	struct ieee80211_sta_rates *ratetbl;
+#endif
 	struct ieee80211_sta *sta;
+	spinlock_t lock;
 
 	/* ampdu length (average, per sampling interval) */
 	unsigned int ampdu_len;
@@ -197,7 +219,124 @@ struct minstrel_ht_sta {
 };
 
 void minstrel_ht_add_sta_debugfs(void *priv, void *priv_sta, struct dentry *dir);
+
+#ifdef CPTCFG_MAC80211_RC_MINSTREL_DEBUGFS_API
+void minstrel_ht_sta_update(struct minstrel_priv *mp, struct minstrel_ht_sta *mi);
+void minstrel_ht_sta_remove(struct minstrel_priv *mp, struct minstrel_ht_sta *mi);
+void __minstrel_ht_report_tx_status(struct minstrel_priv *mp,
+				    struct minstrel_ht_sta *mi,
+				    struct ieee80211_tx_info *info,
+				    u16 *rate_list, int n_rates);
+void __minstrel_ht_report_rx_status(struct minstrel_priv *mp, u8 *addr,
+                                    int last_signal, u8 chain_status,
+                                    s8 *chain_signal);
+void __minstrel_ht_report_rate_update(struct minstrel_priv *mp,
+				      struct minstrel_ht_sta *mi, u16 rate,
+				      struct minstrel_rate_stats *mrs);
+void __minstrel_ht_report_best_rates(struct minstrel_priv *mp,
+				     struct minstrel_ht_sta *mi);
+void __minstrel_ht_report_sample_rates(struct minstrel_priv *mp,
+				       struct minstrel_ht_sta *mi);
+void minstrel_ht_add_debugfs_api(struct ieee80211_hw *hw, void *priv,
+				 struct dentry *dir);
+void minstrel_ht_remove_debugfs_api(void *priv);
+#else
+static inline void
+minstrel_ht_sta_update(struct minstrel_priv *mp, struct minstrel_ht_sta *mi)
+{
+}
+static inline void
+minstrel_ht_sta_remove(struct minstrel_priv *mp, struct minstrel_ht_sta *mi)
+{
+}
+static inline void
+minstrel_ht_add_debugfs_api(struct ieee80211_hw *hw, void *priv,
+			    struct dentry *dir)
+{
+}
+static inline void
+minstrel_ht_remove_debugfs_api(void *priv)
+{
+}
+#endif
+
+static inline void
+minstrel_ht_report_tx_status(struct minstrel_priv *mp,
+			     struct minstrel_ht_sta *mi,
+			     struct ieee80211_tx_info *info,
+			     u16 *rate_list, int n_rates)
+{
+#ifdef CPTCFG_MAC80211_RC_MINSTREL_DEBUGFS_API
+	if (!(mp->monitor & MINSTREL_MONITOR_TXS))
+		return;
+
+	__minstrel_ht_report_tx_status(mp, mi, info, rate_list, n_rates);
+#endif
+}
+
+static inline void
+minstrel_ht_report_rx_status(struct minstrel_priv *mp, u8 *addr,
+                             int last_signal, u8 chain_status, s8 *chain_signal)
+{
+#ifdef CPTCFG_MAC80211_RC_MINSTREL_DEBUGFS_API
+	if (!(mp->monitor & MINSTREL_MONITOR_RXS))
+		return;
+
+	__minstrel_ht_report_rx_status(mp, addr, last_signal,
+	                               chain_status, chain_signal);
+#endif
+}
+
+static inline void
+minstrel_ht_report_rate_update(struct minstrel_priv *mp,
+			       struct minstrel_ht_sta *mi, u16 rate,
+			       struct minstrel_rate_stats *mrs)
+{
+#ifdef CPTCFG_MAC80211_RC_MINSTREL_DEBUGFS_API
+	if (!(mp->monitor & MINSTREL_MONITOR_STATS))
+		return;
+
+	__minstrel_ht_report_rate_update(mp, mi, rate, mrs);
+#endif
+}
+
+static inline void
+minstrel_ht_report_best_rates(struct minstrel_priv *mp, struct minstrel_ht_sta *mi)
+{
+#ifdef CPTCFG_MAC80211_RC_MINSTREL_DEBUGFS_API
+	if (!(mp->monitor & MINSTREL_MONITOR_STATS))
+		return;
+
+	__minstrel_ht_report_best_rates(mp, mi);
+#endif
+}
+
+static inline void
+minstrel_ht_report_sample_rates(struct minstrel_priv *mp, struct minstrel_ht_sta *mi)
+{
+#ifdef CPTCFG_MAC80211_RC_MINSTREL_DEBUGFS_API
+	if (!(mp->monitor & MINSTREL_MONITOR_STATS))
+		return;
+
+	__minstrel_ht_report_sample_rates(mp, mi);
+#endif
+}
+
+static inline bool
+minstrel_ht_manual_mode(struct minstrel_priv *mp)
+{
+#ifdef CPTCFG_MAC80211_RC_MINSTREL_DEBUGFS_API
+	return mp->manual;
+#else
+	return false;
+#endif
+}
+
+void minstrel_ht_set_rate(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,
+						  struct ieee80211_sta_rates *ratetbl, int offset,
+						  int index);
 int minstrel_ht_get_tp_avg(struct minstrel_ht_sta *mi, int group, int rate,
 			   int prob_avg);
+void minstrel_ht_update_stats(struct minstrel_priv *mp, struct minstrel_ht_sta *mi);
 
 #endif
--- /dev/null
+++ b/net/mac80211/rc80211_minstrel_ht_api.c
@@ -0,0 +1,757 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (C) 2021 Felix Fietkau <nbd@nbd.name>
+ */
+#include <linux/kernel.h>
+#include <linux/debugfs.h>
+#include <linux/relay.h>
+#include <net/mac80211.h>
+#include "rc80211_minstrel_ht.h"
+
+extern u8 sample_table[SAMPLE_COLUMNS][MCS_GROUP_RATES];
+
+enum sta_cmd {
+	STA_CMD_PROBE,
+	STA_CMD_RATES,
+};
+
+static void
+minstrel_ht_print_rate_durations(struct seq_file *s, int group)
+{
+	const struct mcs_group *g = &minstrel_mcs_groups[group];
+	int n_rates;
+	int i;
+
+	if (g->flags & IEEE80211_TX_RC_VHT_MCS)
+		n_rates = 10;
+	else
+		n_rates = 8;
+
+	seq_printf(s, "%x", g->duration[0] << g->shift);
+	for (i = 1; i < n_rates; i++)
+		seq_printf(s, ";%x", g->duration[i] << g->shift);
+
+	for (; i < MCS_GROUP_RATES; i++)
+		seq_printf(s, ";");
+}
+
+static int
+minstrel_ht_read_api_info(struct seq_file *s, void *data)
+{
+	int i, j;
+
+	seq_printf(s, "#group;index;offset;type;nss;bw;gi");
+	for (i = 0; i < MCS_GROUP_RATES; i++)
+	        seq_printf(s, ";airtime%d", i);
+        seq_printf(s, "\n");
+
+	seq_printf(s, "#sta;action;macaddr;overhead_mcs;overhead_legacy");
+	for (i = 0; i < MINSTREL_GROUPS_NB; i++)
+	        seq_printf(s, ";mcs%d", i);
+	seq_printf(s, "\n");
+
+	seq_printf(s, "#txs;macaddr;num_frames;num_acked;probe");
+	for (i = 0; i < IEEE80211_TX_MAX_RATES; i++)
+		seq_printf(s, ";rate%d;count%d", i, i);
+	seq_printf(s, "\n");
+
+	seq_printf(s, "#rxs;macaddr;last_signal");
+	for (i = 0; i < IEEE80211_MAX_CHAINS; i++)
+		seq_printf(s, ";signal%d", i);
+	seq_printf(s, "\n");
+
+	seq_printf(s, "#stats;macaddr;rate;avg_prob;avg_tp;cur_success;"
+		      "cur_attempts;hist_success;hist_attempts\n");
+	seq_printf(s, "#best_rates;macaddr");
+	for (i = 0; i < MAX_THR_RATES; i++)
+		seq_printf(s, ";maxtp%d", i);
+	seq_printf(s, ";maxprob\n");
+
+	seq_printf(s, "#sample_rates;macaddr");
+	for (i = 0; i < MINSTREL_SAMPLE_RATES; i++)
+	        seq_printf(s, ";inc%d", i);
+	for (i = 0; i < MINSTREL_SAMPLE_RATES; i++)
+	        seq_printf(s, ";jump%d", i);
+	for (i = 0; i < MINSTREL_SAMPLE_RATES; i++)
+	        seq_printf(s, ";slow%d", i);
+	seq_printf(s, "\n");
+
+	seq_printf(s, "#reset_stats;macaddr\n");
+	seq_printf(s, "#rates;macaddr;rates;counts\n");
+	seq_printf(s, "#probe;macaddr;rate\n");
+
+	seq_printf(s, "#sample_table;cols;rows");
+	for (i = 0; i < SAMPLE_COLUMNS; i++)
+		seq_printf(s, ";column%d", i);
+	seq_printf(s, "\n");
+
+	for (i = 0; i < MINSTREL_GROUPS_NB; i++) {
+		const struct mcs_group *g = &minstrel_mcs_groups[i];
+		const char *type;
+
+		if (i == MINSTREL_CCK_GROUP)
+			type = "cck";
+		else if (i == MINSTREL_OFDM_GROUP)
+			type = "ofdm";
+		else if (g->flags & IEEE80211_TX_RC_VHT_MCS)
+			type = "vht";
+		else
+			type = "ht";
+
+		seq_printf(s, "group;%x;%x;%s;%x;%x;%x;",
+			   i, (u32) MI_RATE(i, 0), type, g->streams, g->bw,
+			   !!(g->flags & IEEE80211_TX_RC_SHORT_GI));
+		minstrel_ht_print_rate_durations(s, i);
+		seq_printf(s, "\n");
+	}
+	seq_printf(s, "sample_table;%x;%x", SAMPLE_COLUMNS, MCS_GROUP_RATES);
+	for (i = 0; i < SAMPLE_COLUMNS; i++) {
+		seq_printf(s, ";");
+		for (j = 0; j < MCS_GROUP_RATES; j++) {
+			if (j == 0)
+				seq_printf(s, "%x", sample_table[i][j]);
+			else
+				seq_printf(s, ",%x", sample_table[i][j]);
+		}
+	}
+	seq_printf(s, "\n");
+
+	return 0;
+}
+
+static struct dentry *
+create_buf_file_cb(const char *filename, struct dentry *parent, umode_t mode,
+		   struct rchan_buf *buf, int *is_global)
+{
+	struct dentry *f;
+
+	f = debugfs_create_file("api_event", mode, parent, buf,
+				&relay_file_operations);
+	if (IS_ERR(f))
+		return NULL;
+
+	*is_global = 1;
+
+	return f;
+}
+
+static int
+remove_buf_file_cb(struct dentry *f)
+{
+	debugfs_remove(f);
+
+	return 0;
+}
+
+static struct rchan_callbacks relay_ev_cb = {
+	.create_buf_file = create_buf_file_cb,
+	.remove_buf_file = remove_buf_file_cb,
+};
+
+static void
+minstrel_ht_dump_sta(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,
+		     const char *type)
+{
+	char info[64 + MINSTREL_GROUPS_NB * 4];
+	int ofs = 0;
+	int i;
+
+	ofs += scnprintf(info + ofs, sizeof(info) - ofs, "%llx;sta;%s;%pM;%x;%x;",
+			(unsigned long long)ktime_get_real_fast_ns(),
+			type, mi->sta->addr, mi->overhead, mi->overhead_legacy);
+
+	ofs += scnprintf(info + ofs, sizeof(info) - ofs, "%x",
+			 mi->supported[0]);
+	for (i = 1; i < MINSTREL_GROUPS_NB; i++)
+		ofs += scnprintf(info + ofs, sizeof(info) - ofs, ";%x",
+				 mi->supported[i]);
+
+	ofs += scnprintf(info + ofs, sizeof(info) - ofs, "\n");
+
+	relay_write(mp->relay_ev, info, ofs);
+	relay_flush(mp->relay_ev);
+}
+
+void __minstrel_ht_report_sample_rates(struct minstrel_priv *mp,
+				       struct minstrel_ht_sta *mi)
+{
+	char line[128];
+	int i, j, ofs;
+
+	ofs = scnprintf(line, sizeof(line), "%llx;sample_rates;%pM",
+			(unsigned long long)ktime_get_real_fast_ns(),
+			mi->sta->addr);
+
+	for (i = 0; i < __MINSTREL_SAMPLE_TYPE_MAX; i++)
+		for (j = 0; j < MINSTREL_SAMPLE_RATES; j++)
+			ofs += scnprintf(line + ofs, sizeof(line), ";%x",
+					 mi->sample[i].cur_sample_rates[j]);
+
+	ofs += scnprintf(line + ofs, sizeof(line), "\n");
+
+	relay_write(mp->relay_ev, line, ofs);
+	relay_flush(mp->relay_ev);
+}
+
+static void
+minstrel_ht_dump_stations(struct minstrel_priv *mp, const char *type)
+{
+	struct minstrel_ht_sta *mi;
+
+	rcu_read_lock();
+	spin_lock_bh(&mp->relay_lock);
+
+	list_for_each_entry_rcu(mi, &mp->stations, list)
+		minstrel_ht_dump_sta(mp, mi, type);
+
+	spin_unlock_bh(&mp->relay_lock);
+	rcu_read_unlock();
+}
+
+static void
+minstrel_ht_api_start(struct minstrel_priv *mp, char *params)
+{
+	char *cur;
+	u8 mask = 0;
+
+	while ((cur = strsep(&params, ";")) != NULL) {
+		if (!strlen(cur))
+			break;
+
+		if (!strcmp(cur, "txs"))
+			mask |= MINSTREL_MONITOR_TXS;
+		else if (!strcmp(cur, "rxs"))
+			mask |= MINSTREL_MONITOR_RXS;
+		else if (!strcmp(cur, "sta"))
+			mask |= MINSTREL_MONITOR_STA;
+		else if (!strcmp(cur, "stats"))
+			mask |= MINSTREL_MONITOR_STATS;
+	}
+
+	if (!mask)
+		mask = MINSTREL_MONITOR_TXS;
+
+	if (!mp->monitor)
+		minstrel_ht_dump_stations(mp, "add");
+	mp->monitor = mask | MINSTREL_MONITOR_STA;
+}
+
+static void
+minstrel_ht_api_stop(struct minstrel_priv *mp)
+{
+	spin_lock_bh(&mp->relay_lock);
+	mp->monitor = 0;
+	relay_reset(mp->relay_ev);
+	spin_unlock_bh(&mp->relay_lock);
+}
+
+static void
+minstrel_ht_reset_sample_table(struct minstrel_ht_sta *mi)
+{
+	int i;
+
+	for (i = 0; i < __MINSTREL_SAMPLE_TYPE_MAX; i++)
+		memset(mi->sample[i].sample_rates, 0, 
+		       sizeof(mi->sample[i].sample_rates));
+
+	mi->sample_seq = 0;
+	mi->user_sample_rate = -1;
+}
+
+static void
+minstrel_ht_api_set_manual(struct minstrel_priv *mp, bool manual)
+{
+	struct minstrel_ht_sta *mi;
+
+	mp->manual = manual;
+
+	rcu_read_lock();
+	list_for_each_entry_rcu(mi, &mp->stations, list) {
+		spin_lock_bh(&mi->lock);
+
+		minstrel_ht_reset_sample_table(mi);
+		kfree(mi->ratetbl);
+		mi->ratetbl = NULL;
+
+		spin_unlock_bh(&mi->lock);
+	}
+	rcu_read_unlock();
+}
+
+static struct minstrel_ht_sta *
+minstrel_ht_api_get_sta(struct minstrel_priv *mp, const u8 *macaddr)
+{
+	struct minstrel_ht_sta *mi;
+
+	rcu_read_lock();
+	list_for_each_entry_rcu(mi, &mp->stations, list) {
+		if (!memcmp(mi->sta->addr, macaddr, ETH_ALEN))
+			goto out;
+	}
+	mi = NULL;
+
+out:
+	rcu_read_unlock();
+	return mi;
+}
+
+static int
+minstrel_ht_get_args(char **dest, int dest_size, char *str, char *sep)
+{
+	int i, n;
+
+	for (i = 0, n = 0; i < dest_size; i++) {
+		if (!str) {
+			dest[i] = NULL;
+			continue;
+		}
+
+		dest[i] = strsep(&str, sep);
+		if (dest[i])
+			n++;
+	}
+
+	return n;
+}
+
+static bool
+minstrel_ht_valid_rate(struct minstrel_ht_sta *mi, u32 rate)
+{
+	int group, idx;
+
+	group = MI_RATE_GROUP(rate);
+	if (group >= MINSTREL_GROUPS_NB)
+		return false;
+
+	idx = MI_RATE_IDX(rate);
+
+	return !!(mi->supported[group] & BIT(idx));
+}
+
+static int
+minstrel_ht_rate_from_str(struct minstrel_ht_sta *mi, const char *str)
+{
+	unsigned int rate;
+
+	if (kstrtouint(str, 16, &rate))
+		return -EINVAL;
+
+	if (!minstrel_ht_valid_rate(mi, rate))
+		return -EINVAL;
+
+	return rate;
+}
+
+static int
+minstrel_ht_set_probe_rate(struct minstrel_ht_sta *mi, const char *rate_str)
+{
+	int rate;
+
+	if (!rate_str)
+		return -EINVAL;
+
+	rate = minstrel_ht_rate_from_str(mi, rate_str);
+	if (rate < 0)
+		return rate;
+
+	mi->user_sample_rate = rate;
+	return 0;
+}
+
+static int
+minstrel_ht_set_rates(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,
+		      char *rate_str, char *count_str)
+{
+	struct ieee80211_sta_rates *ratetbl;
+	unsigned int count;
+	char *countlist[4];
+	char *ratelist[4];
+	int rate;
+	int n_rates;
+	int n_count;
+	int err = -EINVAL;
+	int i;
+
+	if (!rate_str || !count_str)
+		return -EINVAL;
+
+	if (!mi->ratetbl)
+		mi->ratetbl = kzalloc(sizeof(*ratetbl), GFP_ATOMIC);
+
+	ratetbl = mi->ratetbl;
+	if (!ratetbl)
+		return -ENOMEM;
+
+	memset(ratetbl, 0, sizeof(*ratetbl));
+	n_rates = minstrel_ht_get_args(ratelist, ARRAY_SIZE(ratelist),
+				       rate_str, ",");
+	n_count = minstrel_ht_get_args(countlist, ARRAY_SIZE(countlist),
+				       count_str, ",");
+	for (i = 0; i < min(n_rates, n_count); i++) {
+		rate = minstrel_ht_rate_from_str(mi, ratelist[i]);
+		if (rate < 0)
+			goto error;
+
+		if (kstrtouint(countlist[i], 16, &count))
+			goto error;
+
+		minstrel_ht_set_rate(mp, mi, ratetbl, i, rate);
+		ratetbl->rate[i].count = count;
+		ratetbl->rate[i].count_rts = count;
+		ratetbl->rate[i].count_cts = count;
+	}
+	if (!i)
+		goto error;
+
+	ratetbl = kmemdup(ratetbl, sizeof(*ratetbl), GFP_KERNEL);
+	if (!ratetbl)
+		return -ENOMEM;
+
+	rate_control_set_rates(mp->hw, mi->sta, ratetbl);
+
+	return 0;
+
+error:
+	kfree(ratetbl);
+	mi->ratetbl = NULL;
+
+	return err;
+}
+
+static int
+minstrel_ht_api_sta_cmd(struct minstrel_priv *mp, enum sta_cmd cmd,
+			char *arg_str)
+{
+	struct minstrel_ht_sta *mi;
+	uint8_t macaddr[ETH_ALEN];
+	char *args[3];
+	int n_args;
+	int ret = -EINVAL;
+
+	if (!mp->manual)
+		return -EINVAL;
+
+	n_args = minstrel_ht_get_args(args, ARRAY_SIZE(args), arg_str, ";");
+	if (!args[0])
+		return -EINVAL;
+
+	if (!mac_pton(args[0], macaddr))
+		return -EINVAL;
+
+	mi = minstrel_ht_api_get_sta(mp, macaddr);
+	if (!mi)
+		return -ENOENT;
+
+	spin_lock_bh(&mi->lock);
+
+	switch (cmd) {
+	case STA_CMD_PROBE:
+		ret = minstrel_ht_set_probe_rate(mi, args[1]);
+		break;
+	case STA_CMD_RATES:
+		ret = minstrel_ht_set_rates(mp, mi, args[1], args[2]);
+		break;
+	}
+
+	spin_unlock_bh(&mi->lock);
+	return ret;
+}
+
+static void
+minstrel_ht_reset_sta_rc_stats(struct minstrel_priv *mp, struct minstrel_ht_sta *mi)
+{
+	mi->ampdu_len = 0;
+	mi->ampdu_packets = 0;
+	mi->avg_ampdu_len = MINSTREL_FRAC(1, 1);
+	memset(&mi->max_tp_rate, 0, sizeof(u16) * MAX_THR_RATES);
+	mi->max_prob_rate = 0;
+	mi->total_packets = 0;
+	mi->sample_packets = 0;
+	mi->sample_rate = 0;
+	memset(&mi->sample, 0, sizeof(struct minstrel_sample_category) *
+			       __MINSTREL_SAMPLE_TYPE_MAX);
+	memset(&mi->groups, 0, sizeof(struct minstrel_mcs_group_data) *
+			       MINSTREL_GROUPS_NB);
+
+	minstrel_ht_update_stats(mp, mi);
+}
+
+static int
+minstrel_ht_reset_stats(struct minstrel_priv *mp, char *buf)
+{
+	struct minstrel_ht_sta *mi;
+	uint8_t macaddr[ETH_ALEN];
+	int err = 0;
+
+	rcu_read_lock();
+
+	if (!buf) {
+		list_for_each_entry(mi, &mp->stations, list)
+			minstrel_ht_reset_sta_rc_stats(mp, mi);
+		goto out;
+	}
+
+	if (!mac_pton(buf, macaddr)) {
+		err = -EINVAL;
+		goto out;
+	}
+
+	mi = minstrel_ht_api_get_sta(mp, macaddr);
+	if (!mi) {
+		err = -ENOENT;
+		goto out;
+	}
+
+	minstrel_ht_reset_sta_rc_stats(mp, mi);
+
+out:
+	rcu_read_unlock();
+
+	return err;
+}
+
+static ssize_t
+minstrel_ht_control_write(struct file *file, const char __user *userbuf,
+			  size_t count, loff_t *ppos)
+{
+	struct minstrel_priv *mp = file->private_data;
+	char *pos, *cur;
+	char buf[64];
+	size_t len = count;
+	int err;
+
+	if (len > sizeof(buf) - 1)
+		return -EINVAL;
+
+	if (copy_from_user(buf, userbuf, len))
+		return -EFAULT;
+
+	if (count > 0 && buf[len - 1] == '\n')
+		len--;
+
+	buf[len] = 0;
+	if (!len)
+		return count;
+
+	pos = buf;
+	cur = strsep(&pos, ";");
+
+	err = 0;
+	if (!strcmp(cur, "dump"))
+		minstrel_ht_dump_stations(mp, "dump");
+	else if (!strcmp(cur, "start"))
+		minstrel_ht_api_start(mp, pos);
+	else if (!strcmp(cur, "stop"))
+		minstrel_ht_api_stop(mp);
+	else if (!strcmp(cur, "manual"))
+		minstrel_ht_api_set_manual(mp, true);
+	else if (!strcmp(cur, "auto"))
+		minstrel_ht_api_set_manual(mp, false);
+	else if (!strcmp(cur, "reset_stats"))
+		err = minstrel_ht_reset_stats(mp, pos);
+	else if (!strcmp(cur, "rates"))
+		err = minstrel_ht_api_sta_cmd(mp, STA_CMD_RATES, pos);
+	else if (!strcmp(cur, "probe"))
+		err = minstrel_ht_api_sta_cmd(mp, STA_CMD_PROBE, pos);
+	else
+		err = -EINVAL;
+
+	if (err)
+		return err;
+
+	return count;
+}
+
+static const struct file_operations fops_control = {
+	.open = simple_open,
+	.llseek = generic_file_llseek,
+	.write = minstrel_ht_control_write,
+};
+
+void minstrel_ht_sta_update(struct minstrel_priv *mp, struct minstrel_ht_sta *mi)
+{
+	bool add = list_empty(&mi->list);
+
+	if (add) {
+		spin_lock_bh(&mp->sta_wlock);
+		list_add_rcu(&mi->list, &mp->stations);
+		spin_unlock_bh(&mp->sta_wlock);
+	}
+
+	if (mp->monitor) {
+		spin_lock_bh(&mp->relay_lock);
+		minstrel_ht_dump_sta(mp, mi, add ? "add" : "update");
+		spin_unlock_bh(&mp->relay_lock);
+	}
+}
+
+void minstrel_ht_sta_remove(struct minstrel_priv *mp, struct minstrel_ht_sta *mi)
+{
+	char info[64];
+	int ofs = 0;
+
+	spin_lock_bh(&mp->sta_wlock);
+
+	list_del_rcu(&mi->list);
+	INIT_LIST_HEAD_RCU(&mi->list);
+
+	spin_unlock_bh(&mp->sta_wlock);
+
+	if (!mp->monitor)
+		return;
+
+
+	ofs = scnprintf(info, sizeof(info), "%llx;sta;remove;%pM;;;\n",
+			(unsigned long long)ktime_get_real_fast_ns(),
+			mi->sta->addr);
+
+	spin_lock_bh(&mp->relay_lock);
+
+	relay_write(mp->relay_ev, info, ofs);
+	relay_flush(mp->relay_ev);
+
+	spin_unlock_bh(&mp->relay_lock);
+}
+
+void __minstrel_ht_report_tx_status(struct minstrel_priv *mp,
+				    struct minstrel_ht_sta *mi,
+				    struct ieee80211_tx_info *info,
+				    u16 *rate_list,
+				    int n_rates)
+{
+	char txs[64 + IEEE80211_TX_MAX_RATES * 8];
+	int ofs = 0;
+	int i;
+
+	if (!n_rates)
+		return;
+
+
+	ofs += scnprintf(txs, sizeof(txs), "%llx;txs;%pM;%x;%x;%x",
+			 (unsigned long long)ktime_get_real_fast_ns(),
+			 mi->sta->addr,
+			 info->status.ampdu_len,
+			 info->status.ampdu_ack_len,
+			 !!(info->flags & IEEE80211_TX_CTL_RATE_CTRL_PROBE));
+
+	for (i = 0; i < n_rates; i++)
+		ofs += scnprintf(txs + ofs, sizeof(txs) - ofs, ";%x;%x",
+				 rate_list[i],
+				 info->status.rates[i].count);
+
+	for (; i < IEEE80211_TX_MAX_RATES; i++)
+		ofs += scnprintf(txs + ofs, sizeof(txs) - ofs, ";ffff;0");
+
+	ofs += scnprintf(txs + ofs, sizeof(txs) - ofs, "\n");
+
+	spin_lock_bh(&mp->relay_lock);
+
+	relay_write(mp->relay_ev, txs, ofs);
+	relay_flush(mp->relay_ev);
+
+	spin_unlock_bh(&mp->relay_lock);
+}
+
+void __minstrel_ht_report_rx_status(struct minstrel_priv *mp, u8 *addr,
+				    int last_signal, u8 chain_status,
+				    s8 *chain_signal)
+{
+	char rxs[64 + IEEE80211_MAX_CHAINS * 8];
+	int ofs = 0;
+	int i;
+
+	ofs += scnprintf(rxs, sizeof(rxs), "%llx;rxs;%pM;%x",
+			 (unsigned long long)ktime_get_real_fast_ns(),
+			 addr, last_signal);
+
+	for (i = 0; i < IEEE80211_MAX_CHAINS; i++)
+	ofs += scnprintf(rxs + ofs, sizeof(rxs) - ofs, ";%x",
+			 (chain_status & BIT(i) ? chain_signal[i] : 0x7f));
+
+	ofs += scnprintf(rxs + ofs, sizeof(rxs) - ofs, "\n");
+
+	spin_lock_bh(&mp->relay_lock);
+
+	relay_write(mp->relay_ev, rxs, ofs);
+	relay_flush(mp->relay_ev);
+
+	spin_unlock_bh(&mp->relay_lock);
+}
+
+void __minstrel_ht_report_rate_update(struct minstrel_priv *mp,
+				      struct minstrel_ht_sta *mi, u16 rate,
+				      struct minstrel_rate_stats *mrs)
+{
+	char stat[100];
+	int ofs;
+	int tp;
+
+	tp = minstrel_ht_get_tp_avg(mi, MI_RATE_GROUP(rate), MI_RATE_IDX(rate),
+				    mrs->prob_avg);
+
+
+	ofs = scnprintf(stat, sizeof(stat),
+			"%llx;stats;%pM;%x;%x;%x;%x;%x;%x;%x\n",
+			(unsigned long long)ktime_get_real_fast_ns(),
+			mi->sta->addr, rate,
+			MINSTREL_TRUNC(mrs->prob_avg * 1000), tp,
+			mrs->last_success,
+			mrs->last_attempts,
+			mrs->succ_hist, mrs->att_hist);
+
+	spin_lock_bh(&mp->relay_lock);
+
+	relay_write(mp->relay_ev, stat, ofs);
+	relay_flush(mp->relay_ev);
+
+	spin_unlock_bh(&mp->relay_lock);
+}
+
+void __minstrel_ht_report_best_rates(struct minstrel_priv *mp, struct minstrel_ht_sta *mi)
+{
+	char line[128];
+	int i, ofs;
+
+	ofs = scnprintf(line, sizeof(line), "%llx;best_rates;%pM",
+	                (unsigned long long)ktime_get_real_fast_ns(),
+	                mi->sta->addr);
+
+	for (i = 0; i < MAX_THR_RATES; i++)
+		ofs += scnprintf(line + ofs, sizeof(line), ";%x", mi->max_tp_rate[i]);
+
+	ofs += scnprintf(line + ofs, sizeof(line), ";%x\n", mi->max_prob_rate);
+
+	spin_lock_bh(&mp->relay_lock);
+
+	relay_write(mp->relay_ev, line, ofs);
+	relay_flush(mp->relay_ev);
+
+	spin_unlock_bh(&mp->relay_lock);
+}
+
+void minstrel_ht_add_debugfs_api(struct ieee80211_hw *hw, void *priv,
+				 struct dentry *dir)
+{
+	struct minstrel_priv *mp = priv;
+
+	spin_lock_init(&mp->relay_lock);
+	spin_lock_init(&mp->sta_wlock);
+
+	INIT_LIST_HEAD_RCU(&mp->stations);
+	mp->relay_ev = relay_open("api_event", dir, 256, 512, &relay_ev_cb,
+				  NULL);
+	debugfs_create_devm_seqfile(&hw->wiphy->dev, "api_info",
+				    dir, minstrel_ht_read_api_info);
+	debugfs_create_file("api_control", 0200, dir, mp, &fops_control);
+}
+
+void minstrel_ht_remove_debugfs_api(void *priv)
+{
+	struct minstrel_priv *mp = priv;
+
+	spin_lock_bh(&mp->relay_lock);
+	if (mp->relay_ev)
+		relay_close(mp->relay_ev);
+
+	spin_unlock_bh(&mp->relay_lock);
+}
--- a/net/mac80211/rx.c
+++ b/net/mac80211/rx.c
@@ -32,6 +32,7 @@
 #include "tkip.h"
 #include "wme.h"
 #include "rate.h"
+#include "rc80211_minstrel_ht.h"
 
 /*
  * monitor mode reception
@@ -1795,6 +1796,12 @@ ieee80211_rx_h_sta_process(struct ieee80
 		}
 	}
 
+	if (rx->local->rate_ctrl && test_sta_flag(sta, WLAN_STA_RATE_CONTROL)) {
+		minstrel_ht_report_rx_status(rx->local->rate_ctrl->priv, sta->addr,
+			(!(status->flag & RX_FLAG_NO_SIGNAL_VAL) ? status->signal : -1),
+			status->chains, status->chain_signal);
+	}
+
 	if (ieee80211_is_s1g_beacon(hdr->frame_control))
 		return RX_CONTINUE;
 
