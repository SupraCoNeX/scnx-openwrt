--- a/net/mac80211/rc80211_minstrel_ht_api.c
+++ /dev/null
@@ -1,1077 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0-only
-/*
- * ORCA - Open-Source Resource Control API
- *
- * Copyright (C) 2021 Felix Fietkau <nbd@nbd.name>
- * Copyright (C) 2021-2023 SupraCoNeX <supraconex@gmail.com>
- */
-#include <linux/kernel.h>
-#include <linux/debugfs.h>
-#include <linux/relay.h>
-#include <net/mac80211.h>
-#include "ieee80211_i.h"
-#include "rate.h"
-#include "rc80211_minstrel_ht.h"
-
-#define ORCA_VERSION "2"
-
-extern u8 sample_table[SAMPLE_COLUMNS][MCS_GROUP_RATES];
-
-enum api_cmd {
-	PHY_CMD_START,
-	PHY_CMD_STOP,
-	PHY_CMD_DUMP,
-
-	/* per-STA commands */
-	STA_CMD_RC_MODE,
-	STA_CMD_TPC_MODE,
-	STA_CMD_RESET_STATS,
-	STA_CMD_PROBE,
-	STA_CMD_TPRC,
-	STA_CMD_TPC,
-	STA_CMD_RC,
-};
-
-static void
-minstrel_ht_print_rate_durations(struct seq_file *s, int group)
-{
-	const struct mcs_group *g = &minstrel_mcs_groups[group];
-	int n_rates;
-	int i;
-
-	if (g->flags & IEEE80211_TX_RC_VHT_MCS)
-		n_rates = 10;
-	else
-		n_rates = 8;
-
-	seq_printf(s, "%x", g->duration[0] << g->shift);
-	for (i = 1; i < n_rates; i++)
-		seq_printf(s, ";%x", g->duration[i] << g->shift);
-
-	for (; i < MCS_GROUP_RATES; i++)
-		seq_printf(s, ";");
-}
-
-static int
-minstrel_ht_read_api_info(struct seq_file *s, void *data)
-{
-	int i, j;
-	seq_printf(s, "orca_version;%s\n", ORCA_VERSION);
-
-	seq_printf(s, "#group;index;offset;type;nss;bw;gi");
-	for (i = 0; i < MCS_GROUP_RATES; i++)
-	        seq_printf(s, ";airtime%d", i);
-        seq_printf(s, "\n");
-
-	seq_printf(s, "#sta;action;macaddr;iface;rc_mode;tpc_mode;overhead_mcs;overhead_legacy");
-	for (i = 0; i < MINSTREL_GROUPS_NB; i++)
-	        seq_printf(s, ";mcs%d", i);
-	seq_printf(s, "\n");
-
-	seq_printf(s, "#txs;macaddr;num_frames;num_acked;probe");
-	for (i = 0; i < IEEE80211_TX_MAX_RATES; i++)
-		seq_printf(s, ";rate%d,count%d,txpwr%d", i, i, i);
-	seq_printf(s, "\n");
-
-	seq_printf(s, "#rxs;macaddr;last_signal");
-	for (i = 0; i < IEEE80211_MAX_CHAINS; i++)
-		seq_printf(s, ";signal%d", i);
-	seq_printf(s, "\n");
-
-	seq_printf(s, "#stats;macaddr;rate;avg_prob;avg_tp;cur_success;"
-		      "cur_attempts;hist_success;hist_attempts\n");
-	seq_printf(s, "#best_rates;macaddr");
-	for (i = 0; i < MAX_THR_RATES; i++)
-		seq_printf(s, ";maxtp%d", i);
-	seq_printf(s, ";maxprob\n");
-
-	seq_printf(s, "#sample_rates;macaddr");
-	for (i = 0; i < MINSTREL_SAMPLE_RATES; i++)
-	        seq_printf(s, ";inc%d", i);
-	for (i = 0; i < MINSTREL_SAMPLE_RATES; i++)
-	        seq_printf(s, ";jump%d", i);
-	for (i = 0; i < MINSTREL_SAMPLE_RATES; i++)
-	        seq_printf(s, ";slow%d", i);
-	seq_printf(s, "\n");
-
-	seq_printf(s, "#sample_table;cols;rows");
-	for (i = 0; i < SAMPLE_COLUMNS; i++)
-		seq_printf(s, ";column%d", i);
-	seq_printf(s, "\n");
-
-	seq_printf(s, "#start;txs;rxs;stats;sta;tprc_echo\n");
-	seq_printf(s, "#stop;txs;rxs;stats;sta;tprc_echo\n");
-
-	seq_printf(s, "#set_rates;macaddr");
-	for (i = 0; i < IEEE80211_TX_MAX_RATES; i++)
-		seq_printf(s, ";rate%d,count%d", i, i);
-	seq_printf(s, "\n");
-
-	seq_printf(s, "#set_power;macaddr");
-	for (i = 0; i < IEEE80211_TX_MAX_RATES; i++)
-		seq_printf(s, ";txpwr%d", i);
-	seq_printf(s, "\n");
-
-	seq_printf(s, "#set_rates_power;macaddr");
-	for (i = 0; i < IEEE80211_TX_MAX_RATES; i++)
-		seq_printf(s, ";rate%d,count%d,txpwr%d", i, i, i);
-	seq_printf(s, "\n");
-
-	seq_printf(s, "#set_probe;macaddr;rate,count,txpwr\n");
-
-	/*
-	 * Commands targeting 'all' instead of a mac address are executed for
-	 * all currently connected STAs. However, this has no effect on any
-	 * future STAs. For 'rc_mode' and 'tpc_mode', an STA is by default in
-	 * 'auto' mode after connecting.
-	 */
-	seq_printf(s, "#rc_mode;macaddr;mode\n");
-	seq_printf(s, "#rc_mode;all;mode\n");
-	seq_printf(s, "#tpc_mode;macaddr;mode\n");
-	seq_printf(s, "#tpc_mode;all;mode\n");
-
-	seq_printf(s, "#reset_stats;macaddr\n");
-	seq_printf(s, "#reset_stats;all\n");
-
-	for (i = 0; i < MINSTREL_GROUPS_NB; i++) {
-		const struct mcs_group *g = &minstrel_mcs_groups[i];
-		const char *type;
-
-		if (i == MINSTREL_CCK_GROUP)
-			type = "cck";
-		else if (i == MINSTREL_OFDM_GROUP)
-			type = "ofdm";
-		else if (g->flags & IEEE80211_TX_RC_VHT_MCS)
-			type = "vht";
-		else
-			type = "ht";
-
-		seq_printf(s, "group;%x;%x;%s;%x;%x;%x;",
-			   i, (u32) MI_RATE(i, 0), type, g->streams, g->bw,
-			   !!(g->flags & IEEE80211_TX_RC_SHORT_GI));
-		minstrel_ht_print_rate_durations(s, i);
-		seq_printf(s, "\n");
-	}
-	seq_printf(s, "sample_table;%x;%x", SAMPLE_COLUMNS, MCS_GROUP_RATES);
-	for (i = 0; i < SAMPLE_COLUMNS; i++) {
-		seq_printf(s, ";");
-		for (j = 0; j < MCS_GROUP_RATES; j++) {
-			if (j == 0)
-				seq_printf(s, "%x", sample_table[i][j]);
-			else
-				seq_printf(s, ",%x", sample_table[i][j]);
-		}
-	}
-	seq_printf(s, "\n");
-
-	return 0;
-}
-
-static int
-minstrel_ht_read_phy_info(struct seq_file *s, void *data)
-{
-	struct wiphy *wiphy = container_of(s->private, struct wiphy, dev);
-	struct ieee80211_local *local = wiphy_priv(wiphy);
-	struct ieee80211_sub_if_data *sdata;
-	int i = 0;
-
-	seq_printf(s, "drv;%s\n", wiphy_dev(wiphy)->driver->name);
-
-	mutex_lock(&local->iflist_mtx);
-	list_for_each_entry(sdata, &local->interfaces, list) {
-		if (!i) {
-			seq_printf(s, "if;%s", sdata->name);
-			i++;
-        	} else {
-			seq_printf(s, ",%s", sdata->name);
-		}
-	}
-	mutex_unlock(&local->iflist_mtx);
-	seq_printf(s, "\n");
-
-	if (ieee80211_hw_check(&local->hw, SUPPORTS_TPC_PER_PACKET)) {
-		seq_printf(s, "tpc;pkt");
-	} else if (ieee80211_hw_check(&local->hw, SUPPORTS_TPC_PER_MRR)) {
-		seq_printf(s, "tpc;mrr");
-	} else {
-		seq_printf(s, "tpc;not\n");
-		goto skip_tpc;
-	}
-
-	seq_printf(s, ";%u", local->hw.n_txpower_ranges);
-	for (i = 0; i < local->hw.n_txpower_ranges; i++) {
-		struct ieee80211_hw_txpower_range *rng = &local->hw.txpower_ranges[i];
-		seq_printf(s, ";%x,%x,%x,%x", rng->start_idx, rng->n_levels,
-			   rng->start_pwr, rng->pwr_step);
-	}
-	seq_printf(s, "\n");
-
-skip_tpc:
-	return 0;
-}
-
-static struct dentry *
-create_buf_file_cb(const char *filename, struct dentry *parent, umode_t mode,
-		   struct rchan_buf *buf, int *is_global)
-{
-	struct dentry *f;
-
-	f = debugfs_create_file("api_event", mode, parent, buf,
-				&relay_file_operations);
-	if (IS_ERR(f))
-		return NULL;
-
-	*is_global = 1;
-
-	return f;
-}
-
-static int
-remove_buf_file_cb(struct dentry *f)
-{
-	debugfs_remove(f);
-
-	return 0;
-}
-
-static struct rchan_callbacks relay_ev_cb = {
-	.create_buf_file = create_buf_file_cb,
-	.remove_buf_file = remove_buf_file_cb,
-};
-
-static void
-minstrel_ht_dump_sta(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,
-		     const char *type)
-{
-	struct sta_info *sta_info;
-	char info[128 + MINSTREL_GROUPS_NB * 4];
-	int ofs = 0;
-	int i;
-
-	sta_info = container_of(mi->sta, struct sta_info, sta);
-	ofs += scnprintf(info + ofs, sizeof(info) - ofs,
-			 "%llx;sta;%s;%pM;%s;%s;%s;%x;%x;",
-			 (unsigned long long)ktime_get_real_fast_ns(), type,
-			 mi->sta->addr, sta_info->sdata->name,
-			 mi->rc_manual ? "manual" : "auto",
-			 mi->tpc_manual ? "manual" : "auto",
-			 mi->overhead, mi->overhead_legacy);
-
-	ofs += scnprintf(info + ofs, sizeof(info) - ofs, "%x",
-			 mi->supported[0]);
-	for (i = 1; i < MINSTREL_GROUPS_NB; i++)
-		ofs += scnprintf(info + ofs, sizeof(info) - ofs, ";%x",
-				 mi->supported[i]);
-
-	ofs += scnprintf(info + ofs, sizeof(info) - ofs, "\n");
-
-	relay_write(mp->relay_ev, info, ofs);
-	relay_flush(mp->relay_ev);
-}
-
-void __minstrel_ht_report_sample_rates(struct minstrel_priv *mp,
-				       struct minstrel_ht_sta *mi)
-{
-	char line[128];
-	int i, j, ofs;
-
-	ofs = scnprintf(line, sizeof(line), "%llx;sample_rates;%pM",
-			(unsigned long long)ktime_get_real_fast_ns(),
-			mi->sta->addr);
-
-	for (i = 0; i < __MINSTREL_SAMPLE_TYPE_MAX; i++)
-		for (j = 0; j < MINSTREL_SAMPLE_RATES; j++)
-			ofs += scnprintf(line + ofs, sizeof(line), ";%x",
-					 mi->sample[i].cur_sample_rates[j]);
-
-	ofs += scnprintf(line + ofs, sizeof(line), "\n");
-
-	spin_lock_bh(&mp->relay_lock);
-
-	relay_write(mp->relay_ev, line, ofs);
-	relay_flush(mp->relay_ev);
-
-	spin_lock_bh(&mp->relay_lock);
-}
-
-static void
-minstrel_ht_dump_stations(struct minstrel_priv *mp, const char *type)
-{
-	struct minstrel_ht_sta *mi;
-
-	rcu_read_lock();
-	spin_lock_bh(&mp->relay_lock);
-
-	list_for_each_entry_rcu(mi, &mp->stations, list)
-		minstrel_ht_dump_sta(mp, mi, type);
-
-	spin_unlock_bh(&mp->relay_lock);
-	rcu_read_unlock();
-}
-
-static void
-minstrel_ht_api_start(struct minstrel_priv *mp, char *params)
-{
-	char *cur;
-	u8 mask = mp->monitor;
-
-	while ((cur = strsep(&params, ";")) != NULL) {
-		if (!strlen(cur))
-			break;
-
-		if (!strcmp(cur, "txs"))
-			mask |= MINSTREL_MONITOR_TXS;
-		else if (!strcmp(cur, "rxs"))
-			mask |= MINSTREL_MONITOR_RXS;
-		else if (!strcmp(cur, "sta"))
-			mask |= MINSTREL_MONITOR_STA;
-		else if (!strcmp(cur, "stats"))
-			mask |= MINSTREL_MONITOR_STATS;
-		else if (!strcmp(cur, "tprc_echo"))
-			mask |= MINSTREL_ECHO_TPRC;
-	}
-
-	if (!mask)
-		mask = MINSTREL_MONITOR_TXS;
-
-	if (!mp->monitor)
-		minstrel_ht_dump_stations(mp, "add");
-	mp->monitor = mask | MINSTREL_MONITOR_STA;
-}
-
-static void
-minstrel_ht_api_stop(struct minstrel_priv *mp, char *params)
-{
-	u8 mask = 0;
-	char *cur;
-
-	if (!params || !strncmp(params, "all", 3))
-		goto set_mask;
-
-	mask = mp->monitor;
-	while ((cur = strsep(&params, ";")) != NULL) {
-		if (!strlen(cur))
-			break;
-
-		if (!strcmp(cur, "txs"))
-			mask &= ~MINSTREL_MONITOR_TXS;
-		else if (!strcmp(cur, "rxs"))
-			mask &= ~MINSTREL_MONITOR_RXS;
-		else if (!strcmp(cur, "sta"))
-			mask &= ~MINSTREL_MONITOR_STA;
-		else if (!strcmp(cur, "stats"))
-			mask &= ~MINSTREL_MONITOR_STATS;
-		else if (!strcmp(cur, "tprc_echo"))
-			mask &= ~MINSTREL_ECHO_TPRC;
-	}
-
-set_mask:
-	spin_lock_bh(&mp->relay_lock);
-	mp->monitor = mask;
-	relay_reset(mp->relay_ev);
-	spin_unlock_bh(&mp->relay_lock);
-}
-
-static void
-minstrel_ht_reset_sample_table(struct minstrel_ht_sta *mi)
-{
-	int i;
-
-	for (i = 0; i < __MINSTREL_SAMPLE_TYPE_MAX; i++)
-		memset(mi->sample[i].sample_rates, 0,
-		       sizeof(mi->sample[i].sample_rates));
-
-	mi->sample_seq = 0;
-	mi->user_sample_rate = -1;
-	mi->user_sample_count = 0;
-	mi->user_sample_txpower = -1;
-}
-
-static int
-minstrel_ht_api_sta_set_rc_mode(struct minstrel_ht_sta *mi, char *mode)
-{
-	int i;
-
-	if (!mode)
-		return -EINVAL;
-
-	if (!strcmp(mode, "manual"))
-		mi->rc_manual = true;
-	else if (!strcmp(mode, "auto"))
-		mi->rc_manual = false;
-	else
-		return -EINVAL;
-
-	minstrel_ht_reset_sample_table(mi);
-	for (i = 0; i < sizeof(mi->ratetbl->rate); i++) {
-		mi->ratetbl->rate[i].idx = -1;
-		mi->ratetbl->rate[i].count = 0;
-		mi->ratetbl->rate[i].count_rts = 0;
-		mi->ratetbl->rate[i].count_cts = 0;
-	}
-
-	return 0;
-}
-
-static int
-minstrel_ht_api_sta_set_tpc_mode(struct minstrel_ht_sta *mi, char *mode)
-{
-	int i;
-
-	if (!mode)
-		return -EINVAL;
-
-	if (!strcmp(mode, "manual"))
-		mi->tpc_manual = true;
-	else if (!strcmp(mode, "auto"))
-		mi->tpc_manual = false;
-	else
-		return -EINVAL;
-
-	for (i = 0; i < sizeof(mi->ratetbl->rate); i++)
-		mi->ratetbl->rate[i].txpower_idx = -1;
-
-	return 0;
-}
-
-static struct minstrel_ht_sta *
-minstrel_ht_api_get_sta(struct minstrel_priv *mp, const u8 *macaddr)
-{
-	struct minstrel_ht_sta *mi;
-
-	rcu_read_lock();
-	list_for_each_entry_rcu(mi, &mp->stations, list) {
-		if (!memcmp(mi->sta->addr, macaddr, ETH_ALEN))
-			goto out;
-	}
-	mi = NULL;
-
-out:
-	rcu_read_unlock();
-	return mi;
-}
-
-static int
-minstrel_ht_get_args(char **dest, int dest_size, char *str, char *sep)
-{
-	int i, n;
-
-	for (i = 0, n = 0; i < dest_size; i++) {
-		if (!str) {
-			dest[i] = NULL;
-			continue;
-		}
-
-		dest[i] = strsep(&str, sep);
-		if (dest[i])
-			n++;
-	}
-
-	return n;
-}
-
-static bool
-minstrel_ht_valid_rate(struct minstrel_ht_sta *mi, u32 rate)
-{
-	int group, idx;
-
-	group = MI_RATE_GROUP(rate);
-	if (group >= MINSTREL_GROUPS_NB)
-		return false;
-
-	idx = MI_RATE_IDX(rate);
-
-	return !!(mi->supported[group] & BIT(idx));
-}
-
-static int
-minstrel_ht_rate_from_str(struct minstrel_ht_sta *mi, const char *str)
-{
-	unsigned int rate;
-
-	if (kstrtouint(str, 16, &rate))
-		return -EINVAL;
-
-	if (!minstrel_ht_valid_rate(mi, rate))
-		return -EINVAL;
-
-	return rate;
-}
-
-static int
-minstrel_ht_set_probe_rate(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,
-			   char *arg_str)
-{
-	char *rate_str, *count_str, *txpwr_str;
-	unsigned int count;
-	int rate;
-	u16 raw_txpwr;
-	s16 max_power, txpwr = -1;
-
-	if (!arg_str)
-		return -EINVAL;
-	if (!mi->rc_manual)
-		return -EPERM;
-
-	txpwr_str = arg_str;
-	rate_str = strsep(&txpwr_str, ",");
-	count_str = strsep(&txpwr_str, ",");
-
-	rate = minstrel_ht_rate_from_str(mi, rate_str);
-	if (rate < 0)
-		return rate;
-
-	if (!count_str || kstrtouint(count_str, 16, &count))
-		return -EINVAL;
-
-	if (txpwr_str) {
-		if (!mi->tpc_manual)
-			return -EPERM;
-
-		max_power = ieee80211_hw_get_max_txpower_idx(mp->hw);
-		if (kstrtou16(txpwr_str, 16, &raw_txpwr))
-			return -EINVAL;
-
-		txpwr = (raw_txpwr <= S16_MAX) ? (s16)raw_txpwr : -1;
-		if (txpwr > max_power)
-			return -ERANGE;
-	}
-
-	mi->user_sample_rate = rate;
-	mi->user_sample_count = count;
-	mi->user_sample_txpower = txpwr;
-	return 0;
-}
-
-static int
-minstrel_ht_ratetbl_set_rate_count(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,
-				   char **rate_count_str, unsigned int stage)
-{
-	char *rate_str, *count_str;
-	unsigned int count;
-	int rate;
-
-	rate_str = strsep(rate_count_str, ",");
-	count_str = strsep(rate_count_str, ",");
-
-	if (!rate_str || !count_str)
-		return -EINVAL;
-
-	rate = minstrel_ht_rate_from_str(mi, rate_str);
-	if (rate < 0)
-		return -EINVAL;
-
-	if (kstrtouint(count_str, 16, &count))
-		return -EINVAL;
-
-	minstrel_ht_set_rate(mp, mi, mi->ratetbl, stage, rate);
-	mi->ratetbl->rate[stage].count = count;
-	mi->ratetbl->rate[stage].count_rts = count;
-	mi->ratetbl->rate[stage].count_cts = count;
-
-	return 0;
-}
-
-static int
-minstrel_ht_ratetbl_set_txpower(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,
-			       char *txpwr_str, int stage, s16 max_power)
-{
-	u16 raw;
-	s16 txpwr;
-
-	if (!txpwr_str)
-		return -EINVAL;
-
-	if (kstrtou16(txpwr_str, 16, &raw))
-		return -EINVAL;
-
-	txpwr = (raw <= S16_MAX) ? (s16)raw : -1;
-	if (txpwr > max_power)
-		return -ERANGE;
-
-	mi->ratetbl->rate[stage].txpower_idx = txpwr;
-	return 0;
-}
-
-static int
-minstrel_ht_set_ratetbl(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,
-			enum api_cmd cmd, char **args_str, unsigned int n_args)
-{
-	struct ieee80211_sta_rates *ratetbl;
-	unsigned int i;
-	int err = 0;
-	s16 max_tx_power;
-	bool rc, tpc;
-
-	if (!args_str || !n_args)
-		return -EINVAL;
-
-	rc = (cmd == STA_CMD_RC || cmd == STA_CMD_TPRC);
-	tpc = (cmd == STA_CMD_TPC || cmd == STA_CMD_TPRC);
-
-	if ((rc && !minstrel_ht_sta_rc_manual_mode(mi)) ||
-	    (tpc && !minstrel_ht_sta_tpc_manual_mode(mi)))
-		return -EPERM;
-
-	if (tpc)
-		max_tx_power = ieee80211_hw_get_max_txpower_idx(mp->hw);
-
-	for (i = 0; i < min_t(unsigned int, n_args, sizeof(ratetbl->rate)); i++) {
-		if (rc) {
-			err = minstrel_ht_ratetbl_set_rate_count(mp, mi, &args_str[i], i);
-			if (err)
-				return err;
-		}
-
-		if (tpc) {
-			err = minstrel_ht_ratetbl_set_txpower(mp, mi, args_str[i], i,
-							      max_tx_power);
-			if (err)
-				return err;
-		}
-	}
-	if (!i)
-		return err;
-
-	for (; i < IEEE80211_TX_RATE_TABLE_SIZE; i++) {
-		mi->ratetbl->rate[i].idx = -1;
-		mi->ratetbl->rate[i].count = 0;
-		mi->ratetbl->rate[i].txpower_idx = -1;
-	}
-
-	minstrel_ht_update_rates(mp, mi, false);
-	return err;
-}
-
-static void
-minstrel_ht_api_sta_reset_rc_stats(struct minstrel_priv *mp, struct minstrel_ht_sta *mi)
-{
-	mi->ampdu_len = 0;
-	mi->ampdu_packets = 0;
-	mi->avg_ampdu_len = MINSTREL_FRAC(1, 1);
-	memset(&mi->max_tp_rate, 0, sizeof(u16) * MAX_THR_RATES);
-	mi->max_prob_rate = 0;
-	mi->total_packets = 0;
-	mi->sample_packets = 0;
-	mi->sample_rate = 0;
-	memset(&mi->sample, 0, sizeof(struct minstrel_sample_category) *
-			       __MINSTREL_SAMPLE_TYPE_MAX);
-	memset(&mi->groups, 0, sizeof(struct minstrel_mcs_group_data) *
-			       MINSTREL_GROUPS_NB);
-
-	minstrel_ht_update_stats(mp, mi);
-}
-
-static int
-minstrel_ht_api_sta_cmd(struct minstrel_priv *mp, enum api_cmd cmd,
-			char *arg_str)
-{
-	struct minstrel_ht_sta *mi;
-	uint8_t macaddr[ETH_ALEN];
-	char *args[5];
-	int n_args;
-	int ret = -EINVAL;
-
-	n_args = minstrel_ht_get_args(args, ARRAY_SIZE(args), arg_str, ";");
-	if (!args[0])
-		return -EINVAL;
-
-	if (!mac_pton(args[0], macaddr))
-		return -EINVAL;
-
-	mi = minstrel_ht_api_get_sta(mp, macaddr);
-	if (!mi)
-		return -ENOENT;
-
-	spin_lock_bh(&mi->lock);
-
-	switch (cmd) {
-	case STA_CMD_PROBE:
-		ret = minstrel_ht_set_probe_rate(mp, mi, args[1]);
-		break;
-	case STA_CMD_RC:
-	case STA_CMD_TPC:
-	case STA_CMD_TPRC:
-		ret = minstrel_ht_set_ratetbl(mp, mi, cmd, &args[1], n_args - 1);
-		break;
-	case STA_CMD_RC_MODE:
-		ret = minstrel_ht_api_sta_set_rc_mode(mi, args[1]);
-		break;
-	case STA_CMD_TPC_MODE:
-		ret = minstrel_ht_api_sta_set_tpc_mode(mi, args[1]);
-		break;
-	case STA_CMD_RESET_STATS:
-		minstrel_ht_api_sta_reset_rc_stats(mp, mi);
-		break;
-	default:
-		ret = -EINVAL;
-		break;
-	}
-
-	spin_unlock_bh(&mi->lock);
-	return ret;
-}
-
-static int
-minstrel_ht_api_exec_cmd_for_all(struct minstrel_priv *mp, enum api_cmd cmd,
-				 char *args)
-{
-	struct minstrel_ht_sta *mi;
-	int ret = 0;
-
-	rcu_read_lock();
-
-	switch (cmd) {
-	case STA_CMD_RESET_STATS:
-		list_for_each_entry_rcu(mi, &mp->stations, list)
-			minstrel_ht_api_sta_reset_rc_stats(mp, mi);
-		break;
-	case STA_CMD_RC_MODE:
-		list_for_each_entry_rcu(mi, &mp->stations, list)
-			minstrel_ht_api_sta_set_rc_mode(mi, args);
-		break;
-	case STA_CMD_TPC_MODE:
-		list_for_each_entry_rcu(mi, &mp->stations, list)
-			minstrel_ht_api_sta_set_tpc_mode(mi, args);
-		break;
-	default:
-		ret = -EPERM;
-	}
-
-	rcu_read_unlock();
-	return ret;
-}
-
-static int
-minstrel_ht_api_exec_cmd(struct minstrel_priv *mp, enum api_cmd cmd, char *args)
-{
-	int err = 0;
-
-	switch (cmd) {
-	case PHY_CMD_START:
-		minstrel_ht_api_start(mp, args);
-		break;
-	case PHY_CMD_STOP:
-		minstrel_ht_api_stop(mp, args);
-		break;
-	case PHY_CMD_DUMP:
-		minstrel_ht_dump_stations(mp, "dump");
-		break;
-	case STA_CMD_RC_MODE:
-	case STA_CMD_TPC_MODE:
-	case STA_CMD_RESET_STATS:
-		if (args && !strncmp(args, "all", 3)) {
-			strsep(&args, ";");
-			err = minstrel_ht_api_exec_cmd_for_all(mp, cmd, args);
-			break;
-		}
-		fallthrough;
-	case STA_CMD_RC:
-	case STA_CMD_TPC:
-	case STA_CMD_TPRC:
-	case STA_CMD_PROBE:
-		err = minstrel_ht_api_sta_cmd(mp, cmd, args);
-		break;
-	default:
-		err = -EINVAL;
-	}
-
-	return err;
-}
-
-static int
-minstrel_ht_api_exec_and_echo_cmd(struct minstrel_priv *mp, enum api_cmd cmd,
-				  char* cmd_str, char *args)
-{
-	char buf[96];
-	int err = 0, len;
-
-	/* Store command with timestamp, args may be modified later */
-	len = scnprintf(buf, sizeof(buf), "%llx;%s",
-			(unsigned long long)ktime_get_real_fast_ns(),
-			cmd_str);
-	if (args)
-		len += scnprintf(buf + len, sizeof(buf) - len, ";%s\n", args);
-	else
-		len += scnprintf(buf + len, sizeof(buf) - len, "\n");
-
-	err = minstrel_ht_api_exec_cmd(mp, cmd, args);
-	if (err)
-		return err;
-
-	/* Echo command to api_event */
-	spin_lock_bh(&mp->relay_lock);
-	relay_write(mp->relay_ev, buf, len);
-	relay_flush(mp->relay_ev);
-	spin_unlock_bh(&mp->relay_lock);
-
-	return 0;
-}
-
-static ssize_t
-minstrel_ht_control_write(struct file *file, const char __user *userbuf,
-			  size_t count, loff_t *ppos)
-{
-	struct minstrel_priv *mp = file->private_data;
-	enum api_cmd cmd;
-	char *pos, *cur;
-	char buf[64];
-	size_t len = count;
-	int err;
-	bool echo = true;
-
-	if (len > sizeof(buf) - 1)
-		return -EINVAL;
-
-	if (copy_from_user(buf, userbuf, len))
-		return -EFAULT;
-
-	if (count > 0 && buf[len - 1] == '\n')
-		len--;
-
-	buf[len] = 0;
-	if (!len)
-		return count;
-
-	pos = buf;
-	cur = strsep(&pos, ";");
-
-	if (!strcmp(cur, "set_rates_power") || !strcmp(cur, "rates")) {
-		cmd = STA_CMD_TPRC;
-		echo = (mp->monitor & MINSTREL_ECHO_TPRC);
-	} else if (!strcmp(cur, "set_power")) {
-		cmd = STA_CMD_TPC;
-		echo = (mp->monitor & MINSTREL_ECHO_TPRC);
-	} else if (!strcmp(cur, "set_rates")) {
-		cmd = STA_CMD_RC;
-		echo = (mp->monitor & MINSTREL_ECHO_TPRC);
-	} else if (!strcmp(cur, "set_probe")) {
-		cmd = STA_CMD_PROBE;
-		echo = (mp->monitor & MINSTREL_ECHO_TPRC);
-	} else if (!strcmp(cur, "dump")) {
-		cmd = PHY_CMD_DUMP;
-		echo = false;
-	} else if (!strcmp(cur, "start")) {
-		cmd = PHY_CMD_START;
-	} else if (!strcmp(cur, "stop")) {
-		cmd = PHY_CMD_STOP;
-	} else if (!strcmp(cur, "rc_mode")) {
-		cmd = STA_CMD_RC_MODE;
-	} else if (!strcmp(cur, "tpc_mode")) {
-		cmd = STA_CMD_TPC_MODE;
-	} else if (!strcmp(cur, "reset_stats")) {
-		cmd = STA_CMD_RESET_STATS;
-	} else {
-		return -EINVAL;
-	}
-
-	err = (echo) ? minstrel_ht_api_exec_and_echo_cmd(mp, cmd, cur, pos)
-		     : minstrel_ht_api_exec_cmd(mp, cmd, pos);
-	if (err)
-		return err;
-
-	return count;
-}
-
-static const struct file_operations fops_control = {
-	.open = simple_open,
-	.llseek = generic_file_llseek,
-	.write = minstrel_ht_control_write,
-};
-
-void minstrel_ht_sta_update(struct minstrel_priv *mp, struct minstrel_ht_sta *mi)
-{
-	bool add = list_empty(&mi->list);
-
-	if (add) {
-		spin_lock_bh(&mp->sta_wlock);
-		list_add_rcu(&mi->list, &mp->stations);
-		spin_unlock_bh(&mp->sta_wlock);
-	}
-
-	if (mp->monitor) {
-		spin_lock_bh(&mp->relay_lock);
-		minstrel_ht_dump_sta(mp, mi, add ? "add" : "update");
-		spin_unlock_bh(&mp->relay_lock);
-	}
-}
-
-void minstrel_ht_sta_remove(struct minstrel_priv *mp, struct minstrel_ht_sta *mi)
-{
-	char info[64];
-	int ofs = 0;
-
-	spin_lock_bh(&mp->sta_wlock);
-
-	list_del_rcu(&mi->list);
-	INIT_LIST_HEAD_RCU(&mi->list);
-	kfree(mi->ratetbl);
-
-	spin_unlock_bh(&mp->sta_wlock);
-
-	if (!mp->monitor)
-		return;
-
-
-	ofs = scnprintf(info, sizeof(info), "%llx;sta;remove;%pM;;;\n",
-			(unsigned long long)ktime_get_real_fast_ns(),
-			mi->sta->addr);
-
-	spin_lock_bh(&mp->relay_lock);
-
-	relay_write(mp->relay_ev, info, ofs);
-	relay_flush(mp->relay_ev);
-
-	spin_unlock_bh(&mp->relay_lock);
-}
-
-void __minstrel_ht_report_tx_status(struct minstrel_priv *mp,
-				    struct minstrel_ht_sta *mi,
-				    struct ieee80211_tx_info *info,
-				    u16 *rate_list,
-				    s16 *txpwr_list,
-				    int n_rates)
-{
-	char txs[64 + IEEE80211_TX_MAX_RATES * 14];
-	int ofs = 0;
-	int i;
-
-	if (!n_rates)
-		return;
-
-
-	ofs += scnprintf(txs, sizeof(txs), "%llx;txs;%pM;%x;%x;%x",
-			 (unsigned long long)ktime_get_real_fast_ns(),
-			 mi->sta->addr,
-			 info->status.ampdu_len,
-			 info->status.ampdu_ack_len,
-			 !!(info->flags & IEEE80211_TX_CTL_RATE_CTRL_PROBE));
-
-	for (i = 0; i < n_rates; i++) {
-		ofs += scnprintf(txs + ofs, sizeof(txs) - ofs, ";%x,%x,",
-				 rate_list[i], info->status.rates[i].count);
-		if (txpwr_list[i] < 0)
-			continue;
-
-		ofs += scnprintf(txs + ofs, sizeof(txs) - ofs, "%x",
-				 (u16)(txpwr_list[i]));
-	}
-
-	for (; i < IEEE80211_TX_MAX_RATES; i++)
-		ofs += scnprintf(txs + ofs, sizeof(txs) - ofs, ";,,");
-
-	ofs += scnprintf(txs + ofs, sizeof(txs) - ofs, "\n");
-
-	spin_lock_bh(&mp->relay_lock);
-
-	relay_write(mp->relay_ev, txs, ofs);
-	relay_flush(mp->relay_ev);
-
-	spin_unlock_bh(&mp->relay_lock);
-}
-
-void __minstrel_ht_report_rx_status(struct minstrel_priv *mp, u8 *addr,
-				    int last_signal, u8 chain_status,
-				    s8 *chain_signal)
-{
-	char rxs[64 + IEEE80211_MAX_CHAINS * 8];
-	int ofs = 0;
-	int i;
-
-	ofs += scnprintf(rxs, sizeof(rxs), "%llx;rxs;%pM;%x",
-			 (unsigned long long)ktime_get_real_fast_ns(),
-			 addr, last_signal);
-
-	for (i = 0; i < IEEE80211_MAX_CHAINS; i++)
-	ofs += scnprintf(rxs + ofs, sizeof(rxs) - ofs, ";%x",
-			 (chain_status & BIT(i) ? chain_signal[i] : 0x7f));
-
-	ofs += scnprintf(rxs + ofs, sizeof(rxs) - ofs, "\n");
-
-	spin_lock_bh(&mp->relay_lock);
-
-	relay_write(mp->relay_ev, rxs, ofs);
-	relay_flush(mp->relay_ev);
-
-	spin_unlock_bh(&mp->relay_lock);
-}
-
-void __minstrel_ht_report_rate_update(struct minstrel_priv *mp,
-				      struct minstrel_ht_sta *mi, u16 rate,
-				      struct minstrel_rate_stats *mrs)
-{
-	char stat[100];
-	int ofs;
-	int tp;
-
-	tp = minstrel_ht_get_tp_avg(mi, MI_RATE_GROUP(rate), MI_RATE_IDX(rate),
-				    mrs->prob_avg);
-
-
-	ofs = scnprintf(stat, sizeof(stat),
-			"%llx;stats;%pM;%x;%x;%x;%x;%x;%x;%x\n",
-			(unsigned long long)ktime_get_real_fast_ns(),
-			mi->sta->addr, rate,
-			MINSTREL_TRUNC(mrs->prob_avg * 1000), tp,
-			mrs->last_success,
-			mrs->last_attempts,
-			mrs->succ_hist, mrs->att_hist);
-
-	spin_lock_bh(&mp->relay_lock);
-
-	relay_write(mp->relay_ev, stat, ofs);
-	relay_flush(mp->relay_ev);
-
-	spin_unlock_bh(&mp->relay_lock);
-}
-
-void __minstrel_ht_report_best_rates(struct minstrel_priv *mp, struct minstrel_ht_sta *mi)
-{
-	char line[128];
-	int i, ofs;
-
-	ofs = scnprintf(line, sizeof(line), "%llx;best_rates;%pM",
-	                (unsigned long long)ktime_get_real_fast_ns(),
-	                mi->sta->addr);
-
-	for (i = 0; i < MAX_THR_RATES; i++)
-		ofs += scnprintf(line + ofs, sizeof(line), ";%x", mi->max_tp_rate[i]);
-
-	ofs += scnprintf(line + ofs, sizeof(line), ";%x\n", mi->max_prob_rate);
-
-	spin_lock_bh(&mp->relay_lock);
-
-	relay_write(mp->relay_ev, line, ofs);
-	relay_flush(mp->relay_ev);
-
-	spin_unlock_bh(&mp->relay_lock);
-}
-
-void minstrel_ht_add_debugfs_api(struct ieee80211_hw *hw, void *priv,
-				 struct dentry *dir)
-{
-	struct minstrel_priv *mp = priv;
-
-	spin_lock_init(&mp->relay_lock);
-	spin_lock_init(&mp->sta_wlock);
-
-	INIT_LIST_HEAD_RCU(&mp->stations);
-	mp->relay_ev = relay_open("api_event", dir, 256, 512, &relay_ev_cb,
-				  NULL);
-	debugfs_create_devm_seqfile(&hw->wiphy->dev, "api_info",
-				    dir, minstrel_ht_read_api_info);
-	debugfs_create_devm_seqfile(&hw->wiphy->dev, "api_phy",
-				    dir, minstrel_ht_read_phy_info);
-	debugfs_create_file("api_control", 0200, dir, mp, &fops_control);
-}
-
-void minstrel_ht_remove_debugfs_api(void *priv)
-{
-	struct minstrel_priv *mp = priv;
-
-	spin_lock_bh(&mp->relay_lock);
-	if (mp->relay_ev)
-		relay_close(mp->relay_ev);
-
-	spin_unlock_bh(&mp->relay_lock);
-}
--- a/net/mac80211/rc80211_minstrel_ht.c
+++ b/net/mac80211/rc80211_minstrel_ht.c
@@ -1101,7 +1101,7 @@ minstrel_ht_update_stats(struct minstrel
 			changed = mrs->attempts > 0;
 			minstrel_ht_calc_rate_stats(mp, mrs);
 			if (changed)
-				minstrel_ht_report_rate_update(mp, mi, index,
+				orca_report_rate_update(mp, mi, index,
 							       mrs);
 
 			if (mrs->att_hist)
@@ -1151,11 +1151,11 @@ minstrel_ht_update_stats(struct minstrel
 
 	mi->max_prob_rate = tmp_max_prob_rate;
 
-	minstrel_ht_report_best_rates(mp, mi);
+	orca_report_best_rates(mp, mi);
 
-	if (!minstrel_ht_sta_rc_manual_mode(mi)) {
+	if (!orca_sta_rc_manual_mode(mi)) {
 		minstrel_ht_refill_sample_rates(mi);
-		minstrel_ht_report_sample_rates(mp, mi);
+		orca_report_sample_rates(mp, mi);
 	}
 
 #ifdef CPTCFG_MAC80211_DEBUGFS
@@ -1332,7 +1332,7 @@ minstrel_ht_tx_status(void *priv, struct
 		}
 	}
 
-	minstrel_ht_report_tx_status(mp, mi, info, rate_list, txpwr_list, i);
+	orca_report_tx_status(mp, mi, info, rate_list, txpwr_list, i);
 
 	if (mp->hw->max_rates > 1) {
 		/*
@@ -1541,8 +1541,8 @@ minstrel_ht_update_rates(struct minstrel
 	if (!rates)
 		return;
 
-	manual_rc = minstrel_ht_sta_rc_manual_mode(mi) && !force;
-	manual_tpc = minstrel_ht_sta_tpc_manual_mode(mi) && !force;
+	manual_rc = orca_sta_rc_manual_mode(mi) && !force;
+	manual_tpc = orca_sta_tpc_manual_mode(mi) && !force;
 
 	if (manual_rc) {
 		if (mi->ratetbl->rate[0].idx >= 0) {
@@ -1587,7 +1587,7 @@ minstrel_ht_get_sample_rate(struct minst
 {
 	u8 seq;
 
-	if (mp->hw->max_rates > 1 && !minstrel_ht_sta_rc_manual_mode(mi)) {
+	if (mp->hw->max_rates > 1 && !orca_sta_rc_manual_mode(mi)) {
 		seq = mi->sample_seq;
 		mi->sample_seq = (seq + 1) % ARRAY_SIZE(minstrel_sample_seq);
 		seq = minstrel_sample_seq[seq];
@@ -1626,11 +1626,11 @@ minstrel_ht_get_rate(void *priv, struct
 	    (info->control.flags & IEEE80211_TX_CTRL_PORT_CTRL_PROTO))
 		return;
 
-	if (minstrel_ht_sta_tpc_manual_mode(mi) && mi->user_sample_txpower != -1) {
+	if (orca_sta_tpc_manual_mode(mi) && mi->user_sample_txpower != -1) {
 		sample_txpower = mi->user_sample_txpower;
 		mi->user_sample_txpower = -1;
 	}
-	if (minstrel_ht_sta_rc_manual_mode(mi) && mi->user_sample_rate != -1) {
+	if (orca_sta_rc_manual_mode(mi) && mi->user_sample_rate != -1) {
 		sample_idx = mi->user_sample_rate;
 		if (mi->user_sample_count > 0 &&
 		    mi->user_sample_count <= IEEE80211_MAX_TX_RETRY)
@@ -1868,7 +1868,7 @@ minstrel_ht_update_caps(void *priv, stru
 	minstrel_ht_update_stats(mp, mi);
 	minstrel_ht_update_rates(mp, mi, true);
 
-	minstrel_ht_sta_update(mp, mi);
+	orca_sta_update(mp, mi);
 
 	spin_unlock_bh(&mi->lock);
 }
@@ -1908,7 +1908,8 @@ minstrel_ht_alloc_sta(void *priv, struct
 
 	mi = kzalloc(sizeof(*mi), gfp);
 	spin_lock_init(&mi->lock);
-#ifdef CPTCFG_MAC80211_RC_MINSTREL_DEBUGFS_API
+
+#ifdef CPTCFG_MAC80211_ORCA_UAPI
 	INIT_LIST_HEAD(&mi->list);
 	mi->ratetbl = kzalloc(sizeof(*mi->ratetbl), gfp);
 	mi->user_sample_rate = -1;
@@ -1922,7 +1923,7 @@ minstrel_ht_alloc_sta(void *priv, struct
 static void
 minstrel_ht_free_sta(void *priv, struct ieee80211_sta *sta, void *priv_sta)
 {
-	minstrel_ht_sta_remove(priv, priv_sta);
+	orca_sta_remove(priv, priv_sta);
 	kfree(priv_sta);
 }
 
@@ -2079,14 +2080,14 @@ static void minstrel_ht_add_debugfs(stru
 				   &mp->sampling_interval,
 				   &minstrel_ht_debugfs_hz_fops);
 
-	minstrel_ht_add_debugfs_api(hw, priv, debugfsdir);
+	orca_add_debugfs_api(hw, priv, debugfsdir);
 }
 #endif
 
 static void
 minstrel_ht_free(void *priv)
 {
-	minstrel_ht_remove_debugfs_api(priv);
+	orca_remove_debugfs_api(priv);
 	kfree(priv);
 }
 
--- a/net/mac80211/rc80211_minstrel_ht.h
+++ b/net/mac80211/rc80211_minstrel_ht.h
@@ -72,11 +72,11 @@
 #define MINSTREL_SAMPLE_RATES		5 /* rates per sample type */
 #define MINSTREL_SAMPLE_INTERVAL	(HZ / 50)
 
-#define MINSTREL_MONITOR_STA		BIT(0)
-#define MINSTREL_MONITOR_TXS		BIT(1)
-#define MINSTREL_MONITOR_RXS		BIT(2)
-#define MINSTREL_MONITOR_STATS		BIT(3)
-#define MINSTREL_ECHO_TPRC		BIT(7)
+#define ORCA_MONITOR_STA		BIT(0)
+#define ORCA_MONITOR_TXS		BIT(1)
+#define ORCA_MONITOR_RXS		BIT(2)
+#define ORCA_MONITOR_STATS		BIT(3)
+#define ORCA_ECHO_TPRC			BIT(7)
 
 struct minstrel_priv {
 	struct ieee80211_hw *hw;
@@ -100,7 +100,7 @@ struct minstrel_priv {
 	u32 fixed_rate_idx;
 	unsigned int sampling_interval;
 #endif
-#ifdef CPTCFG_MAC80211_RC_MINSTREL_DEBUGFS_API
+#ifdef CPTCFG_MAC80211_ORCA_UAPI
 	struct rchan *relay_ev;
 	spinlock_t relay_lock;
 
@@ -169,7 +169,7 @@ struct minstrel_sample_category {
 };
 
 struct minstrel_ht_sta {
-#ifdef CPTCFG_MAC80211_RC_MINSTREL_DEBUGFS_API
+#ifdef CPTCFG_MAC80211_ORCA_UAPI
 	struct list_head list;
 	u32 user_sample_rate;
 	s16 user_sample_txpower;
@@ -225,113 +225,111 @@ struct minstrel_ht_sta {
 
 void minstrel_ht_add_sta_debugfs(void *priv, void *priv_sta, struct dentry *dir);
 
-#ifdef CPTCFG_MAC80211_RC_MINSTREL_DEBUGFS_API
-void minstrel_ht_sta_update(struct minstrel_priv *mp, struct minstrel_ht_sta *mi);
-void minstrel_ht_sta_remove(struct minstrel_priv *mp, struct minstrel_ht_sta *mi);
-void __minstrel_ht_report_tx_status(struct minstrel_priv *mp,
-				    struct minstrel_ht_sta *mi,
-				    struct ieee80211_tx_info *info,
-				    u16 *rate_list, s16* txpwr_list, int n_rates);
-void __minstrel_ht_report_rx_status(struct minstrel_priv *mp, u8 *addr,
-                                    int last_signal, u8 chain_status,
-                                    s8 *chain_signal);
-void __minstrel_ht_report_rate_update(struct minstrel_priv *mp,
-				      struct minstrel_ht_sta *mi, u16 rate,
-				      struct minstrel_rate_stats *mrs);
-void __minstrel_ht_report_best_rates(struct minstrel_priv *mp,
-				     struct minstrel_ht_sta *mi);
-void __minstrel_ht_report_sample_rates(struct minstrel_priv *mp,
-				       struct minstrel_ht_sta *mi);
-void minstrel_ht_add_debugfs_api(struct ieee80211_hw *hw, void *priv,
+#ifdef CPTCFG_MAC80211_ORCA_UAPI
+void orca_sta_update(struct minstrel_priv *mp, struct minstrel_ht_sta *mi);
+void orca_sta_remove(struct minstrel_priv *mp, struct minstrel_ht_sta *mi);
+void __orca_report_tx_status(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,
+			     struct ieee80211_tx_info *info,
+			     u16 *rate_list, s16* txpwr_list, int n_rates);
+void __orca_report_rx_status(struct minstrel_priv *mp, u8 *addr,
+			     int last_signal, u8 chain_status,
+			     s8 *chain_signal);
+void __orca_report_rate_update(struct minstrel_priv *mp,
+			       struct minstrel_ht_sta *mi, u16 rate,
+			       struct minstrel_rate_stats *mrs);
+void __orca_report_best_rates(struct minstrel_priv *mp,
+			      struct minstrel_ht_sta *mi);
+void __orca_report_sample_rates(struct minstrel_priv *mp,
+				struct minstrel_ht_sta *mi);
+void orca_add_debugfs_api(struct ieee80211_hw *hw, void *priv,
 				 struct dentry *dir);
-void minstrel_ht_remove_debugfs_api(void *priv);
+void orca_remove_debugfs_api(void *priv);
 #else
 static inline void
-minstrel_ht_sta_update(struct minstrel_priv *mp, struct minstrel_ht_sta *mi)
+orca_sta_update(struct minstrel_priv *mp, struct minstrel_ht_sta *mi)
 {
 }
 static inline void
-minstrel_ht_sta_remove(struct minstrel_priv *mp, struct minstrel_ht_sta *mi)
+orca_sta_remove(struct minstrel_priv *mp, struct minstrel_ht_sta *mi)
 {
 }
 static inline void
-minstrel_ht_add_debugfs_api(struct ieee80211_hw *hw, void *priv,
+orca_add_debugfs_api(struct ieee80211_hw *hw, void *priv,
 			    struct dentry *dir)
 {
 }
 static inline void
-minstrel_ht_remove_debugfs_api(void *priv)
+orca_remove_debugfs_api(void *priv)
 {
 }
 #endif
 
 static inline void
-minstrel_ht_report_tx_status(struct minstrel_priv *mp,
-			     struct minstrel_ht_sta *mi,
-			     struct ieee80211_tx_info *info,
-			     u16 *rate_list, s16 *txpwr_list, int n_rates)
+orca_report_tx_status(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,
+		      struct ieee80211_tx_info *info,
+		      u16 *rate_list, s16 *txpwr_list, int n_rates)
 {
-#ifdef CPTCFG_MAC80211_RC_MINSTREL_DEBUGFS_API
-	if (!(mp->monitor & MINSTREL_MONITOR_TXS))
+#ifdef CPTCFG_MAC80211_ORCA_UAPI
+	if (!(mp->monitor & ORCA_MONITOR_TXS))
 		return;
 
-	__minstrel_ht_report_tx_status(mp, mi, info, rate_list, txpwr_list,
+	__orca_report_tx_status(mp, mi, info, rate_list, txpwr_list,
 				       n_rates);
 #endif
 }
 
 static inline void
-minstrel_ht_report_rx_status(struct minstrel_priv *mp, u8 *addr,
-                             int last_signal, u8 chain_status, s8 *chain_signal)
+orca_report_rx_status(struct minstrel_priv *mp, u8 *addr, int last_signal,
+		      u8 chain_status, s8 *chain_signal)
 {
-#ifdef CPTCFG_MAC80211_RC_MINSTREL_DEBUGFS_API
-	if (!(mp->monitor & MINSTREL_MONITOR_RXS))
+#ifdef CPTCFG_MAC80211_ORCA_UAPI
+	if (!(mp->monitor & ORCA_MONITOR_RXS))
 		return;
 
-	__minstrel_ht_report_rx_status(mp, addr, last_signal,
+	__orca_report_rx_status(mp, addr, last_signal,
 	                               chain_status, chain_signal);
 #endif
 }
 
 static inline void
-minstrel_ht_report_rate_update(struct minstrel_priv *mp,
-			       struct minstrel_ht_sta *mi, u16 rate,
-			       struct minstrel_rate_stats *mrs)
+orca_report_rate_update(struct minstrel_priv *mp,
+			struct minstrel_ht_sta *mi, u16 rate,
+			struct minstrel_rate_stats *mrs)
 {
-#ifdef CPTCFG_MAC80211_RC_MINSTREL_DEBUGFS_API
-	if (!(mp->monitor & MINSTREL_MONITOR_STATS))
+#ifdef CPTCFG_MAC80211_ORCA_UAPI
+	if (!(mp->monitor & ORCA_MONITOR_STATS))
 		return;
 
-	__minstrel_ht_report_rate_update(mp, mi, rate, mrs);
+	__orca_report_rate_update(mp, mi, rate, mrs);
 #endif
 }
 
 static inline void
-minstrel_ht_report_best_rates(struct minstrel_priv *mp, struct minstrel_ht_sta *mi)
+orca_report_best_rates(struct minstrel_priv *mp, struct minstrel_ht_sta *mi)
 {
-#ifdef CPTCFG_MAC80211_RC_MINSTREL_DEBUGFS_API
-	if (!(mp->monitor & MINSTREL_MONITOR_STATS))
+#ifdef CPTCFG_MAC80211_ORCA_UAPI
+	if (!(mp->monitor & ORCA_MONITOR_STATS))
 		return;
 
-	__minstrel_ht_report_best_rates(mp, mi);
+	__orca_report_best_rates(mp, mi);
 #endif
 }
 
 static inline void
-minstrel_ht_report_sample_rates(struct minstrel_priv *mp, struct minstrel_ht_sta *mi)
+orca_report_sample_rates(struct minstrel_priv *mp, struct minstrel_ht_sta *mi)
 {
-#ifdef CPTCFG_MAC80211_RC_MINSTREL_DEBUGFS_API
-	if (!(mp->monitor & MINSTREL_MONITOR_STATS))
+#ifdef CPTCFG_MAC80211_ORCA_UAPI
+	if (!(mp->monitor & ORCA_MONITOR_STATS))
 		return;
 
-	__minstrel_ht_report_sample_rates(mp, mi);
+	__orca_report_sample_rates(mp, mi);
 #endif
 }
 
 static inline bool
-minstrel_ht_sta_rc_manual_mode(struct minstrel_ht_sta *mi)
+orca_sta_rc_manual_mode(struct minstrel_ht_sta *mi)
 {
-#ifdef CPTCFG_MAC80211_RC_MINSTREL_DEBUGFS_API
+#ifdef CPTCFG_MAC80211_ORCA_UAPI
 	return mi->rc_manual;
 #else
 	return false;
@@ -339,9 +337,9 @@ minstrel_ht_sta_rc_manual_mode(struct mi
 }
 
 static inline bool
-minstrel_ht_sta_tpc_manual_mode(struct minstrel_ht_sta *mi)
+orca_sta_tpc_manual_mode(struct minstrel_ht_sta *mi)
 {
-#ifdef CPTCFG_MAC80211_RC_MINSTREL_DEBUGFS_API
+#ifdef CPTCFG_MAC80211_ORCA_UAPI
 	return mi->tpc_manual;
 #else
 	return false;
--- a/net/mac80211/rx.c
+++ b/net/mac80211/rx.c
@@ -1797,7 +1797,7 @@ ieee80211_rx_h_sta_process(struct ieee80
 	}
 
 	if (rx->local->rate_ctrl && test_sta_flag(sta, WLAN_STA_RATE_CONTROL)) {
-		minstrel_ht_report_rx_status(rx->local->rate_ctrl->priv, sta->addr,
+		orca_report_rx_status(rx->local->rate_ctrl->priv, sta->addr,
 			(!(status->flag & RX_FLAG_NO_SIGNAL_VAL) ? status->signal : -1),
 			status->chains, status->chain_signal);
 	}
--- a/net/mac80211/Makefile
+++ b/net/mac80211/Makefile
@@ -63,8 +63,8 @@ rc80211_minstrel-y := \
 rc80211_minstrel-$(CPTCFG_MAC80211_DEBUGFS) += \
 	rc80211_minstrel_ht_debugfs.o
 
-rc80211_minstrel-$(CPTCFG_MAC80211_RC_MINSTREL_DEBUGFS_API) += \
-	rc80211_minstrel_ht_api.o
+rc80211_minstrel-$(CPTCFG_MAC80211_ORCA_UAPI) += \
+	orca_uapi.o
 
 mac80211-$(CPTCFG_MAC80211_RC_MINSTREL) += $(rc80211_minstrel-y)
 
--- a/net/mac80211/Kconfig
+++ b/net/mac80211/Kconfig
@@ -29,15 +29,6 @@ config MAC80211_RC_MINSTREL
 	help
 	  This option enables the 'minstrel' TX rate control algorithm
 
-config MAC80211_RC_MINSTREL_DEBUGFS_API
-	bool "Minstrel debugfs userspace control API"
-	depends on MAC80211_RC_MINSTREL
-	depends on MAC80211_DEBUGFS
-	select RELAY
-	help
-	  This option creates debugfs files that allow user space to observe
-	  and/or control minstrel rate selection behavior
-
 choice
 	prompt "Default rate control algorithm"
 	depends on MAC80211_HAS_RC
@@ -107,6 +98,15 @@ config MAC80211_MESSAGE_TRACING
 	  need to be present in the binary and formatted at
 	  runtime for tracing.
 
+config MAC80211_ORCA_UAPI
+        bool "ORCA Userspace API"
+        depends on MAC80211_RC_MINSTREL
+        depends on MAC80211_DEBUGFS
+        select RELAY
+        help
+          This option creates debugfs files that allow user space to observe
+          and/or control minstrel rate selection behavior
+
 menuconfig MAC80211_DEBUG_MENU
 	bool "Select mac80211 debugging features"
 	depends on MAC80211
--- a/local-symbols
+++ b/local-symbols
@@ -41,7 +41,7 @@ LIB80211_DEBUG=
 MAC80211=
 MAC80211_HAS_RC=
 MAC80211_RC_MINSTREL=
-MAC80211_RC_MINSTREL_DEBUGFS_API=
+MAC80211_ORCA_UAPI=
 MAC80211_RC_DEFAULT_MINSTREL=
 MAC80211_RC_DEFAULT=
 MAC80211_MESH=
--- /dev/null
+++ b/net/mac80211/orca_uapi.c
@@ -0,0 +1,1075 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * ORCA - Open-Source Resource Control API
+ *
+ * Copyright (C) 2021 Felix Fietkau <nbd@nbd.name>
+ * Copyright (C) 2021-2023 SupraCoNeX <supraconex@gmail.com>
+ */
+#include <linux/kernel.h>
+#include <linux/debugfs.h>
+#include <linux/relay.h>
+#include <net/mac80211.h>
+#include "ieee80211_i.h"
+#include "rate.h"
+#include "rc80211_minstrel_ht.h"
+
+#define ORCA_VERSION "2"
+
+extern u8 sample_table[SAMPLE_COLUMNS][MCS_GROUP_RATES];
+
+enum api_cmd {
+	PHY_CMD_START,
+	PHY_CMD_STOP,
+	PHY_CMD_DUMP,
+
+	/* per-STA commands */
+	STA_CMD_RC_MODE,
+	STA_CMD_TPC_MODE,
+	STA_CMD_RESET_STATS,
+	STA_CMD_PROBE,
+	STA_CMD_TPRC,
+	STA_CMD_TPC,
+	STA_CMD_RC,
+};
+
+static void
+orca_print_rate_durations(struct seq_file *s, int group)
+{
+	const struct mcs_group *g = &minstrel_mcs_groups[group];
+	int n_rates;
+	int i;
+
+	if (g->flags & IEEE80211_TX_RC_VHT_MCS)
+		n_rates = 10;
+	else
+		n_rates = 8;
+
+	seq_printf(s, "%x", g->duration[0] << g->shift);
+	for (i = 1; i < n_rates; i++)
+		seq_printf(s, ";%x", g->duration[i] << g->shift);
+
+	for (; i < MCS_GROUP_RATES; i++)
+		seq_printf(s, ";");
+}
+
+static int
+orca_read_api_info(struct seq_file *s, void *data)
+{
+	int i, j;
+	seq_printf(s, "orca_version;%s\n", ORCA_VERSION);
+
+	seq_printf(s, "#group;index;offset;type;nss;bw;gi");
+	for (i = 0; i < MCS_GROUP_RATES; i++)
+	        seq_printf(s, ";airtime%d", i);
+        seq_printf(s, "\n");
+
+	seq_printf(s, "#sta;action;macaddr;iface;rc_mode;tpc_mode;overhead_mcs;overhead_legacy");
+	for (i = 0; i < MINSTREL_GROUPS_NB; i++)
+	        seq_printf(s, ";mcs%d", i);
+	seq_printf(s, "\n");
+
+	seq_printf(s, "#txs;macaddr;num_frames;num_acked;probe");
+	for (i = 0; i < IEEE80211_TX_MAX_RATES; i++)
+		seq_printf(s, ";rate%d,count%d,txpwr%d", i, i, i);
+	seq_printf(s, "\n");
+
+	seq_printf(s, "#rxs;macaddr;last_signal");
+	for (i = 0; i < IEEE80211_MAX_CHAINS; i++)
+		seq_printf(s, ";signal%d", i);
+	seq_printf(s, "\n");
+
+	seq_printf(s, "#stats;macaddr;rate;avg_prob;avg_tp;cur_success;"
+		      "cur_attempts;hist_success;hist_attempts\n");
+	seq_printf(s, "#best_rates;macaddr");
+	for (i = 0; i < MAX_THR_RATES; i++)
+		seq_printf(s, ";maxtp%d", i);
+	seq_printf(s, ";maxprob\n");
+
+	seq_printf(s, "#sample_rates;macaddr");
+	for (i = 0; i < MINSTREL_SAMPLE_RATES; i++)
+	        seq_printf(s, ";inc%d", i);
+	for (i = 0; i < MINSTREL_SAMPLE_RATES; i++)
+	        seq_printf(s, ";jump%d", i);
+	for (i = 0; i < MINSTREL_SAMPLE_RATES; i++)
+	        seq_printf(s, ";slow%d", i);
+	seq_printf(s, "\n");
+
+	seq_printf(s, "#sample_table;cols;rows");
+	for (i = 0; i < SAMPLE_COLUMNS; i++)
+		seq_printf(s, ";column%d", i);
+	seq_printf(s, "\n");
+
+	seq_printf(s, "#start;txs;rxs;stats;sta;tprc_echo\n");
+	seq_printf(s, "#stop;txs;rxs;stats;sta;tprc_echo\n");
+
+	seq_printf(s, "#set_rates;macaddr");
+	for (i = 0; i < IEEE80211_TX_MAX_RATES; i++)
+		seq_printf(s, ";rate%d,count%d", i, i);
+	seq_printf(s, "\n");
+
+	seq_printf(s, "#set_power;macaddr");
+	for (i = 0; i < IEEE80211_TX_MAX_RATES; i++)
+		seq_printf(s, ";txpwr%d", i);
+	seq_printf(s, "\n");
+
+	seq_printf(s, "#set_rates_power;macaddr");
+	for (i = 0; i < IEEE80211_TX_MAX_RATES; i++)
+		seq_printf(s, ";rate%d,count%d,txpwr%d", i, i, i);
+	seq_printf(s, "\n");
+
+	seq_printf(s, "#set_probe;macaddr;rate,count,txpwr\n");
+
+	/*
+	 * Commands targeting 'all' instead of a mac address are executed for
+	 * all currently connected STAs. However, this has no effect on any
+	 * future STAs. For 'rc_mode' and 'tpc_mode', an STA is by default in
+	 * 'auto' mode after connecting.
+	 */
+	seq_printf(s, "#rc_mode;macaddr;mode\n");
+	seq_printf(s, "#rc_mode;all;mode\n");
+	seq_printf(s, "#tpc_mode;macaddr;mode\n");
+	seq_printf(s, "#tpc_mode;all;mode\n");
+
+	seq_printf(s, "#reset_stats;macaddr\n");
+	seq_printf(s, "#reset_stats;all\n");
+
+	for (i = 0; i < MINSTREL_GROUPS_NB; i++) {
+		const struct mcs_group *g = &minstrel_mcs_groups[i];
+		const char *type;
+
+		if (i == MINSTREL_CCK_GROUP)
+			type = "cck";
+		else if (i == MINSTREL_OFDM_GROUP)
+			type = "ofdm";
+		else if (g->flags & IEEE80211_TX_RC_VHT_MCS)
+			type = "vht";
+		else
+			type = "ht";
+
+		seq_printf(s, "group;%x;%x;%s;%x;%x;%x;",
+			   i, (u32) MI_RATE(i, 0), type, g->streams, g->bw,
+			   !!(g->flags & IEEE80211_TX_RC_SHORT_GI));
+		orca_print_rate_durations(s, i);
+		seq_printf(s, "\n");
+	}
+	seq_printf(s, "sample_table;%x;%x", SAMPLE_COLUMNS, MCS_GROUP_RATES);
+	for (i = 0; i < SAMPLE_COLUMNS; i++) {
+		seq_printf(s, ";");
+		for (j = 0; j < MCS_GROUP_RATES; j++) {
+			if (j == 0)
+				seq_printf(s, "%x", sample_table[i][j]);
+			else
+				seq_printf(s, ",%x", sample_table[i][j]);
+		}
+	}
+	seq_printf(s, "\n");
+
+	return 0;
+}
+
+static int
+orca_read_phy_info(struct seq_file *s, void *data)
+{
+	struct wiphy *wiphy = container_of(s->private, struct wiphy, dev);
+	struct ieee80211_local *local = wiphy_priv(wiphy);
+	struct ieee80211_sub_if_data *sdata;
+	int i = 0;
+
+	seq_printf(s, "drv;%s\n", wiphy_dev(wiphy)->driver->name);
+
+	mutex_lock(&local->iflist_mtx);
+	list_for_each_entry(sdata, &local->interfaces, list) {
+		if (!i) {
+			seq_printf(s, "if;%s", sdata->name);
+			i++;
+        	} else {
+			seq_printf(s, ",%s", sdata->name);
+		}
+	}
+	mutex_unlock(&local->iflist_mtx);
+	seq_printf(s, "\n");
+
+	if (ieee80211_hw_check(&local->hw, SUPPORTS_TPC_PER_PACKET)) {
+		seq_printf(s, "tpc;pkt");
+	} else if (ieee80211_hw_check(&local->hw, SUPPORTS_TPC_PER_MRR)) {
+		seq_printf(s, "tpc;mrr");
+	} else {
+		seq_printf(s, "tpc;not\n");
+		goto skip_tpc;
+	}
+
+	seq_printf(s, ";%u", local->hw.n_txpower_ranges);
+	for (i = 0; i < local->hw.n_txpower_ranges; i++) {
+		struct ieee80211_hw_txpower_range *rng = &local->hw.txpower_ranges[i];
+		seq_printf(s, ";%x,%x,%x,%x", rng->start_idx, rng->n_levels,
+			   rng->start_pwr, rng->pwr_step);
+	}
+	seq_printf(s, "\n");
+
+skip_tpc:
+	return 0;
+}
+
+static struct dentry *
+create_buf_file_cb(const char *filename, struct dentry *parent, umode_t mode,
+		   struct rchan_buf *buf, int *is_global)
+{
+	struct dentry *f;
+
+	f = debugfs_create_file("api_event", mode, parent, buf,
+				&relay_file_operations);
+	if (IS_ERR(f))
+		return NULL;
+
+	*is_global = 1;
+
+	return f;
+}
+
+static int
+remove_buf_file_cb(struct dentry *f)
+{
+	debugfs_remove(f);
+
+	return 0;
+}
+
+static struct rchan_callbacks relay_ev_cb = {
+	.create_buf_file = create_buf_file_cb,
+	.remove_buf_file = remove_buf_file_cb,
+};
+
+static void
+orca_dump_sta(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,
+	      const char *type)
+{
+	struct sta_info *sta_info;
+	char info[128 + MINSTREL_GROUPS_NB * 4];
+	int ofs = 0;
+	int i;
+
+	sta_info = container_of(mi->sta, struct sta_info, sta);
+	ofs += scnprintf(info + ofs, sizeof(info) - ofs,
+			 "%llx;sta;%s;%pM;%s;%s;%s;%x;%x;",
+			 (unsigned long long)ktime_get_real_fast_ns(), type,
+			 mi->sta->addr, sta_info->sdata->name,
+			 mi->rc_manual ? "manual" : "auto",
+			 mi->tpc_manual ? "manual" : "auto",
+			 mi->overhead, mi->overhead_legacy);
+
+	ofs += scnprintf(info + ofs, sizeof(info) - ofs, "%x",
+			 mi->supported[0]);
+	for (i = 1; i < MINSTREL_GROUPS_NB; i++)
+		ofs += scnprintf(info + ofs, sizeof(info) - ofs, ";%x",
+				 mi->supported[i]);
+
+	ofs += scnprintf(info + ofs, sizeof(info) - ofs, "\n");
+
+	relay_write(mp->relay_ev, info, ofs);
+	relay_flush(mp->relay_ev);
+}
+
+void __orca_report_sample_rates(struct minstrel_priv *mp,
+				struct minstrel_ht_sta *mi)
+{
+	char line[128];
+	int i, j, ofs;
+
+	ofs = scnprintf(line, sizeof(line), "%llx;sample_rates;%pM",
+			(unsigned long long)ktime_get_real_fast_ns(),
+			mi->sta->addr);
+
+	for (i = 0; i < __MINSTREL_SAMPLE_TYPE_MAX; i++)
+		for (j = 0; j < MINSTREL_SAMPLE_RATES; j++)
+			ofs += scnprintf(line + ofs, sizeof(line), ";%x",
+					 mi->sample[i].cur_sample_rates[j]);
+
+	ofs += scnprintf(line + ofs, sizeof(line), "\n");
+
+	spin_lock_bh(&mp->relay_lock);
+
+	relay_write(mp->relay_ev, line, ofs);
+	relay_flush(mp->relay_ev);
+
+	spin_unlock_bh(&mp->relay_lock);
+}
+
+static void
+orca_dump_stations(struct minstrel_priv *mp, const char *type)
+{
+	struct minstrel_ht_sta *mi;
+
+	rcu_read_lock();
+	spin_lock_bh(&mp->relay_lock);
+
+	list_for_each_entry_rcu(mi, &mp->stations, list)
+		orca_dump_sta(mp, mi, type);
+
+	spin_unlock_bh(&mp->relay_lock);
+	rcu_read_unlock();
+}
+
+static void
+orca_start_monitoring(struct minstrel_priv *mp, char *params)
+{
+	char *cur;
+	u8 mask = mp->monitor;
+
+	while ((cur = strsep(&params, ";")) != NULL) {
+		if (!strlen(cur))
+			break;
+
+		if (!strcmp(cur, "txs"))
+			mask |= ORCA_MONITOR_TXS;
+		else if (!strcmp(cur, "rxs"))
+			mask |= ORCA_MONITOR_RXS;
+		else if (!strcmp(cur, "sta"))
+			mask |= ORCA_MONITOR_STA;
+		else if (!strcmp(cur, "stats"))
+			mask |= ORCA_MONITOR_STATS;
+		else if (!strcmp(cur, "tprc_echo"))
+			mask |= ORCA_ECHO_TPRC;
+	}
+
+	if (!mask)
+		mask = ORCA_MONITOR_TXS;
+
+	if (!mp->monitor)
+		orca_dump_stations(mp, "add");
+	mp->monitor = mask | ORCA_MONITOR_STA;
+}
+
+static void
+orca_stop_monitoring(struct minstrel_priv *mp, char *params)
+{
+	u8 mask = 0;
+	char *cur;
+
+	if (!params || !strncmp(params, "all", 3))
+		goto set_mask;
+
+	mask = mp->monitor;
+	while ((cur = strsep(&params, ";")) != NULL) {
+		if (!strlen(cur))
+			break;
+
+		if (!strcmp(cur, "txs"))
+			mask &= ~ORCA_MONITOR_TXS;
+		else if (!strcmp(cur, "rxs"))
+			mask &= ~ORCA_MONITOR_RXS;
+		else if (!strcmp(cur, "sta"))
+			mask &= ~ORCA_MONITOR_STA;
+		else if (!strcmp(cur, "stats"))
+			mask &= ~ORCA_MONITOR_STATS;
+		else if (!strcmp(cur, "tprc_echo"))
+			mask &= ~ORCA_ECHO_TPRC;
+	}
+
+set_mask:
+	spin_lock_bh(&mp->relay_lock);
+	mp->monitor = mask;
+	relay_reset(mp->relay_ev);
+	spin_unlock_bh(&mp->relay_lock);
+}
+
+static void
+orca_reset_sample_table(struct minstrel_ht_sta *mi)
+{
+	int i;
+
+	for (i = 0; i < __MINSTREL_SAMPLE_TYPE_MAX; i++)
+		memset(mi->sample[i].sample_rates, 0,
+		       sizeof(mi->sample[i].sample_rates));
+
+	mi->sample_seq = 0;
+	mi->user_sample_rate = -1;
+	mi->user_sample_count = 0;
+	mi->user_sample_txpower = -1;
+}
+
+static int
+orca_sta_set_rc_mode(struct minstrel_ht_sta *mi, char *mode)
+{
+	int i;
+
+	if (!mode)
+		return -EINVAL;
+
+	if (!strcmp(mode, "manual"))
+		mi->rc_manual = true;
+	else if (!strcmp(mode, "auto"))
+		mi->rc_manual = false;
+	else
+		return -EINVAL;
+
+	orca_reset_sample_table(mi);
+	for (i = 0; i < sizeof(mi->ratetbl->rate); i++) {
+		mi->ratetbl->rate[i].idx = -1;
+		mi->ratetbl->rate[i].count = 0;
+		mi->ratetbl->rate[i].count_rts = 0;
+		mi->ratetbl->rate[i].count_cts = 0;
+	}
+
+	return 0;
+}
+
+static int
+orca_sta_set_tpc_mode(struct minstrel_ht_sta *mi, char *mode)
+{
+	int i;
+
+	if (!mode)
+		return -EINVAL;
+
+	if (!strcmp(mode, "manual"))
+		mi->tpc_manual = true;
+	else if (!strcmp(mode, "auto"))
+		mi->tpc_manual = false;
+	else
+		return -EINVAL;
+
+	for (i = 0; i < sizeof(mi->ratetbl->rate); i++)
+		mi->ratetbl->rate[i].txpower_idx = -1;
+
+	return 0;
+}
+
+static struct minstrel_ht_sta *
+orca_get_sta(struct minstrel_priv *mp, const u8 *macaddr)
+{
+	struct minstrel_ht_sta *mi;
+
+	rcu_read_lock();
+	list_for_each_entry_rcu(mi, &mp->stations, list) {
+		if (!memcmp(mi->sta->addr, macaddr, ETH_ALEN))
+			goto out;
+	}
+	mi = NULL;
+
+out:
+	rcu_read_unlock();
+	return mi;
+}
+
+static int
+orca_get_args(char **dest, int dest_size, char *str, char *sep)
+{
+	int i, n;
+
+	for (i = 0, n = 0; i < dest_size; i++) {
+		if (!str) {
+			dest[i] = NULL;
+			continue;
+		}
+
+		dest[i] = strsep(&str, sep);
+		if (dest[i])
+			n++;
+	}
+
+	return n;
+}
+
+static bool
+orca_is_valid_rate(struct minstrel_ht_sta *mi, u32 rate)
+{
+	int group, idx;
+
+	group = MI_RATE_GROUP(rate);
+	if (group >= MINSTREL_GROUPS_NB)
+		return false;
+
+	idx = MI_RATE_IDX(rate);
+
+	return !!(mi->supported[group] & BIT(idx));
+}
+
+static int
+orca_rate_from_str(struct minstrel_ht_sta *mi, const char *str)
+{
+	unsigned int rate;
+
+	if (kstrtouint(str, 16, &rate))
+		return -EINVAL;
+
+	if (!orca_is_valid_rate(mi, rate))
+		return -EINVAL;
+
+	return rate;
+}
+
+static int
+orca_set_probe(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,
+	       char *arg_str)
+{
+	char *rate_str, *count_str, *txpwr_str;
+	unsigned int count;
+	int rate;
+	u16 raw_txpwr;
+	s16 max_power, txpwr = -1;
+
+	if (!arg_str)
+		return -EINVAL;
+	if (!mi->rc_manual)
+		return -EPERM;
+
+	txpwr_str = arg_str;
+	rate_str = strsep(&txpwr_str, ",");
+	count_str = strsep(&txpwr_str, ",");
+
+	rate = orca_rate_from_str(mi, rate_str);
+	if (rate < 0)
+		return rate;
+
+	if (!count_str || kstrtouint(count_str, 16, &count))
+		return -EINVAL;
+
+	if (txpwr_str) {
+		if (!mi->tpc_manual)
+			return -EPERM;
+
+		max_power = ieee80211_hw_get_max_txpower_idx(mp->hw);
+		if (kstrtou16(txpwr_str, 16, &raw_txpwr))
+			return -EINVAL;
+
+		txpwr = (raw_txpwr <= S16_MAX) ? (s16)raw_txpwr : -1;
+		if (txpwr > max_power)
+			return -ERANGE;
+	}
+
+	mi->user_sample_rate = rate;
+	mi->user_sample_count = count;
+	mi->user_sample_txpower = txpwr;
+	return 0;
+}
+
+static int
+orca_ratetbl_set_rate_count(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,
+			    char **rate_count_str, unsigned int stage)
+{
+	char *rate_str, *count_str;
+	unsigned int count;
+	int rate;
+
+	rate_str = strsep(rate_count_str, ",");
+	count_str = strsep(rate_count_str, ",");
+
+	if (!rate_str || !count_str)
+		return -EINVAL;
+
+	rate = orca_rate_from_str(mi, rate_str);
+	if (rate < 0)
+		return -EINVAL;
+
+	if (kstrtouint(count_str, 16, &count))
+		return -EINVAL;
+
+	minstrel_ht_set_rate(mp, mi, mi->ratetbl, stage, rate);
+	mi->ratetbl->rate[stage].count = count;
+	mi->ratetbl->rate[stage].count_rts = count;
+	mi->ratetbl->rate[stage].count_cts = count;
+
+	return 0;
+}
+
+static int
+orca_ratetbl_set_txpower(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,
+			 char *txpwr_str, int stage, s16 max_power)
+{
+	u16 raw;
+	s16 txpwr;
+
+	if (!txpwr_str)
+		return -EINVAL;
+
+	if (kstrtou16(txpwr_str, 16, &raw))
+		return -EINVAL;
+
+	txpwr = (raw <= S16_MAX) ? (s16)raw : -1;
+	if (txpwr > max_power)
+		return -ERANGE;
+
+	mi->ratetbl->rate[stage].txpower_idx = txpwr;
+	return 0;
+}
+
+static int
+orca_set_ratetbl(struct minstrel_priv *mp, struct minstrel_ht_sta *mi,
+		 enum api_cmd cmd, char **args_str, unsigned int n_args)
+{
+	struct ieee80211_sta_rates *ratetbl;
+	unsigned int i;
+	int err = 0;
+	s16 max_tx_power;
+	bool rc, tpc;
+
+	if (!args_str || !n_args)
+		return -EINVAL;
+
+	rc = (cmd == STA_CMD_RC || cmd == STA_CMD_TPRC);
+	tpc = (cmd == STA_CMD_TPC || cmd == STA_CMD_TPRC);
+
+	if ((rc && !orca_sta_rc_manual_mode(mi)) ||
+	    (tpc && !orca_sta_tpc_manual_mode(mi)))
+		return -EPERM;
+
+	if (tpc)
+		max_tx_power = ieee80211_hw_get_max_txpower_idx(mp->hw);
+
+	for (i = 0; i < min_t(unsigned int, n_args, sizeof(ratetbl->rate)); i++) {
+		if (rc) {
+			err = orca_ratetbl_set_rate_count(mp, mi, &args_str[i], i);
+			if (err)
+				return err;
+		}
+
+		if (tpc) {
+			err = orca_ratetbl_set_txpower(mp, mi, args_str[i], i,
+						       max_tx_power);
+			if (err)
+				return err;
+		}
+	}
+	if (!i)
+		return err;
+
+	for (; i < IEEE80211_TX_RATE_TABLE_SIZE; i++) {
+		mi->ratetbl->rate[i].idx = -1;
+		mi->ratetbl->rate[i].count = 0;
+		mi->ratetbl->rate[i].txpower_idx = -1;
+	}
+
+	minstrel_ht_update_rates(mp, mi, false);
+	return err;
+}
+
+static void
+orca_sta_reset_rc_stats(struct minstrel_priv *mp, struct minstrel_ht_sta *mi)
+{
+	mi->ampdu_len = 0;
+	mi->ampdu_packets = 0;
+	mi->avg_ampdu_len = MINSTREL_FRAC(1, 1);
+	memset(&mi->max_tp_rate, 0, sizeof(u16) * MAX_THR_RATES);
+	mi->max_prob_rate = 0;
+	mi->total_packets = 0;
+	mi->sample_packets = 0;
+	mi->sample_rate = 0;
+	memset(&mi->sample, 0, sizeof(struct minstrel_sample_category) *
+			       __MINSTREL_SAMPLE_TYPE_MAX);
+	memset(&mi->groups, 0, sizeof(struct minstrel_mcs_group_data) *
+			       MINSTREL_GROUPS_NB);
+
+	minstrel_ht_update_stats(mp, mi);
+}
+
+static int
+orca_sta_cmd(struct minstrel_priv *mp, enum api_cmd cmd, char *arg_str)
+{
+	struct minstrel_ht_sta *mi;
+	uint8_t macaddr[ETH_ALEN];
+	char *args[5];
+	int n_args;
+	int ret = -EINVAL;
+
+	n_args = orca_get_args(args, ARRAY_SIZE(args), arg_str, ";");
+	if (!args[0])
+		return -EINVAL;
+
+	if (!mac_pton(args[0], macaddr))
+		return -EINVAL;
+
+	mi = orca_get_sta(mp, macaddr);
+	if (!mi)
+		return -ENOENT;
+
+	spin_lock_bh(&mi->lock);
+
+	switch (cmd) {
+	case STA_CMD_PROBE:
+		ret = orca_set_probe(mp, mi, args[1]);
+		break;
+	case STA_CMD_RC:
+	case STA_CMD_TPC:
+	case STA_CMD_TPRC:
+		ret = orca_set_ratetbl(mp, mi, cmd, &args[1], n_args - 1);
+		break;
+	case STA_CMD_RC_MODE:
+		ret = orca_sta_set_rc_mode(mi, args[1]);
+		break;
+	case STA_CMD_TPC_MODE:
+		ret = orca_sta_set_tpc_mode(mi, args[1]);
+		break;
+	case STA_CMD_RESET_STATS:
+		orca_sta_reset_rc_stats(mp, mi);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	spin_unlock_bh(&mi->lock);
+	return ret;
+}
+
+static int
+orca_exec_cmd_for_all(struct minstrel_priv *mp, enum api_cmd cmd, char *args)
+{
+	struct minstrel_ht_sta *mi;
+	int ret = 0;
+
+	rcu_read_lock();
+
+	switch (cmd) {
+	case STA_CMD_RESET_STATS:
+		list_for_each_entry_rcu(mi, &mp->stations, list)
+			orca_sta_reset_rc_stats(mp, mi);
+		break;
+	case STA_CMD_RC_MODE:
+		list_for_each_entry_rcu(mi, &mp->stations, list)
+			orca_sta_set_rc_mode(mi, args);
+		break;
+	case STA_CMD_TPC_MODE:
+		list_for_each_entry_rcu(mi, &mp->stations, list)
+			orca_sta_set_tpc_mode(mi, args);
+		break;
+	default:
+		ret = -EPERM;
+	}
+
+	rcu_read_unlock();
+	return ret;
+}
+
+static int
+orca_exec_cmd(struct minstrel_priv *mp, enum api_cmd cmd, char *args)
+{
+	int err = 0;
+
+	switch (cmd) {
+	case PHY_CMD_START:
+		orca_start_monitoring(mp, args);
+		break;
+	case PHY_CMD_STOP:
+		orca_stop_monitoring(mp, args);
+		break;
+	case PHY_CMD_DUMP:
+		orca_dump_stations(mp, "dump");
+		break;
+	case STA_CMD_RC_MODE:
+	case STA_CMD_TPC_MODE:
+	case STA_CMD_RESET_STATS:
+		if (args && !strncmp(args, "all", 3)) {
+			strsep(&args, ";");
+			err = orca_exec_cmd_for_all(mp, cmd, args);
+			break;
+		}
+		fallthrough;
+	case STA_CMD_RC:
+	case STA_CMD_TPC:
+	case STA_CMD_TPRC:
+	case STA_CMD_PROBE:
+		err = orca_sta_cmd(mp, cmd, args);
+		break;
+	default:
+		err = -EINVAL;
+	}
+
+	return err;
+}
+
+static int
+orca_exec_and_echo_cmd(struct minstrel_priv *mp, enum api_cmd cmd,
+		       char* cmd_str, char *args)
+{
+	char buf[96];
+	int err = 0, len;
+
+	/* Store command with timestamp, args may be modified later */
+	len = scnprintf(buf, sizeof(buf), "%llx;%s",
+			(unsigned long long)ktime_get_real_fast_ns(),
+			cmd_str);
+	if (args)
+		len += scnprintf(buf + len, sizeof(buf) - len, ";%s\n", args);
+	else
+		len += scnprintf(buf + len, sizeof(buf) - len, "\n");
+
+	err = orca_exec_cmd(mp, cmd, args);
+	if (err)
+		return err;
+
+	/* Echo command to api_event */
+	spin_lock_bh(&mp->relay_lock);
+	relay_write(mp->relay_ev, buf, len);
+	relay_flush(mp->relay_ev);
+	spin_unlock_bh(&mp->relay_lock);
+
+	return 0;
+}
+
+static ssize_t
+orca_control_write(struct file *file, const char __user *userbuf, size_t count,
+		   loff_t *ppos)
+{
+	struct minstrel_priv *mp = file->private_data;
+	enum api_cmd cmd;
+	char *pos, *cur;
+	char buf[64];
+	size_t len = count;
+	int err;
+	bool echo = true;
+
+	if (len > sizeof(buf) - 1)
+		return -EINVAL;
+
+	if (copy_from_user(buf, userbuf, len))
+		return -EFAULT;
+
+	if (count > 0 && buf[len - 1] == '\n')
+		len--;
+
+	buf[len] = 0;
+	if (!len)
+		return count;
+
+	pos = buf;
+	cur = strsep(&pos, ";");
+
+	if (!strcmp(cur, "set_rates_power") || !strcmp(cur, "rates")) {
+		cmd = STA_CMD_TPRC;
+		echo = (mp->monitor & ORCA_ECHO_TPRC);
+	} else if (!strcmp(cur, "set_power")) {
+		cmd = STA_CMD_TPC;
+		echo = (mp->monitor & ORCA_ECHO_TPRC);
+	} else if (!strcmp(cur, "set_rates")) {
+		cmd = STA_CMD_RC;
+		echo = (mp->monitor & ORCA_ECHO_TPRC);
+	} else if (!strcmp(cur, "set_probe")) {
+		cmd = STA_CMD_PROBE;
+		echo = (mp->monitor & ORCA_ECHO_TPRC);
+	} else if (!strcmp(cur, "dump")) {
+		cmd = PHY_CMD_DUMP;
+		echo = false;
+	} else if (!strcmp(cur, "start")) {
+		cmd = PHY_CMD_START;
+	} else if (!strcmp(cur, "stop")) {
+		cmd = PHY_CMD_STOP;
+	} else if (!strcmp(cur, "rc_mode")) {
+		cmd = STA_CMD_RC_MODE;
+	} else if (!strcmp(cur, "tpc_mode")) {
+		cmd = STA_CMD_TPC_MODE;
+	} else if (!strcmp(cur, "reset_stats")) {
+		cmd = STA_CMD_RESET_STATS;
+	} else {
+		return -EINVAL;
+	}
+
+	err = (echo) ? orca_exec_and_echo_cmd(mp, cmd, cur, pos)
+		     : orca_exec_cmd(mp, cmd, pos);
+	if (err)
+		return err;
+
+	return count;
+}
+
+static const struct file_operations fops_control = {
+	.open = simple_open,
+	.llseek = generic_file_llseek,
+	.write = orca_control_write,
+};
+
+void orca_sta_update(struct minstrel_priv *mp, struct minstrel_ht_sta *mi)
+{
+	bool add = list_empty(&mi->list);
+
+	if (add) {
+		spin_lock_bh(&mp->sta_wlock);
+		list_add_rcu(&mi->list, &mp->stations);
+		spin_unlock_bh(&mp->sta_wlock);
+	}
+
+	if (mp->monitor) {
+		spin_lock_bh(&mp->relay_lock);
+		orca_dump_sta(mp, mi, add ? "add" : "update");
+		spin_unlock_bh(&mp->relay_lock);
+	}
+}
+
+void orca_sta_remove(struct minstrel_priv *mp, struct minstrel_ht_sta *mi)
+{
+	char info[64];
+	int ofs = 0;
+
+	spin_lock_bh(&mp->sta_wlock);
+
+	list_del_rcu(&mi->list);
+	INIT_LIST_HEAD_RCU(&mi->list);
+	kfree(mi->ratetbl);
+
+	spin_unlock_bh(&mp->sta_wlock);
+
+	if (!mp->monitor)
+		return;
+
+
+	ofs = scnprintf(info, sizeof(info), "%llx;sta;remove;%pM;;;\n",
+			(unsigned long long)ktime_get_real_fast_ns(),
+			mi->sta->addr);
+
+	spin_lock_bh(&mp->relay_lock);
+
+	relay_write(mp->relay_ev, info, ofs);
+	relay_flush(mp->relay_ev);
+
+	spin_unlock_bh(&mp->relay_lock);
+}
+
+void __orca_report_tx_status(struct minstrel_priv *mp,
+				    struct minstrel_ht_sta *mi,
+				    struct ieee80211_tx_info *info,
+				    u16 *rate_list,
+				    s16 *txpwr_list,
+				    int n_rates)
+{
+	char txs[64 + IEEE80211_TX_MAX_RATES * 14];
+	int ofs = 0;
+	int i;
+
+	if (!n_rates)
+		return;
+
+
+	ofs += scnprintf(txs, sizeof(txs), "%llx;txs;%pM;%x;%x;%x",
+			 (unsigned long long)ktime_get_real_fast_ns(),
+			 mi->sta->addr,
+			 info->status.ampdu_len,
+			 info->status.ampdu_ack_len,
+			 !!(info->flags & IEEE80211_TX_CTL_RATE_CTRL_PROBE));
+
+	for (i = 0; i < n_rates; i++) {
+		ofs += scnprintf(txs + ofs, sizeof(txs) - ofs, ";%x,%x,",
+				 rate_list[i], info->status.rates[i].count);
+		if (txpwr_list[i] < 0)
+			continue;
+
+		ofs += scnprintf(txs + ofs, sizeof(txs) - ofs, "%x",
+				 (u16)(txpwr_list[i]));
+	}
+
+	for (; i < IEEE80211_TX_MAX_RATES; i++)
+		ofs += scnprintf(txs + ofs, sizeof(txs) - ofs, ";,,");
+
+	ofs += scnprintf(txs + ofs, sizeof(txs) - ofs, "\n");
+
+	spin_lock_bh(&mp->relay_lock);
+
+	relay_write(mp->relay_ev, txs, ofs);
+	relay_flush(mp->relay_ev);
+
+	spin_unlock_bh(&mp->relay_lock);
+}
+
+void __orca_report_rx_status(struct minstrel_priv *mp, u8 *addr,
+				    int last_signal, u8 chain_status,
+				    s8 *chain_signal)
+{
+	char rxs[64 + IEEE80211_MAX_CHAINS * 8];
+	int ofs = 0;
+	int i;
+
+	ofs += scnprintf(rxs, sizeof(rxs), "%llx;rxs;%pM;%x",
+			 (unsigned long long)ktime_get_real_fast_ns(),
+			 addr, last_signal);
+
+	for (i = 0; i < IEEE80211_MAX_CHAINS; i++)
+	ofs += scnprintf(rxs + ofs, sizeof(rxs) - ofs, ";%x",
+			 (chain_status & BIT(i) ? chain_signal[i] : 0x7f));
+
+	ofs += scnprintf(rxs + ofs, sizeof(rxs) - ofs, "\n");
+
+	spin_lock_bh(&mp->relay_lock);
+
+	relay_write(mp->relay_ev, rxs, ofs);
+	relay_flush(mp->relay_ev);
+
+	spin_unlock_bh(&mp->relay_lock);
+}
+
+void __orca_report_rate_update(struct minstrel_priv *mp,
+				      struct minstrel_ht_sta *mi, u16 rate,
+				      struct minstrel_rate_stats *mrs)
+{
+	char stat[100];
+	int ofs;
+	int tp;
+
+	tp = minstrel_ht_get_tp_avg(mi, MI_RATE_GROUP(rate), MI_RATE_IDX(rate),
+				    mrs->prob_avg);
+
+
+	ofs = scnprintf(stat, sizeof(stat),
+			"%llx;stats;%pM;%x;%x;%x;%x;%x;%x;%x\n",
+			(unsigned long long)ktime_get_real_fast_ns(),
+			mi->sta->addr, rate,
+			MINSTREL_TRUNC(mrs->prob_avg * 1000), tp,
+			mrs->last_success,
+			mrs->last_attempts,
+			mrs->succ_hist, mrs->att_hist);
+
+	spin_lock_bh(&mp->relay_lock);
+
+	relay_write(mp->relay_ev, stat, ofs);
+	relay_flush(mp->relay_ev);
+
+	spin_unlock_bh(&mp->relay_lock);
+}
+
+void __orca_report_best_rates(struct minstrel_priv *mp, struct minstrel_ht_sta *mi)
+{
+	char line[128];
+	int i, ofs;
+
+	ofs = scnprintf(line, sizeof(line), "%llx;best_rates;%pM",
+	                (unsigned long long)ktime_get_real_fast_ns(),
+	                mi->sta->addr);
+
+	for (i = 0; i < MAX_THR_RATES; i++)
+		ofs += scnprintf(line + ofs, sizeof(line), ";%x", mi->max_tp_rate[i]);
+
+	ofs += scnprintf(line + ofs, sizeof(line), ";%x\n", mi->max_prob_rate);
+
+	spin_lock_bh(&mp->relay_lock);
+
+	relay_write(mp->relay_ev, line, ofs);
+	relay_flush(mp->relay_ev);
+
+	spin_unlock_bh(&mp->relay_lock);
+}
+
+void orca_add_debugfs_api(struct ieee80211_hw *hw, void *priv,
+			  struct dentry *dir)
+{
+	struct minstrel_priv *mp = priv;
+
+	spin_lock_init(&mp->relay_lock);
+	spin_lock_init(&mp->sta_wlock);
+
+	INIT_LIST_HEAD_RCU(&mp->stations);
+	mp->relay_ev = relay_open("api_event", dir, 256, 512, &relay_ev_cb,
+				  NULL);
+	debugfs_create_devm_seqfile(&hw->wiphy->dev, "api_info",
+				    dir, orca_read_api_info);
+	debugfs_create_devm_seqfile(&hw->wiphy->dev, "api_phy",
+				    dir, orca_read_phy_info);
+	debugfs_create_file("api_control", 0200, dir, mp, &fops_control);
+}
+
+void orca_remove_debugfs_api(void *priv)
+{
+	struct minstrel_priv *mp = priv;
+
+	spin_lock_bh(&mp->relay_lock);
+	if (mp->relay_ev)
+		relay_close(mp->relay_ev);
+
+	spin_unlock_bh(&mp->relay_lock);
+}
