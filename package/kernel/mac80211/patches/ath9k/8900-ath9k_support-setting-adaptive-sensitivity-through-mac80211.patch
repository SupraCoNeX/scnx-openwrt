--- a/drivers/net/wireless/ath/ath9k/init.c
+++ b/drivers/net/wireless/ath/ath9k/init.c
@@ -974,6 +974,7 @@ static void ath9k_set_hw_capab(struct at
 	ieee80211_hw_set(hw, SUPPORT_FAST_XMIT);
 	ieee80211_hw_set(hw, SUPPORTS_CLONED_SKBS);
 	ieee80211_hw_set(hw, MFP_CAPABLE);
+	ieee80211_hw_set(hw, ADAPTIVE_SENSITIVITY_CTRL);
 
 	if (ath9k_ps_enable)
 		ieee80211_hw_set(hw, SUPPORTS_PS);
--- a/drivers/net/wireless/ath/ath9k/main.c
+++ b/drivers/net/wireless/ath/ath9k/main.c
@@ -2782,6 +2782,51 @@ static int ath9k_get_txpower(struct ieee
 	return 0;
 }
 
+
+static bool ath9k_get_ani(struct ieee80211_hw *hw) {
+	struct ath_softc *sc = hw->priv;
+	struct ath_common *common = &sc->sc_ah->common;
+
+	return !common->disable_ani;
+}
+
+static void ath9k_set_ani(struct ieee80211_hw *hw, bool enable) {
+	struct ath_softc *sc = hw->priv;
+	struct ath_common *common = &sc->sc_ah->common;
+
+	common->disable_ani = !enable;
+	if (enable) {
+		ath_check_ani(sc);
+	} else {
+		clear_bit(ATH_OP_ANI_RUN, &common->op_flags);
+		ath_stop_ani(sc);
+        }
+}
+
+static int
+ath9k_get_feature_state(struct ieee80211_hw *hw, enum ieee80211_feature feature)
+{
+	switch (feature) {
+	case IEEE80211_FEAT_ADAPTIVE_SENSITIVITY:
+		return (int)ath9k_get_ani(hw);
+	default:
+		return -1;
+	}
+}
+
+static int
+ath9k_set_feature_state(struct ieee80211_hw *hw, enum ieee80211_feature feature,
+			bool enable)
+{
+	switch (feature) {
+	case IEEE80211_FEAT_ADAPTIVE_SENSITIVITY:
+		ath9k_set_ani(hw, enable);
+		return 1;
+	default:
+		return -1;
+	}
+}
+
 struct ieee80211_ops ath9k_ops = {
 	.tx 		    = ath9k_tx,
 	.start 		    = ath9k_start,
@@ -2830,4 +2875,6 @@ struct ieee80211_ops ath9k_ops = {
 	.sw_scan_complete   = ath9k_sw_scan_complete,
 	.get_txpower        = ath9k_get_txpower,
 	.wake_tx_queue      = ath9k_wake_tx_queue,
+	.get_feature_state  = ath9k_get_feature_state,
+	.set_feature_state  = ath9k_set_feature_state,
 };
